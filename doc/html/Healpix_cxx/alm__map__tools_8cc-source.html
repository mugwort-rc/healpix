<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>alm_map_tools.cc Source File</title>
<link href="sheet.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>alm_map_tools.cc</h1><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> *  This file is part of Healpix_cxx.</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> *  Healpix_cxx is free software; you can redistribute it and/or modify</span>
00005 <span class="comment"> *  it under the terms of the GNU General Public License as published by</span>
00006 <span class="comment"> *  the Free Software Foundation; either version 2 of the License, or</span>
00007 <span class="comment"> *  (at your option) any later version.</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> *  Healpix_cxx is distributed in the hope that it will be useful,</span>
00010 <span class="comment"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00012 <span class="comment"> *  GNU General Public License for more details.</span>
00013 <span class="comment"> *</span>
00014 <span class="comment"> *  You should have received a copy of the GNU General Public License</span>
00015 <span class="comment"> *  along with Healpix_cxx; if not, write to the Free Software</span>
00016 <span class="comment"> *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
00017 <span class="comment"> *</span>
00018 <span class="comment"> *  For more information about HEALPix, see http://healpix.jpl.nasa.gov</span>
00019 <span class="comment"> */</span>
00020 
00021 <span class="comment">/*</span>
00022 <span class="comment"> *  Healpix_cxx is being developed at the Max-Planck-Institut fuer Astrophysik</span>
00023 <span class="comment"> *  and financially supported by the Deutsches Zentrum fuer Luft- und Raumfahrt</span>
00024 <span class="comment"> *  (DLR).</span>
00025 <span class="comment"> */</span>
00026 
00027 <span class="comment">/*</span>
00028 <span class="comment"> *  Copyright (C) 2003, 2004, 2005, 2006, 2007 Max-Planck-Society</span>
00029 <span class="comment"> *  Author: Martin Reinecke</span>
00030 <span class="comment"> */</span>
00031 
00032 <span class="preprocessor">#include "<a class="code" href="alm__map__tools_8h.html">alm_map_tools.h</a>"</span>
00033 <span class="preprocessor">#include "<a class="code" href="alm_8h.html">alm.h</a>"</span>
00034 <span class="preprocessor">#include "fftpack_support.h"</span>
00035 <span class="preprocessor">#include "ylmgen.h"</span>
00036 <span class="preprocessor">#include "<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/xcomplex_8h.html">xcomplex.h</a>"</span>
00037 
00038 <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00039 
00040 <span class="keyword">namespace </span>{
00041 
00042 <span class="keyword">struct </span>info_comparator
00043   {
00044   <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> <a class="code" href="classringinfo.html">ringinfo</a> &amp;a, <span class="keyword">const</span> <a class="code" href="classringinfo.html">ringinfo</a> &amp;b)
00045     { <span class="keywordflow">return</span> a.<a class="code" href="classringinfo.html#o4">sth</a>&lt;b.<a class="code" href="classringinfo.html#o4">sth</a>; }
00046   };
00047 
00048 <span class="keyword">struct </span>pair_comparator
00049   {
00050   <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> <a class="code" href="classringpair.html">ringpair</a> &amp;a, <span class="keyword">const</span> <a class="code" href="classringpair.html">ringpair</a> &amp;b)
00051     {
00052     <span class="keywordflow">if</span> (a.<a class="code" href="classringpair.html#o0">r1</a>.<a class="code" href="classringinfo.html#o5">nph</a>==b.<a class="code" href="classringpair.html#o0">r1</a>.<a class="code" href="classringinfo.html#o5">nph</a>)
00053       <span class="keywordflow">return</span> a.<a class="code" href="classringpair.html#o0">r1</a>.<a class="code" href="classringinfo.html#o1">phi0</a>&lt;b.<a class="code" href="classringpair.html#o0">r1</a>.<a class="code" href="classringinfo.html#o1">phi0</a>;
00054     <span class="keywordflow">return</span> a.<a class="code" href="classringpair.html#o0">r1</a>.<a class="code" href="classringinfo.html#o5">nph</a>&lt;b.<a class="code" href="classringpair.html#o0">r1</a>.<a class="code" href="classringinfo.html#o5">nph</a>;
00055     }
00056   };
00057 
00058 <span class="keywordtype">void</span> init_lam_fact_1d (<span class="keywordtype">int</span> m, <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> &amp;lam_fact)
00059   {
00060   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> l=m; l&lt;lam_fact.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html#a6">size</a>(); ++l)
00061     lam_fact[l] = (l&lt;2) ? 0. : 2*sqrt((2*l+1.)/(2*l-1.) * (l*l-m*m));
00062   }
00063 
00064 <span class="keywordtype">void</span> init_lam_fact_deriv_1d (<span class="keywordtype">int</span> m, <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> &amp;lam_fact)
00065   {
00066   lam_fact[m]=0;
00067   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> l=m+1; l&lt;lam_fact.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html#a6">size</a>(); ++l)
00068     lam_fact[l] = sqrt((2*l+1.)/(2*l-1.) * (l*l-m*m));
00069   }
00070 
00071 <span class="keywordtype">void</span> init_normal_l (<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> &amp;normal_l)
00072   {
00073   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> l=0; l&lt;normal_l.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html#a6">size</a>(); ++l)
00074     normal_l[l] = (l&lt;2) ? 0. : sqrt(1./((l+2.)*(l+1.)*l*(l-1.)));
00075   }
00076 
00077 <span class="keywordtype">void</span> get_chunk_info (<span class="keywordtype">int</span> nrings, <span class="keywordtype">int</span> &amp;nchunks, <span class="keywordtype">int</span> &amp;chunksize)
00078   {
00079   nchunks = nrings/max(100,nrings/10) + 1;
00080   chunksize = (nrings+nchunks-1)/nchunks;
00081   }
00082 
00083 <span class="keyword">class </span>ringhelper
00084   {
00085   <span class="keyword">private</span>:
00086     <span class="keywordtype">double</span> phi0_;
00087     <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;xcomplex&lt;double&gt;</a> &gt; shiftarr, work;
00088     rfft plan;
00089     <span class="keywordtype">bool</span> norot;
00090 
00091     <span class="keywordtype">void</span> update(<span class="keywordtype">int</span> nph, <span class="keywordtype">int</span> mmax, <span class="keywordtype">double</span> phi0)
00092       {
00093       norot = (abs(phi0)&lt;1e-14);
00094       <span class="keywordflow">if</span> (!norot)
00095         {
00096         <span class="keywordflow">if</span> ((mmax!=shiftarr.size()-1) || (!<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__mathutilsgroup.html#a0">approx</a>(phi0,phi0_,1e-12)))
00097           {
00098           shiftarr.alloc(mmax+1);
00099           phi0_=phi0;
00100           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;=mmax; ++m)
00101             shiftarr[m].Set (cos(m*phi0),sin(m*phi0));
00102           }
00103         }
00104       <span class="keywordflow">if</span> (nph!=plan.size())
00105         plan.Set(nph);
00106       <span class="keywordflow">if</span> (nph&gt;work.size())
00107         work.alloc(2*nph);
00108       }
00109 
00110   <span class="keyword">public</span>:
00111     ringhelper() : phi0_(0), norot(true) {}
00112 
00113     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> phase2ring (<span class="keywordtype">int</span> nph, <span class="keywordtype">int</span> mmax, <span class="keywordtype">double</span> phi0,
00114       <span class="keyword">const</span> <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> *phase, T *ring)
00115       {
00116       update (nph, mmax, phi0);
00117 
00118       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=1; m&lt;nph; ++m) work[m]=0;
00119       work[0]=phase[0];
00120 
00121       <span class="keywordflow">if</span> (norot)
00122         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=1; m&lt;=mmax; ++m)
00123           {
00124           work[m%nph] += phase[m];
00125           work[nph-1-((m-1)%nph)] += <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__complexgroup.html#a0">conj</a>(phase[m]);
00126           }
00127       <span class="keywordflow">else</span>
00128         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=1; m&lt;=mmax; ++m)
00129           {
00130           <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> tmp = phase[m]*shiftarr[m];
00131           work[m%nph] += tmp;
00132           work[nph-1-((m-1)%nph)] += <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__complexgroup.html#a0">conj</a>(tmp);
00133           }
00134 
00135       plan.backward_c(work);
00136       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;nph; ++m) ring[m] = work[m].re;
00137       }
00138     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> phase2ring (<span class="keywordtype">int</span> mmax,
00139       <span class="keyword">const</span> <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> *phase, <span class="keyword">const</span> <a class="code" href="classringinfo.html">ringinfo</a> &amp;info, T *data)
00140       {
00141       <span class="keywordflow">if</span> (info.<a class="code" href="classringinfo.html#o5">nph</a>&gt;0)
00142         phase2ring (info.<a class="code" href="classringinfo.html#o5">nph</a>, mmax, info.<a class="code" href="classringinfo.html#o1">phi0</a>, phase, data+info.<a class="code" href="classringinfo.html#o6">ofs</a>);
00143       }
00144     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> phase2pair (<span class="keywordtype">int</span> mmax,
00145       <span class="keyword">const</span> <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> *phase1, <span class="keyword">const</span> <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> *phase2,
00146       <span class="keyword">const</span> <a class="code" href="classringpair.html">ringpair</a> &amp;pair, T *data)
00147       {
00148       phase2ring (mmax, phase1, pair.<a class="code" href="classringpair.html#o0">r1</a>, data);
00149       phase2ring (mmax, phase2, pair.<a class="code" href="classringpair.html#o1">r2</a>, data);
00150       }
00151 
00152     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> ring2phase (<span class="keywordtype">int</span> nph, <span class="keywordtype">int</span> mmax, <span class="keywordtype">double</span> phi0,
00153       <span class="keywordtype">double</span> weight, <span class="keyword">const</span> T *ring, <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> *phase)
00154       {
00155       update (nph, mmax, -phi0);
00156       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;nph; ++m) work[m] = ring[m]*weight;
00157       plan.forward_c(work);
00158 
00159       <span class="keywordflow">if</span> (norot)
00160         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;=mmax; ++m)
00161           phase[m] = work[m%nph];
00162       <span class="keywordflow">else</span>
00163         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;=mmax; ++m)
00164           phase[m] = work[m%nph]*shiftarr[m];
00165       }
00166     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> ring2phase (<span class="keywordtype">int</span> mmax, <span class="keyword">const</span> <a class="code" href="classringinfo.html">ringinfo</a> &amp;info,
00167       <span class="keyword">const</span> T *data, <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> *phase)
00168       {
00169       <span class="keywordflow">if</span> (info.<a class="code" href="classringinfo.html#o5">nph</a>&gt;0)
00170         ring2phase (info.<a class="code" href="classringinfo.html#o5">nph</a>, mmax, info.<a class="code" href="classringinfo.html#o1">phi0</a>, info.<a class="code" href="classringinfo.html#o2">weight</a>, data+info.<a class="code" href="classringinfo.html#o6">ofs</a>,
00171           phase);
00172       }
00173     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> pair2phase (<span class="keywordtype">int</span> mmax, <span class="keyword">const</span> <a class="code" href="classringpair.html">ringpair</a> &amp;pair,
00174       <span class="keyword">const</span> T *data, <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> *phase1, <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> *phase2)
00175       {
00176       ring2phase (mmax, pair.<a class="code" href="classringpair.html#o0">r1</a>, data, phase1);
00177       ring2phase (mmax, pair.<a class="code" href="classringpair.html#o1">r2</a>, data, phase2);
00178       }
00179   };
00180 
00181 } <span class="comment">// namespace</span>
00182 
00183 
00184 <span class="keywordtype">void</span> info2pair(<span class="keyword">const</span> vector&lt;ringinfo&gt; &amp;info, vector&lt;ringpair&gt; &amp;pair)
00185   {
00186   pair.clear();
00187   vector&lt;ringinfo&gt; info2=info;
00188   sort(info2.begin(),info2.end(),info_comparator());
00189   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos=0;
00190   <span class="keywordflow">while</span> (pos&lt;info2.size()-1)
00191     {
00192     <span class="keywordflow">if</span> (<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__mathutilsgroup.html#a0">approx</a>(info2[pos].cth,-info2[pos+1].cth,1e-12))
00193       {
00194       pair.push_back(<a class="code" href="classringpair.html">ringpair</a>(info2[pos],info2[pos+1]));
00195       pos+=2;
00196       }
00197     <span class="keywordflow">else</span>
00198       {
00199       pair.push_back(<a class="code" href="classringpair.html">ringpair</a>(info2[pos]));
00200       ++pos;
00201       }
00202     }
00203   <span class="keywordflow">if</span> (pos&lt;info2.size())
00204     pair.push_back(info2[pos]);
00205 
00206   sort(pair.begin(),pair.end(),pair_comparator());
00207   }
00208 
00209 
00210 <span class="preprocessor">#define MAP2ALM_MACRO(px) \</span>
00211 <span class="preprocessor">  { \</span>
00212 <span class="preprocessor">  alm_tmp[l].re += px.re*Ylm[l]; \</span>
00213 <span class="preprocessor">  alm_tmp[l].im += px.im*Ylm[l]; \</span>
00214 <span class="preprocessor">  ++l; \</span>
00215 <span class="preprocessor">  }</span>
00216 <span class="preprocessor"></span>
00217 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> <a class="code" href="group__alm__healpix__group.html#a0">map2alm</a> (<span class="keyword">const</span> vector&lt;ringpair&gt; &amp;pair,
00218   <span class="keyword">const</span> T *map, <a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;T&gt;</a> &gt; &amp;alm, <span class="keywordtype">bool</span> add_alm)
00219   {
00220   <span class="keywordtype">int</span> lmax = alm.Lmax(), mmax = alm.Mmax();
00221 
00222   <span class="keywordtype">int</span> nchunks, chunksize;
00223   get_chunk_info(pair.size(),nchunks,chunksize);
00224   <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr2.html">arr2&lt;xcomplex&lt;double&gt;</a> &gt; phas1(chunksize,mmax+1), phas2(chunksize,mmax+1);
00225 
00226   <span class="keywordflow">if</span> (!add_alm) alm.SetToZero();
00227 
00228   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> chunk=0; chunk&lt;nchunks; ++chunk)
00229     {
00230     <span class="keywordtype">int</span> llim=chunk*chunksize, ulim=min(llim+chunksize,<span class="keywordtype">int</span>(pair.size()));
00231 
00232 <span class="preprocessor">#pragma omp parallel</span>
00233 <span class="preprocessor"></span>{
00234     ringhelper helper;
00235 
00236     <span class="keywordtype">int</span> ith;
00237 <span class="preprocessor">#pragma omp for schedule(dynamic,1)</span>
00238 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (ith=llim; ith&lt;ulim; ++ith)
00239       helper.pair2phase(mmax,pair[ith],map,phas1[ith-llim],phas2[ith-llim]);
00240 } <span class="comment">// end of parallel region</span>
00241 
00242 <span class="preprocessor">#pragma omp parallel</span>
00243 <span class="preprocessor"></span>{
00244     <a class="code" href="classYlmgen.html">Ylmgen</a> generator(lmax,mmax,1e-30);
00245     <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> Ylm;
00246     <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;xcomplex&lt;double&gt;</a> &gt; alm_tmp(lmax+1);
00247     <span class="keywordtype">int</span> m;
00248 <span class="preprocessor">#pragma omp for schedule(dynamic,1)</span>
00249 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (m=0; m&lt;=mmax; ++m)
00250       {
00251       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> l=m; l&lt;=lmax; ++l) alm_tmp[l].Set(0.,0.);
00252       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ith=0; ith&lt;ulim-llim; ++ith)
00253         {
00254         <span class="keywordtype">int</span> l;
00255         generator.<a class="code" href="classYlmgen.html#a1">get_Ylm</a>(pair[ith+llim].r1.cth,pair[ith+llim].r1.sth,m,Ylm,l);
00256         <span class="keywordflow">if</span> (l&lt;=lmax)
00257           {
00258           <span class="keywordflow">if</span> (pair[ith+llim].r2.nph&gt;0)
00259             {
00260             <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> p1 = phas1[ith][m]+phas2[ith][m],
00261                              p2 = phas1[ith][m]-phas2[ith][m];
00262 
00263             <span class="keywordflow">if</span> ((l-m)&amp;1)
00264               MAP2ALM_MACRO(p2)
00265             <span class="keywordflow">for</span> (;l&lt;lmax;)
00266               {
00267               MAP2ALM_MACRO(p1)
00268               MAP2ALM_MACRO(p2)
00269               }
00270             <span class="keywordflow">if</span> (l==lmax)
00271               MAP2ALM_MACRO(p1)
00272             }
00273           <span class="keywordflow">else</span>
00274             {
00275             <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> p1 = phas1[ith][m];
00276             <span class="keywordflow">for</span> (;l&lt;=lmax;)
00277               MAP2ALM_MACRO(p1)
00278             }
00279           }
00280         }
00281       <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;T&gt;</a> *palm = alm.mstart(m);
00282       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> l=m; l&lt;=lmax; ++l)
00283         { palm[l].<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html#o0">re</a> += alm_tmp[l].re; palm[l].<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html#o1">im</a> += alm_tmp[l].im; }
00284       }
00285 } <span class="comment">// end of parallel region</span>
00286     }
00287   }
00288 
00289 <span class="keyword">template</span> <span class="keywordtype">void</span> <a class="code" href="group__alm__healpix__group.html#a0">map2alm</a> (<span class="keyword">const</span> vector&lt;ringpair&gt; &amp;pair,
00290   <span class="keyword">const</span> <span class="keywordtype">float</span> *map, <a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;float&gt;</a> &gt; &amp;alm, <span class="keywordtype">bool</span> add_alm);
00291 <span class="keyword">template</span> <span class="keywordtype">void</span> <a class="code" href="group__alm__healpix__group.html#a0">map2alm</a> (<span class="keyword">const</span> vector&lt;ringpair&gt; &amp;pair,
00292   <span class="keyword">const</span> <span class="keywordtype">double</span> *map, <a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> &gt; &amp;alm, <span class="keywordtype">bool</span> add_alm);
00293 
00294 <span class="preprocessor">#define SETUP_LAMBDA \</span>
00295 <span class="preprocessor">  const double t1  = lam_lm1m*lam_fact[l]; \</span>
00296 <span class="preprocessor">  const double a_w = (l-m2)*two_on_s2 + l*(l-1); \</span>
00297 <span class="preprocessor">  const double a_x = twocth*(l-1)*lam_lm; \</span>
00298 <span class="preprocessor">  const double lambda_w = a_w*lam_lm - t1*c_on_s2; \</span>
00299 <span class="preprocessor">  const double lambda_x = m_on_s2 * (a_x-t1);</span>
00300 <span class="preprocessor"></span>
00301 <span class="preprocessor">#define MAP2ALM_POL_MACRO(Tx,Qx,Qy,Ux,Uy) \</span>
00302 <span class="preprocessor">  { \</span>
00303 <span class="preprocessor">  double lam_lm1m=lam_lm; \</span>
00304 <span class="preprocessor">  lam_lm=Ylm[l]; \</span>
00305 <span class="preprocessor">  alm_tmp[l][0].re += Tx.re*lam_lm; alm_tmp[l][0].im += Tx.im*lam_lm; \</span>
00306 <span class="preprocessor">  SETUP_LAMBDA \</span>
00307 <span class="preprocessor">  alm_tmp[l][1].re += Qx.re*lambda_w - Uy.im*lambda_x; \</span>
00308 <span class="preprocessor">  alm_tmp[l][1].im += Qx.im*lambda_w + Uy.re*lambda_x; \</span>
00309 <span class="preprocessor">  alm_tmp[l][2].re += Ux.re*lambda_w + Qy.im*lambda_x; \</span>
00310 <span class="preprocessor">  alm_tmp[l][2].im += Ux.im*lambda_w - Qy.re*lambda_x; \</span>
00311 <span class="preprocessor">  ++l; \</span>
00312 <span class="preprocessor">  }</span>
00313 <span class="preprocessor"></span>
00314 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> <a class="code" href="group__alm__healpix__group.html#a4">map2alm_pol</a>
00315   (<span class="keyword">const</span> vector&lt;ringpair&gt; &amp;pair, <span class="keyword">const</span> T *mapT, <span class="keyword">const</span> T *mapQ, <span class="keyword">const</span> T *mapU,
00316    <a class="code" href="classAlm.html">Alm&lt;xcomplex&lt;T&gt;</a> &gt; &amp;almT, <a class="code" href="classAlm.html">Alm&lt;xcomplex&lt;T&gt;</a> &gt; &amp;almG, <a class="code" href="classAlm.html">Alm&lt;xcomplex&lt;T&gt;</a> &gt; &amp;almC,
00317    <span class="keywordtype">bool</span> add_alm)
00318   {
00319   <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__assertgroup.html#a1">planck_assert</a> (almT.conformable(almG) &amp;&amp; almT.conformable(almC),
00320     <span class="stringliteral">"map2alm_pol: a_lm are not conformable"</span>);
00321 
00322   <span class="keywordtype">int</span> lmax = almT.Lmax(), mmax = almT.Mmax();
00323 
00324   <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> normal_l (lmax+1);
00325   init_normal_l (normal_l);
00326 
00327   <span class="keywordtype">int</span> nchunks, chunksize;
00328   get_chunk_info(pair.size(),nchunks,chunksize);
00329 
00330   <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr2.html">arr2&lt;xcomplex&lt;double&gt;</a> &gt; phas1T(chunksize,mmax+1),phas2T(chunksize,mmax+1),
00331                           phas1Q(chunksize,mmax+1),phas2Q(chunksize,mmax+1),
00332                           phas1U(chunksize,mmax+1),phas2U(chunksize,mmax+1);
00333 
00334   <span class="keywordflow">if</span> (!add_alm)
00335     { almT.SetToZero(); almG.SetToZero(); almC.SetToZero(); }
00336 
00337   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> chunk=0; chunk&lt;nchunks; ++chunk)
00338     {
00339     <span class="keywordtype">int</span> llim=chunk*chunksize, ulim=min(llim+chunksize,<span class="keywordtype">int</span>(pair.size()));
00340 
00341 <span class="preprocessor">#pragma omp parallel</span>
00342 <span class="preprocessor"></span>{
00343     ringhelper helper;
00344 
00345     <span class="keywordtype">int</span> ith;
00346 <span class="preprocessor">#pragma omp for schedule(dynamic,1)</span>
00347 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (ith=llim; ith&lt;ulim; ++ith)
00348       {
00349       helper.pair2phase (mmax, pair[ith], mapT,
00350         phas1T[ith-llim], phas2T[ith-llim]);
00351       helper.pair2phase (mmax, pair[ith], mapQ,
00352         phas1Q[ith-llim], phas2Q[ith-llim]);
00353       helper.pair2phase (mmax, pair[ith], mapU,
00354         phas1U[ith-llim], phas2U[ith-llim]);
00355       }
00356 } <span class="comment">// end of parallel region</span>
00357 
00358 <span class="preprocessor">#pragma omp parallel</span>
00359 <span class="preprocessor"></span>{
00360     <a class="code" href="classYlmgen.html">Ylmgen</a> generator(lmax,mmax,1e-30);
00361     <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> Ylm;
00362     <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> lam_fact(lmax+1);
00363     <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;xcomplex&lt;double&gt;</a>[3] &gt; alm_tmp(lmax+1);
00364     <span class="keywordtype">int</span> m;
00365 <span class="preprocessor">#pragma omp for schedule(dynamic,1)</span>
00366 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (m=0; m&lt;=mmax; ++m)
00367       {
00368       init_lam_fact_1d (m,lam_fact);
00369 
00370       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> l=m; l&lt;alm_tmp.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html#a6">size</a>(); ++l)
00371         alm_tmp[l][0]=alm_tmp[l][1]=alm_tmp[l][2] = 0;
00372 
00373       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ith=0; ith&lt;ulim-llim; ++ith)
00374         {
00375         <span class="keywordtype">int</span> l;
00376         <span class="keywordtype">double</span> cth=pair[ith+llim].r1.cth, sth=pair[ith+llim].r1.sth;
00377         generator.<a class="code" href="classYlmgen.html#a1">get_Ylm</a>(cth,sth,m,Ylm,l);
00378         <span class="keywordflow">if</span> (l&lt;=lmax)
00379           {
00380           <span class="keywordtype">double</span> one_on_s2 = 1/(sth*sth);
00381           <span class="keywordtype">double</span> c_on_s2 = cth * one_on_s2;
00382           <span class="keywordtype">double</span> two_on_s2 = 2*one_on_s2;
00383           <span class="keywordtype">double</span> twocth = 2*cth;
00384           <span class="keywordtype">int</span> m2 = m*m;
00385           <span class="keywordtype">double</span> m_on_s2 = m*one_on_s2;
00386 
00387           <span class="keywordflow">if</span> (pair[ith+llim].r2.nph&gt;0)
00388             {
00389             <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> T1 = phas1T[ith][m]+phas2T[ith][m],
00390                              T2 = phas1T[ith][m]-phas2T[ith][m],
00391                              Q1 = phas1Q[ith][m]+phas2Q[ith][m],
00392                              Q2 = phas1Q[ith][m]-phas2Q[ith][m],
00393                              U1 = phas1U[ith][m]+phas2U[ith][m],
00394                              U2 = phas1U[ith][m]-phas2U[ith][m];
00395 
00396             <span class="keywordtype">double</span> lam_lm = 0;
00397             <span class="keywordflow">if</span> ((l-m)&amp;1)
00398               MAP2ALM_POL_MACRO(T2,Q2,Q1,U2,U1)
00399             <span class="keywordflow">for</span> (;l&lt;lmax;)
00400               {
00401               MAP2ALM_POL_MACRO(T1,Q1,Q2,U1,U2)
00402               MAP2ALM_POL_MACRO(T2,Q2,Q1,U2,U1)
00403               }
00404             <span class="keywordflow">if</span> (l==lmax)
00405               MAP2ALM_POL_MACRO(T1,Q1,Q2,U1,U2)
00406             }
00407           <span class="keywordflow">else</span>
00408             {
00409             <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> T1 = phas1T[ith][m],
00410                              Q1 = phas1Q[ith][m],
00411                              U1 = phas1U[ith][m];
00412             <span class="keywordtype">double</span> lam_lm = 0;
00413             <span class="keywordflow">for</span> (;l&lt;=lmax;)
00414               MAP2ALM_POL_MACRO(T1,Q1,Q1,U1,U1)
00415             }
00416           }
00417         }
00418       <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;T&gt;</a> *palmT=almT.mstart(m), *palmG=almG.mstart(m),
00419                   *palmC=almC.mstart(m);
00420       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> l=m;l&lt;=lmax;++l)
00421         {
00422         palmT[l].<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html#o0">re</a> += alm_tmp[l][0].re;
00423         palmT[l].<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html#o1">im</a> += alm_tmp[l][0].im;
00424         palmG[l].re += alm_tmp[l][1].re*normal_l[l];
00425         palmG[l].im += alm_tmp[l][1].im*normal_l[l];
00426         palmC[l].re += alm_tmp[l][2].re*normal_l[l];
00427         palmC[l].im += alm_tmp[l][2].im*normal_l[l];
00428         }
00429       }
00430 } <span class="comment">// end of parallel region</span>
00431     }
00432   }
00433 
00434 <span class="keyword">template</span> <span class="keywordtype">void</span> <a class="code" href="group__alm__healpix__group.html#a4">map2alm_pol</a> (<span class="keyword">const</span> vector&lt;ringpair&gt; &amp;pair, <span class="keyword">const</span> <span class="keywordtype">float</span> *mapT,
00435    <span class="keyword">const</span> <span class="keywordtype">float</span> *mapQ, <span class="keyword">const</span> <span class="keywordtype">float</span> *mapU, <a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;float&gt;</a> &gt; &amp;almT,
00436    <a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;float&gt;</a> &gt; &amp;almG, <a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;float&gt;</a> &gt; &amp;almC, <span class="keywordtype">bool</span> add_alm);
00437 <span class="keyword">template</span> <span class="keywordtype">void</span> <a class="code" href="group__alm__healpix__group.html#a4">map2alm_pol</a> (<span class="keyword">const</span> vector&lt;ringpair&gt; &amp;pair, <span class="keyword">const</span> <span class="keywordtype">double</span> *mapT,
00438    <span class="keyword">const</span> <span class="keywordtype">double</span> *mapQ, <span class="keyword">const</span> <span class="keywordtype">double</span> *mapU, <a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> &gt; &amp;almT,
00439    <a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> &gt; &amp;almG, <a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> &gt; &amp;almC, <span class="keywordtype">bool</span> add_alm);
00440 
00441 
00442 <span class="preprocessor">#define ALM2MAP_MACRO(px) \</span>
00443 <span class="preprocessor">  { \</span>
00444 <span class="preprocessor">  px.re += alm_tmp[l].re*Ylm[l]; \</span>
00445 <span class="preprocessor">  px.im += alm_tmp[l].im*Ylm[l]; \</span>
00446 <span class="preprocessor">  ++l; \</span>
00447 <span class="preprocessor">  }</span>
00448 <span class="preprocessor"></span>
00449 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> <a class="code" href="group__alm__healpix__group.html#a8">alm2map</a> (<span class="keyword">const</span> <a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;T&gt;</a> &gt; &amp;alm,
00450   <span class="keyword">const</span> vector&lt;ringpair&gt; &amp;pair, T *map)
00451   {
00452   <span class="keywordtype">int</span> lmax = alm.Lmax(), mmax = alm.Mmax();
00453 
00454   <span class="keywordtype">int</span> nchunks, chunksize;
00455   get_chunk_info(pair.size(),nchunks,chunksize);
00456 
00457   <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr2.html">arr2&lt;xcomplex&lt;double&gt;</a> &gt; phas1(chunksize,mmax+1), phas2(chunksize,mmax+1);
00458 
00459   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> chunk=0; chunk&lt;nchunks; ++chunk)
00460     {
00461     <span class="keywordtype">int</span> llim=chunk*chunksize, ulim=min(llim+chunksize,<span class="keywordtype">int</span>(pair.size()));
00462 
00463 <span class="preprocessor">#pragma omp parallel</span>
00464 <span class="preprocessor"></span>{
00465     <a class="code" href="classYlmgen.html">Ylmgen</a> generator(lmax,mmax,1e-30);
00466     <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> Ylm;
00467     <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;xcomplex&lt;double&gt;</a> &gt; alm_tmp(lmax+1);
00468     <span class="keywordtype">int</span> m;
00469 <span class="preprocessor">#pragma omp for schedule(dynamic,1)</span>
00470 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (m=0; m&lt;=mmax; ++m)
00471       {
00472       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> l=m; l&lt;=lmax; ++l)
00473         alm_tmp[l]=alm(l,m);
00474 
00475       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ith=0; ith&lt;ulim-llim; ++ith)
00476         {
00477         <span class="keywordtype">int</span> l;
00478         generator.<a class="code" href="classYlmgen.html#a1">get_Ylm</a>(pair[ith+llim].r1.cth,pair[ith+llim].r1.sth,m,Ylm,l);
00479         <span class="keywordflow">if</span> (l&gt;lmax)
00480           phas1[ith][m] = phas2[ith][m] = 0;
00481         <span class="keywordflow">else</span>
00482           {
00483           <span class="keywordflow">if</span> (pair[ith+llim].r2.nph&gt;0)
00484             {
00485             <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> p1=0, p2=0;
00486 
00487             <span class="keywordflow">if</span> ((l-m)&amp;1)
00488               ALM2MAP_MACRO(p2)
00489             <span class="keywordflow">for</span> (;l&lt;lmax;)
00490               {
00491               ALM2MAP_MACRO(p1)
00492               ALM2MAP_MACRO(p2)
00493               }
00494             <span class="keywordflow">if</span> (l==lmax)
00495               ALM2MAP_MACRO(p1)
00496             phas1[ith][m] = p1+p2; phas2[ith][m] = p1-p2;
00497             }
00498           <span class="keywordflow">else</span>
00499             {
00500             <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> p1=0;
00501             <span class="keywordflow">for</span> (;l&lt;=lmax;)
00502               ALM2MAP_MACRO(p1)
00503             phas1[ith][m] = p1;
00504             }
00505           }
00506         }
00507       }
00508 } <span class="comment">// end of parallel region</span>
00509 
00510 <span class="preprocessor">#pragma omp parallel</span>
00511 <span class="preprocessor"></span>{
00512     ringhelper helper;
00513     <span class="keywordtype">int</span> ith;
00514 <span class="preprocessor">#pragma omp for schedule(dynamic,1)</span>
00515 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (ith=llim; ith&lt;ulim; ++ith)
00516       helper.phase2pair (mmax,phas1[ith-llim],phas2[ith-llim],pair[ith],map);
00517 } <span class="comment">// end of parallel region</span>
00518     }
00519   }
00520 
00521 <span class="keyword">template</span> <span class="keywordtype">void</span> <a class="code" href="group__alm__healpix__group.html#a8">alm2map</a> (<span class="keyword">const</span> <a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;float&gt;</a> &gt; &amp;alm,
00522   <span class="keyword">const</span> vector&lt;ringpair&gt; &amp;pair, <span class="keywordtype">float</span> *map);
00523 <span class="keyword">template</span> <span class="keywordtype">void</span> <a class="code" href="group__alm__healpix__group.html#a8">alm2map</a> (<span class="keyword">const</span> <a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> &gt; &amp;alm,
00524   <span class="keyword">const</span> vector&lt;ringpair&gt; &amp;pair, <span class="keywordtype">double</span> *map);
00525 
00526 <span class="preprocessor">#define ALM2MAP_POL_MACRO(Tx,Qx,Qy,Ux,Uy) \</span>
00527 <span class="preprocessor">  { \</span>
00528 <span class="preprocessor">  double lam_lm1m = lam_lm; \</span>
00529 <span class="preprocessor">  lam_lm = Ylm[l]; \</span>
00530 <span class="preprocessor">  Tx.re+=alm_tmp[l][0].re*lam_lm;   Tx.im+=alm_tmp[l][0].im*lam_lm; \</span>
00531 <span class="preprocessor">  SETUP_LAMBDA \</span>
00532 <span class="preprocessor">  Qx.re+=alm_tmp[l][1].re*lambda_w; Qx.im+=alm_tmp[l][1].im*lambda_w; \</span>
00533 <span class="preprocessor">  Ux.re-=alm_tmp[l][2].re*lambda_w; Ux.im-=alm_tmp[l][2].im*lambda_w; \</span>
00534 <span class="preprocessor">  Qy.re-=alm_tmp[l][2].im*lambda_x; Qy.im+=alm_tmp[l][2].re*lambda_x; \</span>
00535 <span class="preprocessor">  Uy.re-=alm_tmp[l][1].im*lambda_x; Uy.im+=alm_tmp[l][1].re*lambda_x; \</span>
00536 <span class="preprocessor">  ++l; \</span>
00537 <span class="preprocessor">  }</span>
00538 <span class="preprocessor"></span>
00539 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> <a class="code" href="group__alm__healpix__group.html#a9">alm2map_pol</a> (<span class="keyword">const</span> <a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;T&gt;</a> &gt; &amp;almT,
00540    <span class="keyword">const</span> <a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;T&gt;</a> &gt; &amp;almG, <span class="keyword">const</span> <a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;T&gt;</a> &gt; &amp;almC,
00541    <span class="keyword">const</span> vector&lt;ringpair&gt; &amp;pair, T *mapT, T *mapQ, T *mapU)
00542   {
00543   <span class="keywordtype">int</span> lmax = almT.Lmax(), mmax = almT.Mmax();
00544 
00545   <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__assertgroup.html#a1">planck_assert</a> (almT.conformable(almG) &amp;&amp; almT.conformable(almC),
00546     <span class="stringliteral">"alm2map_pol: a_lm are not conformable"</span>);
00547 
00548   <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> normal_l (lmax+1);
00549   init_normal_l (normal_l);
00550 
00551   <span class="keywordtype">int</span> nchunks, chunksize;
00552   get_chunk_info(pair.size(),nchunks,chunksize);
00553 
00554   <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr2.html">arr2&lt;xcomplex&lt;double&gt;</a> &gt;
00555     phas1T(chunksize,mmax+1), phas2T(chunksize,mmax+1),
00556     phas1Q(chunksize,mmax+1), phas2Q(chunksize,mmax+1),
00557     phas1U(chunksize,mmax+1), phas2U(chunksize,mmax+1);
00558 
00559   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> chunk=0; chunk&lt;nchunks; ++chunk)
00560     {
00561     <span class="keywordtype">int</span> llim=chunk*chunksize, ulim=min(llim+chunksize,<span class="keywordtype">int</span>(pair.size()));
00562 
00563 <span class="preprocessor">#pragma omp parallel</span>
00564 <span class="preprocessor"></span>{
00565     <a class="code" href="classYlmgen.html">Ylmgen</a> generator(lmax,mmax,1e-30);
00566     <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> Ylm;
00567     <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> lam_fact (lmax+1);
00568     <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;xcomplex&lt;double&gt;</a>[3]&gt; alm_tmp(lmax+1);
00569     <span class="keywordtype">int</span> m;
00570 <span class="preprocessor">#pragma omp for schedule(dynamic,1)</span>
00571 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (m=0; m&lt;=mmax; ++m)
00572       {
00573       <span class="keywordtype">int</span> m2 = m*m;
00574       init_lam_fact_1d (m,lam_fact);
00575       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> l=m; l&lt;=lmax; ++l)
00576         {
00577         alm_tmp[l][0] = almT(l,m);
00578         alm_tmp[l][1] = almG(l,m)*(-normal_l[l]);
00579         alm_tmp[l][2] = almC(l,m)*(-normal_l[l]);
00580         }
00581       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ith=0; ith&lt;ulim-llim; ++ith)
00582         {
00583         <span class="keywordtype">double</span> cth=pair[ith+llim].r1.cth, sth=pair[ith+llim].r1.sth;
00584         <span class="keywordtype">int</span> l;
00585         generator.<a class="code" href="classYlmgen.html#a1">get_Ylm</a>(cth,sth,m,Ylm,l);
00586         <span class="keywordflow">if</span> (l&lt;=lmax)
00587           {
00588           <span class="keywordtype">double</span> one_on_s2 = 1/(sth*sth);
00589           <span class="keywordtype">double</span> c_on_s2 = cth * one_on_s2;
00590           <span class="keywordtype">double</span> two_on_s2 = 2*one_on_s2;
00591           <span class="keywordtype">double</span> m_on_s2 = m*one_on_s2;
00592           <span class="keywordtype">double</span> twocth = 2*cth;
00593 
00594           <span class="keywordflow">if</span> (pair[ith+llim].r2.nph&gt;0)
00595             {
00596             <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> T1=0, T2=0, Q1=0, Q2=0, U1=0, U2=0;
00597             <span class="keywordtype">double</span> lam_lm = 0;
00598             <span class="keywordflow">if</span> ((l-m)&amp;1)
00599               ALM2MAP_POL_MACRO(T2,Q2,Q1,U2,U1)
00600             <span class="keywordflow">for</span> (;l&lt;lmax;)
00601               {
00602               ALM2MAP_POL_MACRO(T1,Q1,Q2,U1,U2)
00603               ALM2MAP_POL_MACRO(T2,Q2,Q1,U2,U1)
00604               }
00605             <span class="keywordflow">if</span> (l==lmax)
00606               ALM2MAP_POL_MACRO(T1,Q1,Q2,U1,U2)
00607 
00608             phas1T[ith][m] = T1+T2; phas2T[ith][m] = T1-T2;
00609             phas1Q[ith][m] =-Q1-Q2; phas2Q[ith][m] =-Q1+Q2;
00610             phas1U[ith][m] = U1+U2; phas2U[ith][m] = U1-U2;
00611             }
00612           <span class="keywordflow">else</span>
00613             {
00614             <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> T1=0, Q1=0, U1=0;
00615             <span class="keywordtype">double</span> lam_lm = 0;
00616             <span class="keywordflow">for</span> (;l&lt;=lmax;)
00617               { ALM2MAP_POL_MACRO(T1,Q1,Q1,U1,U1) }
00618             phas1T[ith][m] = T1;
00619             phas1Q[ith][m] =-Q1;
00620             phas1U[ith][m] = U1;
00621             }
00622           }
00623         <span class="keywordflow">else</span>
00624           {
00625           phas1T[ith][m] = phas2T[ith][m] = 0;
00626           phas1Q[ith][m] = phas2Q[ith][m] = 0;
00627           phas1U[ith][m] = phas2U[ith][m] = 0;
00628           }
00629         }
00630       }
00631 } <span class="comment">// end of parallel region</span>
00632 
00633 <span class="preprocessor">#pragma omp parallel</span>
00634 <span class="preprocessor"></span>{
00635     ringhelper helper;
00636     <span class="keywordtype">int</span> ith;
00637 <span class="preprocessor">#pragma omp for schedule(dynamic,1)</span>
00638 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (ith=llim; ith&lt;ulim; ++ith)
00639       {
00640       helper.phase2pair(mmax,phas1T[ith-llim],phas2T[ith-llim],pair[ith],mapT);
00641       helper.phase2pair(mmax,phas1Q[ith-llim],phas2Q[ith-llim],pair[ith],mapQ);
00642       helper.phase2pair(mmax,phas1U[ith-llim],phas2U[ith-llim],pair[ith],mapU);
00643       }
00644 } <span class="comment">// end of parallel region</span>
00645     }
00646   }
00647 
00648 <span class="keyword">template</span> <span class="keywordtype">void</span> <a class="code" href="group__alm__healpix__group.html#a9">alm2map_pol</a> (<span class="keyword">const</span> <a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;float&gt;</a> &gt; &amp;almT,
00649    <span class="keyword">const</span> <a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;float&gt;</a> &gt; &amp;almG, <span class="keyword">const</span> <a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;float&gt;</a> &gt; &amp;almC,
00650    <span class="keyword">const</span> vector&lt;ringpair&gt; &amp;pair, <span class="keywordtype">float</span> *mapT, <span class="keywordtype">float</span> *mapQ, <span class="keywordtype">float</span> *mapU);
00651 <span class="keyword">template</span> <span class="keywordtype">void</span> <a class="code" href="group__alm__healpix__group.html#a9">alm2map_pol</a> (<span class="keyword">const</span> <a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> &gt; &amp;almT,
00652    <span class="keyword">const</span> <a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> &gt; &amp;almG, <span class="keyword">const</span> <a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> &gt; &amp;almC,
00653    <span class="keyword">const</span> vector&lt;ringpair&gt; &amp;pair, <span class="keywordtype">double</span> *mapT, <span class="keywordtype">double</span> *mapQ, <span class="keywordtype">double</span> *mapU);
00654 
00655 <span class="preprocessor">#define ALM2MAP_DER1_MACRO(px,pdthx,pdphx) \</span>
00656 <span class="preprocessor">  { \</span>
00657 <span class="preprocessor">  double lam_lm1m = lam_lm; \</span>
00658 <span class="preprocessor">  lam_lm = Ylm[l]; \</span>
00659 <span class="preprocessor">  const double t1 = alm_tmp[l].re*lam_lm; \</span>
00660 <span class="preprocessor">  const double t2 = alm_tmp[l].im*lam_lm; \</span>
00661 <span class="preprocessor">  const double t3 = l*cotanth; \</span>
00662 <span class="preprocessor">  const double t4 = one_on_s*lam_lm1m*lam_fact[l]; \</span>
00663 <span class="preprocessor">  px.re+=t1; px.im+=t2; \</span>
00664 <span class="preprocessor">  pdthx.re+=t3*t1-t4*alm_tmp[l].re; pdthx.im+=t3*t2-t4*alm_tmp[l].im; \</span>
00665 <span class="preprocessor">  pdphx.re-=m*t2; pdphx.im+=m*t1; \</span>
00666 <span class="preprocessor">  ++l; \</span>
00667 <span class="preprocessor">  }</span>
00668 <span class="preprocessor"></span>
00669 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> <a class="code" href="group__alm__healpix__group.html#a10">alm2map_der1</a> (<span class="keyword">const</span> <a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;T&gt;</a> &gt; &amp;alm,
00670    <span class="keyword">const</span> vector&lt;ringpair&gt; &amp;pair, T *map, T *dth, T *dph)
00671   {
00672   <span class="keywordtype">int</span> lmax = alm.Lmax(), mmax = alm.Mmax();
00673 
00674   <span class="keywordtype">int</span> nchunks, chunksize;
00675   get_chunk_info(pair.size(),nchunks,chunksize);
00676 
00677   <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr2.html">arr2&lt;xcomplex&lt;double&gt;</a> &gt;
00678     phas1(chunksize,mmax+1), phas2(chunksize,mmax+1),
00679     phas1dth(chunksize,mmax+1), phas2dth(chunksize,mmax+1),
00680     phas1dph(chunksize,mmax+1), phas2dph(chunksize,mmax+1);
00681 
00682   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> chunk=0; chunk&lt;nchunks; ++chunk)
00683     {
00684     <span class="keywordtype">int</span> llim=chunk*chunksize, ulim=min(llim+chunksize,<span class="keywordtype">int</span>(pair.size()));
00685 
00686 <span class="preprocessor">#pragma omp parallel</span>
00687 <span class="preprocessor"></span>{
00688     <a class="code" href="classYlmgen.html">Ylmgen</a> generator(lmax,mmax,1e-30);
00689     <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> Ylm;
00690     <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> lam_fact (lmax+1);
00691     <span class="keywordtype">int</span> m;
00692 <span class="preprocessor">#pragma omp for schedule(dynamic,1)</span>
00693 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (m=0; m&lt;=mmax; ++m)
00694       {
00695       <span class="keyword">const</span> <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;T&gt;</a> *alm_tmp=alm.mstart(m);
00696       init_lam_fact_deriv_1d (m,lam_fact);
00697       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ith=0; ith&lt;ulim-llim; ++ith)
00698         {
00699         <span class="keywordtype">double</span> cth=pair[ith+llim].r1.cth, sth=pair[ith+llim].r1.sth;
00700         <span class="keywordtype">int</span> l;
00701         generator.<a class="code" href="classYlmgen.html#a1">get_Ylm</a>(cth,sth,m,Ylm,l);
00702         <span class="keywordflow">if</span> (l&lt;=lmax)
00703           {
00704           <span class="keywordtype">double</span> one_on_s = 1/sth;
00705           <span class="keywordtype">double</span> cotanth = cth*one_on_s;
00706 
00707           <span class="keywordflow">if</span> (pair[ith+llim].r2.nph&gt;0)
00708             {
00709             <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> p1=0, p2=0, pth1=0, pth2=0, pph1=0, pph2=0;
00710 
00711             <span class="keywordtype">double</span> lam_lm = 0;
00712             <span class="keywordflow">if</span> ((l-m)&amp;1)
00713               ALM2MAP_DER1_MACRO(p2,pth2,pph2)
00714             <span class="keywordflow">for</span>(;l&lt;lmax;)
00715               {
00716               ALM2MAP_DER1_MACRO(p1,pth1,pph1)
00717               ALM2MAP_DER1_MACRO(p2,pth2,pph2)
00718               }
00719             <span class="keywordflow">if</span> (l==lmax)
00720               ALM2MAP_DER1_MACRO(p1,pth1,pph1)
00721 
00722             phas1[ith][m] = p1+p2; phas2[ith][m] = p1-p2;
00723             phas1dth[ith][m] = pth1+pth2; phas2dth[ith][m] = pth2-pth1;
00724             phas1dph[ith][m] = (pph1+pph2)*one_on_s;
00725             phas2dph[ith][m] = (pph1-pph2)*one_on_s;
00726             }
00727           <span class="keywordflow">else</span>
00728             {
00729             <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> p1=0, pth1=0, pph1=0;
00730 
00731             <span class="keywordtype">double</span> lam_lm = 0;
00732             <span class="keywordflow">for</span>(;l&lt;=lmax;)
00733               ALM2MAP_DER1_MACRO(p1,pth1,pph1)
00734 
00735             phas1[ith][m] = p1;
00736             phas1dth[ith][m] = pth1;
00737             phas1dph[ith][m] = pph1*one_on_s;
00738             }
00739           }
00740         <span class="keywordflow">else</span>
00741           {
00742           phas1[ith][m] = phas2[ith][m] = 0;
00743           phas1dth[ith][m] = phas2dth[ith][m] = 0;
00744           phas1dph[ith][m] = phas2dph[ith][m] = 0;
00745           }
00746         }
00747       }
00748 } <span class="comment">// end of parallel region</span>
00749 
00750 <span class="preprocessor">#pragma omp parallel</span>
00751 <span class="preprocessor"></span>{
00752     ringhelper helper;
00753     <span class="keywordtype">int</span> ith;
00754 <span class="preprocessor">#pragma omp for schedule(dynamic,1)</span>
00755 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (ith=llim; ith&lt;ulim; ++ith)
00756       {
00757       helper.phase2pair(mmax,phas1[ith-llim],phas2[ith-llim],pair[ith],map);
00758       helper.phase2pair(mmax,phas1dth[ith-llim],phas2dth[ith-llim],
00759         pair[ith],dth);
00760       helper.phase2pair(mmax,phas1dph[ith-llim],phas2dph[ith-llim],
00761         pair[ith],dph);
00762       }
00763 } <span class="comment">// end of parallel region</span>
00764     }
00765   }
00766 
00767 <span class="keyword">template</span> <span class="keywordtype">void</span> <a class="code" href="group__alm__healpix__group.html#a10">alm2map_der1</a> (<span class="keyword">const</span> <a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;float&gt;</a> &gt; &amp;alm,
00768    <span class="keyword">const</span> vector&lt;ringpair&gt; &amp;pair, <span class="keywordtype">float</span> *map, <span class="keywordtype">float</span> *dth, <span class="keywordtype">float</span> *dph);
00769 <span class="keyword">template</span> <span class="keywordtype">void</span> <a class="code" href="group__alm__healpix__group.html#a10">alm2map_der1</a> (<span class="keyword">const</span> <a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> &gt; &amp;alm,
00770    <span class="keyword">const</span> vector&lt;ringpair&gt; &amp;pair, <span class="keywordtype">double</span> *map, <span class="keywordtype">double</span> *dth, <span class="keywordtype">double</span> *dph);
</pre></div><hr><address style="align: right;"><small>
Generated on Thu Nov 13 18:48:51 2008 for Healpix C++
</a> </small></address>
</body>
</html>
