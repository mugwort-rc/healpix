<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Healpix C++: alm_map_tools.cc Source File</title>
<link href="sheet.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">Healpix_cxx</a></div>
<h1>alm_map_tools.cc</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> *  This file is part of Healpix_cxx.</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> *  Healpix_cxx is free software; you can redistribute it and/or modify</span>
00005 <span class="comment"> *  it under the terms of the GNU General Public License as published by</span>
00006 <span class="comment"> *  the Free Software Foundation; either version 2 of the License, or</span>
00007 <span class="comment"> *  (at your option) any later version.</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> *  Healpix_cxx is distributed in the hope that it will be useful,</span>
00010 <span class="comment"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00012 <span class="comment"> *  GNU General Public License for more details.</span>
00013 <span class="comment"> *</span>
00014 <span class="comment"> *  You should have received a copy of the GNU General Public License</span>
00015 <span class="comment"> *  along with Healpix_cxx; if not, write to the Free Software</span>
00016 <span class="comment"> *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
00017 <span class="comment"> *</span>
00018 <span class="comment"> *  For more information about HEALPix, see http://healpix.jpl.nasa.gov</span>
00019 <span class="comment"> */</span>
00020 
00021 <span class="comment">/*</span>
00022 <span class="comment"> *  Healpix_cxx is being developed at the Max-Planck-Institut fuer Astrophysik</span>
00023 <span class="comment"> *  and financially supported by the Deutsches Zentrum fuer Luft- und Raumfahrt</span>
00024 <span class="comment"> *  (DLR).</span>
00025 <span class="comment"> */</span>
00026 
00027 <span class="comment">/*</span>
00028 <span class="comment"> *  Copyright (C) 2003, 2004, 2005 Max-Planck-Society</span>
00029 <span class="comment"> *  Author: Martin Reinecke</span>
00030 <span class="comment"> */</span>
00031 
00032 <span class="preprocessor">#include "<a class="code" href="alm__map__tools_8h.html">alm_map_tools.h</a>"</span>
00033 <span class="preprocessor">#include "<a class="code" href="alm_8h.html">alm.h</a>"</span>
00034 <span class="preprocessor">#include "<a class="code" href="healpix__map_8h.html">healpix_map.h</a>"</span>
00035 <span class="preprocessor">#include "fftpack_support.h"</span>
00036 <span class="preprocessor">#include "ylmgen.h"</span>
00037 <span class="preprocessor">#include "<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/xcomplex_8h.html">xcomplex.h</a>"</span>
00038 
00039 <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00040 
00041 <span class="keyword">namespace </span>{
00042 
00043 <span class="keywordtype">void</span> init_lam_fact_1d (<span class="keywordtype">int</span> m, <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> &amp;lam_fact)
00044   {
00045   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> l=m; l&lt;lam_fact.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html#a5">size</a>(); ++l)
00046     lam_fact[l] = (l&lt;2) ? 0. : 2*sqrt((2*l+1.)/(2*l-1.) * (l*l-m*m));
00047   }
00048 
00049 <span class="keywordtype">void</span> init_lam_fact_deriv_1d (<span class="keywordtype">int</span> m, <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> &amp;lam_fact)
00050   {
00051   lam_fact[m]=0;
00052   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> l=m+1; l&lt;lam_fact.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html#a5">size</a>(); ++l)
00053     lam_fact[l] = sqrt((2*l+1.)/(2*l-1.) * (l*l-m*m));
00054   }
00055 
00056 <span class="keywordtype">void</span> init_normal_l (<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> &amp;normal_l)
00057   {
00058   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> l=0; l&lt;normal_l.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html#a5">size</a>(); ++l)
00059     normal_l[l] = (l&lt;2) ? 0. : sqrt(1./((l+2.)*(l+1.)*l*(l-1.)));
00060   }
00061 
00062 <span class="keywordtype">void</span> get_chunk_info (<span class="keywordtype">int</span> nrings, <span class="keywordtype">int</span> &amp;nchunks, <span class="keywordtype">int</span> &amp;chunksize)
00063   {
00064   nchunks = nrings/max(100,nrings/10) + 1;
00065   chunksize = (nrings+nchunks-1)/nchunks;
00066   }
00067 
00068 <span class="keywordtype">void</span> fill_work (<span class="keyword">const</span> <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> *datain, <span class="keywordtype">int</span> nph, <span class="keywordtype">int</span> mmax,
00069   <span class="keywordtype">bool</span> shifted, <span class="keyword">const</span> <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> &gt; &amp;shiftarr,
00070   <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> &gt; &amp;work)
00071   {
00072   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=1; m&lt;nph; ++m) work[m]=0;
00073   work[0]=datain[0];
00074 
00075   <span class="keywordtype">int</span> cnt1=0, cnt2=nph;
00076   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=1; m&lt;=mmax; ++m)
00077     {
00078     <span class="keywordflow">if</span> (++cnt1==nph) cnt1=0;
00079     <span class="keywordflow">if</span> (--cnt2==-1) cnt2=nph-1;
00080     <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> tmp = shifted ? (datain[m]*shiftarr[m]) : datain[m];
00081     work[cnt1] += tmp;
00082     work[cnt2] += <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__complexgroup.html#gga0">conj</a>(tmp);
00083     }
00084   }
00085 
00086 <span class="keywordtype">void</span> read_work (<span class="keyword">const</span> <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> &gt;&amp; work, <span class="keywordtype">int</span> nph, <span class="keywordtype">int</span> mmax,
00087   <span class="keywordtype">bool</span> shifted, <span class="keyword">const</span> <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> &gt; &amp;shiftarr,
00088   <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> *dataout)
00089   {
00090   <span class="keywordtype">int</span> cnt2=0;
00091   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;=mmax; ++m)
00092     {
00093     dataout[m] = work[cnt2];
00094     <span class="keywordflow">if</span> (++cnt2==nph) cnt2=0;
00095     }
00096   <span class="keywordflow">if</span> (shifted)
00097     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;=mmax; ++m) dataout[m] *= shiftarr[m];
00098   }
00099 
00100 <span class="keywordtype">void</span> recalc_map2alm (<span class="keywordtype">int</span> nph, <span class="keywordtype">int</span> mmax, rfft &amp;plan,
00101   <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> &gt; &amp;shiftarr)
00102   {
00103   <span class="keywordflow">if</span> (plan.size() == nph) <span class="keywordflow">return</span>;
00104   plan.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html#a8">Set</a> (nph);
00105   <span class="keywordtype">double</span> f1 = pi/nph;
00106   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;=mmax; ++m)
00107     {
00108     <span class="keywordflow">if</span> (m&lt;nph)
00109       shiftarr[m].<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html#a8">Set</a> (cos(m*f1),-sin(m*f1));
00110     <span class="keywordflow">else</span>
00111       shiftarr[m]=-shiftarr[m-nph];
00112     }
00113   }
00114 
00115 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> fft_map2alm (<span class="keywordtype">int</span> nph, <span class="keywordtype">int</span> mmax, <span class="keywordtype">bool</span> shifted,
00116   <span class="keywordtype">double</span> weight, rfft &amp;plan, T *mapN, T *mapS,
00117   <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> *phas_n, <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> *phas_s,
00118   <span class="keyword">const</span> <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> &gt; &amp;shiftarr, <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> &gt; &amp;work)
00119   {
00120   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;nph; ++m) work[m] = mapN[m]*weight;
00121   plan.forward_c(work);
00122   read_work (work, nph, mmax, shifted, shiftarr, phas_n);
00123   <span class="keywordflow">if</span> (mapN!=mapS)
00124     {
00125     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;nph; ++m) work[m] = mapS[m]*weight;
00126     plan.forward_c(work);
00127     read_work (work, nph, mmax, shifted, shiftarr, phas_s);
00128     }
00129   <span class="keywordflow">else</span>
00130     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;=mmax; ++m) phas_s[m]=0;
00131   }
00132 
00133 <span class="keywordtype">void</span> recalc_alm2map (<span class="keywordtype">int</span> nph, <span class="keywordtype">int</span> mmax, rfft &amp;plan,
00134   <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> &gt; &amp;shiftarr)
00135   {
00136   <span class="keywordflow">if</span> (plan.size() == nph) <span class="keywordflow">return</span>;
00137   plan.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html#a8">Set</a> (nph);
00138   <span class="keywordtype">double</span> f1 = pi/nph;
00139   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;=mmax; ++m)
00140     {
00141     <span class="keywordflow">if</span> (m&lt;nph)
00142       shiftarr[m].<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html#a8">Set</a> (cos(m*f1),sin(m*f1));
00143     <span class="keywordflow">else</span>
00144       shiftarr[m]=-shiftarr[m-nph];
00145     }
00146   }
00147 
00148 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> fft_alm2map (<span class="keywordtype">int</span> nph, <span class="keywordtype">int</span> mmax, <span class="keywordtype">bool</span> shifted,
00149   rfft &amp;plan, T *mapN, T *mapS, <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> *b_north,
00150   <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> *b_south, <span class="keyword">const</span> <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> &gt; &amp;shiftarr,
00151   <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> &gt; &amp;work)
00152   {
00153   fill_work (b_north, nph, mmax, shifted, shiftarr, work);
00154   plan.backward_c(work);
00155   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;nph; ++m) mapN[m] = work[m].<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html#o0">re</a>;
00156   <span class="keywordflow">if</span> (mapN==mapS) <span class="keywordflow">return</span>;
00157   fill_work (b_south, nph, mmax, shifted, shiftarr, work);
00158   plan.backward_c(work);
00159   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;nph; ++m) mapS[m] = work[m].<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html#o0">re</a>;
00160   }
00161 
00162 } <span class="comment">// namespace</span>
00163 
<a name="l00164"></a><a class="code" href="group__alm__map__group.html#ga0">00164</a> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> <a class="code" href="group__alm__map__group.html#ga0">map2alm</a> (<span class="keyword">const</span> <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;T&gt;</a> &amp;map,
00165   <a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;T&gt;</a> &gt; &amp;alm, <span class="keyword">const</span> <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> &amp;weight, <span class="keywordtype">bool</span> add_alm)
00166   {
00167   <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__assertgroup.html#gga1">planck_assert</a> (map.<a class="code" href="classHealpix__Base.html#a22">Scheme</a>()==RING, <span class="stringliteral">"map2alm: map must be in RING scheme"</span>);
00168   <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__assertgroup.html#gga1">planck_assert</a> (weight.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html#a5">size</a>()&gt;=2*map.<a class="code" href="classHealpix__Base.html#a20">Nside</a>(),
00169     <span class="stringliteral">"map2alm: weight array has too few entries"</span>);
00170 
00171   <span class="keywordtype">int</span> lmax = alm.Lmax(), mmax = alm.Mmax(), nside = map.<a class="code" href="classHealpix__Base.html#a20">Nside</a>();
00172 
00173   <span class="keywordtype">int</span> nchunks, chunksize;
00174   get_chunk_info(2*nside,nchunks,chunksize);
00175 
00176   <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr2.html">arr2&lt;xcomplex&lt;double&gt;</a> &gt; phas_n(chunksize,mmax+1), phas_s(chunksize,mmax+1);
00177   <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> cth(chunksize), sth(chunksize);
00178   <span class="keywordtype">double</span> normfact = pi/(3*nside*nside);
00179 
00180   <span class="keywordflow">if</span> (!add_alm) alm.SetToZero();
00181 
00182   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> chunk=0; chunk&lt;nchunks; ++chunk)
00183     {
00184     <span class="keywordtype">int</span> llim=chunk*chunksize, ulim=min(llim+chunksize,2*nside);
00185 
00186 <span class="preprocessor">#pragma omp parallel</span>
00187 <span class="preprocessor"></span>{
00188     <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;xcomplex&lt;double&gt;</a> &gt; shiftarr(mmax+1), work(4*nside);
00189     rfft plan;
00190 
00191     <span class="keywordtype">int</span> ith;
00192 <span class="preprocessor">#pragma omp for schedule(dynamic,1)</span>
00193 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (ith=llim; ith&lt;ulim; ++ith)
00194       {
00195       <span class="keywordtype">int</span> istart_north, istart_south, nph;
00196       <span class="keywordtype">bool</span> shifted;
00197       map.<a class="code" href="classHealpix__Base.html#a14">get_ring_info</a> (ith+1,istart_north,nph,cth[ith-llim],sth[ith-llim],
00198                          shifted);
00199       istart_south = 12*nside*nside - istart_north - nph;
00200 
00201       recalc_map2alm (nph, mmax, plan, shiftarr);
00202       fft_map2alm (nph, mmax, shifted, weight[ith]*normfact, plan,
00203         &amp;map[istart_north], &amp;map[istart_south], phas_n[ith-llim],
00204         phas_s[ith-llim], shiftarr, work);
00205       }
00206 } <span class="comment">// end of parallel region</span>
00207 
00208 <span class="preprocessor">#pragma omp parallel</span>
00209 <span class="preprocessor"></span>{
00210     <a class="code" href="classYlmgen.html">Ylmgen</a> generator(lmax,mmax,1e-30);
00211     <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> Ylm;
00212     <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;xcomplex&lt;double&gt;</a> &gt; alm_tmp(lmax+1);
00213     <span class="keywordtype">int</span> m;
00214 <span class="preprocessor">#pragma omp for schedule(dynamic,1)</span>
00215 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (m=0; m&lt;=mmax; ++m)
00216       {
00217       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> l=m; l&lt;=lmax; ++l) alm_tmp[l].Set(0.,0.);
00218       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ith=0; ith&lt;ulim-llim; ++ith)
00219         {
00220         <span class="keywordtype">int</span> l;
00221         generator.<a class="code" href="classYlmgen.html#a1">get_Ylm</a>(cth[ith],sth[ith],m,Ylm,l);
00222         <span class="keywordflow">if</span> (l&lt;=lmax)
00223           {
00224           <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> p1 = phas_n[ith][m]+phas_s[ith][m],
00225                            p2 = phas_n[ith][m]-phas_s[ith][m];
00226 
00227           <span class="keywordflow">if</span> ((l-m)&amp;1) <span class="keywordflow">goto</span> middle;
00228 start:    alm_tmp[l].re += p1.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html#o0">re</a>*Ylm[l]; alm_tmp[l].im += p1.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html#o1">im</a>*Ylm[l];
00229           <span class="keywordflow">if</span> (++l&gt;lmax) <span class="keywordflow">goto</span> end;
00230 middle:   alm_tmp[l].re += p2.re*Ylm[l]; alm_tmp[l].im += p2.im*Ylm[l];
00231           <span class="keywordflow">if</span> (++l&lt;=lmax) <span class="keywordflow">goto</span> start;
00232 end:      ;
00233           }
00234         }
00235       <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;T&gt;</a> *palm = alm.mstart(m);
00236       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> l=m; l&lt;=lmax; ++l)
00237         { palm[l].<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html#o0">re</a> += alm_tmp[l].re; palm[l].<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html#o1">im</a> += alm_tmp[l].im; }
00238       }
00239 } <span class="comment">// end of parallel region</span>
00240     }
00241   }
00242 
00243 <span class="keyword">template</span> <span class="keywordtype">void</span> <a class="code" href="group__alm__map__group.html#ga0">map2alm</a> (<span class="keyword">const</span> <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;float&gt;</a> &amp;map,
00244   <a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;float&gt;</a> &gt; &amp;alm, <span class="keyword">const</span> <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> &amp;weight,
00245   <span class="keywordtype">bool</span> add_alm);
00246 <span class="keyword">template</span> <span class="keywordtype">void</span> <a class="code" href="group__alm__map__group.html#ga0">map2alm</a> (<span class="keyword">const</span> <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;double&gt;</a> &amp;map,
00247   <a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> &gt; &amp;alm, <span class="keyword">const</span> <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> &amp;weight,
00248   <span class="keywordtype">bool</span> add_alm);
00249 
<a name="l00250"></a><a class="code" href="group__alm__map__group.html#ga1">00250</a> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> <a class="code" href="group__alm__map__group.html#ga1">map2alm_iter</a> (<span class="keyword">const</span> <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;T&gt;</a> &amp;map,
00251   <a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;T&gt;</a> &gt; &amp;alm, <span class="keywordtype">int</span> num_iter, <span class="keyword">const</span> <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> &amp;weight)
00252   {
00253   <a class="code" href="group__alm__map__group.html#ga0">map2alm</a>(map,alm,weight);
00254   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iter=1; iter&lt;=num_iter; ++iter)
00255     {
00256     <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;T&gt;</a> map2(map.<a class="code" href="classHealpix__Base.html#a20">Nside</a>(),map.<a class="code" href="classHealpix__Base.html#a22">Scheme</a>(),SET_NSIDE);
00257     <a class="code" href="group__alm__map__group.html#ga8">alm2map</a>(alm,map2);
00258     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;map.<a class="code" href="classHealpix__Base.html#a21">Npix</a>(); ++m)
00259       map2[m] = map[m]-map2[m];
00260     <a class="code" href="group__alm__map__group.html#ga0">map2alm</a>(map2,alm,weight,<span class="keyword">true</span>);
00261     }
00262   }
00263 
00264 <span class="keyword">template</span> <span class="keywordtype">void</span> <a class="code" href="group__alm__map__group.html#ga1">map2alm_iter</a> (<span class="keyword">const</span> <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;float&gt;</a> &amp;map,
00265   <a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;float&gt;</a> &gt; &amp;alm, <span class="keywordtype">int</span> num_iter,
00266   <span class="keyword">const</span> <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> &amp;weight);
00267 <span class="keyword">template</span> <span class="keywordtype">void</span> <a class="code" href="group__alm__map__group.html#ga1">map2alm_iter</a> (<span class="keyword">const</span> <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;double&gt;</a> &amp;map,
00268   <a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> &gt; &amp;alm, <span class="keywordtype">int</span> num_iter,
00269   <span class="keyword">const</span> <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> &amp;weight);
00270 
00271 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> map2alm_iter2 (<span class="keyword">const</span> <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;T&gt;</a> &amp;map,
00272   <a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;T&gt;</a> &gt; &amp;alm, <span class="keywordtype">double</span> err_abs, <span class="keywordtype">double</span> err_rel)
00273   {
00274   <span class="keywordtype">double</span> x_err_abs=1./err_abs, x_err_rel=1./err_rel;
00275   <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> wgt(2*map.<a class="code" href="classHealpix__Base.html#a20">Nside</a>());
00276   wgt.<a class="code" href="classHealpix__Map.html#a7">fill</a>(1);
00277   <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;T&gt;</a> map2(map);
00278   alm.SetToZero();
00279   <span class="keywordflow">while</span>(<span class="keyword">true</span>)
00280     {
00281     <a class="code" href="group__alm__map__group.html#ga0">map2alm</a>(map2,alm,wgt,<span class="keyword">true</span>);
00282     <a class="code" href="group__alm__map__group.html#ga8">alm2map</a>(alm,map2);
00283     <span class="keywordtype">double</span> errmeasure=0;
00284     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;map.<a class="code" href="classHealpix__Base.html#a21">Npix</a>(); ++m)
00285       {
00286       <span class="keywordtype">double</span> err = abs(map[m]-map2[m]);
00287       <span class="keywordtype">double</span> rel = (map[m]!=0) ? abs(err/map[m]) : 1e300;
00288       errmeasure = max(errmeasure,min(err*x_err_abs,rel*x_err_rel));
00289       map2[m] = map[m]-map2[m];
00290       }
00291 cout &lt;&lt; <span class="stringliteral">"map error measure: "</span> &lt;&lt; errmeasure &lt;&lt; endl;
00292     <span class="keywordflow">if</span> (errmeasure&lt;1) <span class="keywordflow">break</span>;
00293     }
00294   }
00295 
00296 <span class="keyword">template</span> <span class="keywordtype">void</span> map2alm_iter2 (<span class="keyword">const</span> <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;double&gt;</a> &amp;map,
00297   <a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> &gt; &amp;alm, <span class="keywordtype">double</span> err_abs, <span class="keywordtype">double</span> err_rel);
00298 
00299 <span class="preprocessor">#define SETUP_LAMBDA \</span>
00300 <span class="preprocessor">  const double t1  = lam_lm1m*lam_fact[l]; \</span>
00301 <span class="preprocessor">  const double a_w = (l-m2)*two_on_s2 + l*(l-1); \</span>
00302 <span class="preprocessor">  const double a_x = twocth*(l-1)*lam_lm; \</span>
00303 <span class="preprocessor">  const double lambda_w = a_w*lam_lm - t1*c_on_s2; \</span>
00304 <span class="preprocessor">  const double lambda_x = m_on_s2 * (a_x-t1);</span>
00305 <span class="preprocessor"></span>
00306 <span class="preprocessor">#define MAP2ALM_POL_MACRO(T1,Q1,Q2,U1,U2) \</span>
00307 <span class="preprocessor">  { \</span>
00308 <span class="preprocessor">  double lam_lm1m=lam_lm; \</span>
00309 <span class="preprocessor">  lam_lm=Ylm[l]; \</span>
00310 <span class="preprocessor">  alm_tmp[l][0].re += T1.re*lam_lm; alm_tmp[l][0].im += T1.im*lam_lm; \</span>
00311 <span class="preprocessor">  SETUP_LAMBDA \</span>
00312 <span class="preprocessor">  alm_tmp[l][1].re += Q1.re*lambda_w - U2.im*lambda_x; \</span>
00313 <span class="preprocessor">  alm_tmp[l][1].im += Q1.im*lambda_w + U2.re*lambda_x; \</span>
00314 <span class="preprocessor">  alm_tmp[l][2].re += U1.re*lambda_w + Q2.im*lambda_x; \</span>
00315 <span class="preprocessor">  alm_tmp[l][2].im += U1.im*lambda_w - Q2.re*lambda_x; \</span>
00316 <span class="preprocessor">  }</span>
00317 <span class="preprocessor"></span>
00318 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> <a class="code" href="group__alm__map__group.html#ga4">map2alm_pol</a>
<a name="l00319"></a><a class="code" href="group__alm__map__group.html#ga4">00319</a>   (<span class="keyword">const</span> <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;T&gt;</a> &amp;mapT,
00320    <span class="keyword">const</span> <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;T&gt;</a> &amp;mapQ,
00321    <span class="keyword">const</span> <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;T&gt;</a> &amp;mapU,
00322    <a class="code" href="classAlm.html">Alm&lt;xcomplex&lt;T&gt;</a> &gt; &amp;almT,
00323    <a class="code" href="classAlm.html">Alm&lt;xcomplex&lt;T&gt;</a> &gt; &amp;almG,
00324    <a class="code" href="classAlm.html">Alm&lt;xcomplex&lt;T&gt;</a> &gt; &amp;almC,
00325    <span class="keyword">const</span> <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> &amp;weightT,
00326    <span class="keyword">const</span> <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> &amp;weightQ,
00327    <span class="keyword">const</span> <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> &amp;weightU,
00328    <span class="keywordtype">bool</span> add_alm)
00329   {
00330   <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__assertgroup.html#gga1">planck_assert</a> (mapT.Scheme()==RING,
00331     <span class="stringliteral">"map2alm_pol: maps must be in RING scheme"</span>);
00332   <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__assertgroup.html#gga1">planck_assert</a> (mapT.conformable(mapQ) &amp;&amp; mapT.conformable(mapU),
00333     <span class="stringliteral">"map2alm_pol: maps are not conformable"</span>);
00334   <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__assertgroup.html#gga1">planck_assert</a> (almT.conformable(almG) &amp;&amp; almT.conformable(almC),
00335     <span class="stringliteral">"map2alm_pol: a_lms are not conformable"</span>);
00336   <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__assertgroup.html#gga1">planck_assert</a> ((weightT.size()&gt;=2*mapT.Nside()) &amp;&amp;
00337     (weightQ.size()&gt;=2*mapT.Nside()) &amp;&amp; (weightU.size()&gt;=2*mapT.Nside()),
00338     <span class="stringliteral">"map2alm_pol: at least one weight array has too few entries"</span>);
00339 
00340   <span class="keywordtype">int</span> lmax = almT.Lmax(), mmax = almT.Mmax(), nside = mapT.<a class="code" href="classHealpix__Base.html#a20">Nside</a>();
00341 
00342   <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> normal_l (lmax+1);
00343   init_normal_l (normal_l);
00344 
00345   <span class="keywordtype">int</span> nchunks, chunksize;
00346   get_chunk_info(2*nside,nchunks,chunksize);
00347 
00348   <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr2.html">arr2&lt;xcomplex&lt;double&gt;</a> &gt; phas_nT(chunksize,mmax+1),phas_sT(chunksize,mmax+1),
00349                           phas_nQ(chunksize,mmax+1),phas_sQ(chunksize,mmax+1),
00350                           phas_nU(chunksize,mmax+1),phas_sU(chunksize,mmax+1);
00351 
00352   <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> cth(chunksize), sth(chunksize);
00353   <span class="keywordtype">double</span> normfact = pi/(3*nside*nside);
00354 
00355   <span class="keywordflow">if</span> (!add_alm)
00356     { almT.SetToZero(); almG.SetToZero(); almC.SetToZero(); }
00357 
00358   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> chunk=0; chunk&lt;nchunks; ++chunk)
00359     {
00360     <span class="keywordtype">int</span> llim=chunk*chunksize, ulim=min(llim+chunksize,2*nside);
00361 
00362 <span class="preprocessor">#pragma omp parallel</span>
00363 <span class="preprocessor"></span>{
00364     <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;xcomplex&lt;double&gt;</a> &gt; shiftarr(mmax+1), work(4*nside);
00365     rfft plan;
00366 
00367     <span class="keywordtype">int</span> ith;
00368 <span class="preprocessor">#pragma omp for schedule(dynamic,1)</span>
00369 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (ith=llim; ith&lt;ulim; ++ith)
00370       {
00371       <span class="keywordtype">int</span> istart_north, istart_south, nph;
00372       <span class="keywordtype">bool</span> shifted;
00373       mapT.get_ring_info (ith+1,istart_north,nph,cth[ith-llim],sth[ith-llim],
00374                           shifted);
00375       istart_south = 12*nside*nside - istart_north - nph;
00376 
00377       recalc_map2alm (nph, mmax, plan, shiftarr);
00378       fft_map2alm (nph, mmax, shifted, weightT[ith]*normfact, plan,
00379         &amp;mapT[istart_north], &amp;mapT[istart_south], phas_nT[ith-llim],
00380         phas_sT[ith-llim], shiftarr, work);
00381       fft_map2alm (nph, mmax, shifted, weightQ[ith]*normfact, plan,
00382         &amp;mapQ[istart_north], &amp;mapQ[istart_south], phas_nQ[ith-llim],
00383         phas_sQ[ith-llim], shiftarr, work);
00384       fft_map2alm (nph, mmax, shifted, weightU[ith]*normfact, plan,
00385         &amp;mapU[istart_north], &amp;mapU[istart_south], phas_nU[ith-llim],
00386         phas_sU[ith-llim], shiftarr, work);
00387       }
00388 } <span class="comment">// end of parallel region</span>
00389 
00390 <span class="preprocessor">#pragma omp parallel</span>
00391 <span class="preprocessor"></span>{
00392     <a class="code" href="classYlmgen.html">Ylmgen</a> generator(lmax,mmax,1e-30);
00393     <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> Ylm;
00394     <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> lam_fact(lmax+1);
00395     <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;xcomplex&lt;double&gt;</a>[3] &gt; alm_tmp(lmax+1);
00396     <span class="keywordtype">int</span> m;
00397 <span class="preprocessor">#pragma omp for schedule(dynamic,1)</span>
00398 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (m=0; m&lt;=mmax; ++m)
00399       {
00400       init_lam_fact_1d (m,lam_fact);
00401 
00402       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> l=m; l&lt;alm_tmp.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html#a5">size</a>(); ++l)
00403         alm_tmp[l][0]=alm_tmp[l][1]=alm_tmp[l][2] = 0;
00404 
00405       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ith=0; ith&lt;ulim-llim; ++ith)
00406         {
00407         <span class="keywordtype">int</span> l;
00408         generator.<a class="code" href="classYlmgen.html#a1">get_Ylm</a>(cth[ith],sth[ith],m,Ylm,l);
00409         <span class="keywordflow">if</span> (l&lt;=lmax)
00410           {
00411           <span class="keywordtype">double</span> one_on_s2 = 1/(sth[ith]*sth[ith]);
00412           <span class="keywordtype">double</span> c_on_s2 = cth[ith] * one_on_s2;
00413           <span class="keywordtype">double</span> two_on_s2 = 2*one_on_s2;
00414           <span class="keywordtype">double</span> twocth = 2*cth[ith];
00415           <span class="keywordtype">int</span> m2 = m*m;
00416           <span class="keywordtype">double</span> m_on_s2 = m*one_on_s2;
00417 
00418           <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> T1 = phas_nT[ith][m]+phas_sT[ith][m],
00419                            T2 = phas_nT[ith][m]-phas_sT[ith][m],
00420                            Q1 = phas_nQ[ith][m]+phas_sQ[ith][m],
00421                            Q2 = phas_nQ[ith][m]-phas_sQ[ith][m],
00422                            U1 = phas_nU[ith][m]+phas_sU[ith][m],
00423                            U2 = phas_nU[ith][m]-phas_sU[ith][m];
00424 
00425           <span class="keywordtype">double</span> lam_lm = 0;
00426           <span class="keywordflow">if</span> ((l-m)&amp;1) <span class="keywordflow">goto</span> middle;
00427 start:    MAP2ALM_POL_MACRO(T1,Q1,Q2,U1,U2)
00428           <span class="keywordflow">if</span> (++l&gt;lmax) <span class="keywordflow">goto</span> end;
00429 middle:   MAP2ALM_POL_MACRO(T2,Q2,Q1,U2,U1)
00430           <span class="keywordflow">if</span> (++l&lt;=lmax) <span class="keywordflow">goto</span> start;
00431 end:      ;
00432           }
00433         }
00434       <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;T&gt;</a> *palmT=almT.mstart(m), *palmG=almG.mstart(m),
00435                   *palmC=almC.mstart(m);
00436       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> l=m;l&lt;=lmax;++l)
00437         {
00438         palmT[l].<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html#o0">re</a> += alm_tmp[l][0].re;
00439         palmT[l].<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html#o1">im</a> += alm_tmp[l][0].im;
00440         palmG[l].re += alm_tmp[l][1].re*normal_l[l];
00441         palmG[l].im += alm_tmp[l][1].im*normal_l[l];
00442         palmC[l].re += alm_tmp[l][2].re*normal_l[l];
00443         palmC[l].im += alm_tmp[l][2].im*normal_l[l];
00444         }
00445       }
00446 } <span class="comment">// end of parallel region</span>
00447     }
00448   }
00449 
00450 <span class="keyword">template</span> <span class="keywordtype">void</span> <a class="code" href="group__alm__map__group.html#ga4">map2alm_pol</a>
00451   (<span class="keyword">const</span> <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;float&gt;</a> &amp;mapT,
00452    <span class="keyword">const</span> <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;float&gt;</a> &amp;mapQ,
00453    <span class="keyword">const</span> <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;float&gt;</a> &amp;mapU,
00454    <a class="code" href="classAlm.html">Alm&lt;xcomplex&lt;float&gt;</a> &gt; &amp;almT,
00455    <a class="code" href="classAlm.html">Alm&lt;xcomplex&lt;float&gt;</a> &gt; &amp;almG,
00456    <a class="code" href="classAlm.html">Alm&lt;xcomplex&lt;float&gt;</a> &gt; &amp;almC,
00457    <span class="keyword">const</span> <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> &amp;weightT,
00458    <span class="keyword">const</span> <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> &amp;weightQ,
00459    <span class="keyword">const</span> <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> &amp;weightU,
00460    <span class="keywordtype">bool</span> add_alm);
00461 <span class="keyword">template</span> <span class="keywordtype">void</span> <a class="code" href="group__alm__map__group.html#ga4">map2alm_pol</a>
00462   (<span class="keyword">const</span> <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;double&gt;</a> &amp;mapT,
00463    <span class="keyword">const</span> <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;double&gt;</a> &amp;mapQ,
00464    <span class="keyword">const</span> <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;double&gt;</a> &amp;mapU,
00465    <a class="code" href="classAlm.html">Alm&lt;xcomplex&lt;double&gt;</a> &gt; &amp;almT,
00466    <a class="code" href="classAlm.html">Alm&lt;xcomplex&lt;double&gt;</a> &gt; &amp;almG,
00467    <a class="code" href="classAlm.html">Alm&lt;xcomplex&lt;double&gt;</a> &gt; &amp;almC,
00468    <span class="keyword">const</span> <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> &amp;weightT,
00469    <span class="keyword">const</span> <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> &amp;weightQ,
00470    <span class="keyword">const</span> <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> &amp;weightU,
00471    <span class="keywordtype">bool</span> add_alm);
00472 
00473 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> <a class="code" href="group__alm__map__group.html#ga5">map2alm_pol_iter</a>
<a name="l00474"></a><a class="code" href="group__alm__map__group.html#ga5">00474</a>   (<span class="keyword">const</span> <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;T&gt;</a> &amp;mapT,
00475    <span class="keyword">const</span> <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;T&gt;</a> &amp;mapQ,
00476    <span class="keyword">const</span> <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;T&gt;</a> &amp;mapU,
00477    <a class="code" href="classAlm.html">Alm&lt;xcomplex&lt;T&gt;</a> &gt; &amp;almT,
00478    <a class="code" href="classAlm.html">Alm&lt;xcomplex&lt;T&gt;</a> &gt; &amp;almG,
00479    <a class="code" href="classAlm.html">Alm&lt;xcomplex&lt;T&gt;</a> &gt; &amp;almC,
00480    <span class="keywordtype">int</span> num_iter,
00481    <span class="keyword">const</span> <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> &amp;weightT,
00482    <span class="keyword">const</span> <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> &amp;weightQ,
00483    <span class="keyword">const</span> <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> &amp;weightU)
00484   {
00485   <a class="code" href="group__alm__map__group.html#ga4">map2alm_pol</a>(mapT,mapQ,mapU,almT,almG,almC,weightT,weightQ,weightU);
00486   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iter=1; iter&lt;=num_iter; ++iter)
00487     {
00488     <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;T&gt;</a> mapT2(mapT.Nside(),mapT.Scheme(),SET_NSIDE),
00489                    mapQ2(mapT.Nside(),mapT.Scheme(),SET_NSIDE),
00490                    mapU2(mapT.Nside(),mapT.Scheme(),SET_NSIDE);
00491 
00492     <a class="code" href="group__alm__map__group.html#ga9">alm2map_pol</a>(almT,almG,almC,mapT2,mapQ2,mapU2);
00493     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;mapT.Npix(); ++m)
00494       {
00495       mapT2[m] = mapT[m]-mapT2[m];
00496       mapQ2[m] = mapQ[m]-mapQ2[m];
00497       mapU2[m] = mapU[m]-mapU2[m];
00498       }
00499     <a class="code" href="group__alm__map__group.html#ga4">map2alm_pol</a>(mapT2,mapQ2,mapU2,almT,almG,almC,weightT,weightQ,weightU,<span class="keyword">true</span>);
00500     }
00501   }
00502 
00503 <span class="keyword">template</span> <span class="keywordtype">void</span> <a class="code" href="group__alm__map__group.html#ga5">map2alm_pol_iter</a>
00504   (<span class="keyword">const</span> <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;float&gt;</a> &amp;mapT,
00505    <span class="keyword">const</span> <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;float&gt;</a> &amp;mapQ,
00506    <span class="keyword">const</span> <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;float&gt;</a> &amp;mapU,
00507    <a class="code" href="classAlm.html">Alm&lt;xcomplex&lt;float&gt;</a> &gt; &amp;almT,
00508    <a class="code" href="classAlm.html">Alm&lt;xcomplex&lt;float&gt;</a> &gt; &amp;almG,
00509    <a class="code" href="classAlm.html">Alm&lt;xcomplex&lt;float&gt;</a> &gt; &amp;almC,
00510    <span class="keywordtype">int</span> num_iter,
00511    <span class="keyword">const</span> <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> &amp;weightT,
00512    <span class="keyword">const</span> <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> &amp;weightQ,
00513    <span class="keyword">const</span> <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> &amp;weightU);
00514 <span class="keyword">template</span> <span class="keywordtype">void</span> <a class="code" href="group__alm__map__group.html#ga5">map2alm_pol_iter</a>
00515   (<span class="keyword">const</span> <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;double&gt;</a> &amp;mapT,
00516    <span class="keyword">const</span> <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;double&gt;</a> &amp;mapQ,
00517    <span class="keyword">const</span> <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;double&gt;</a> &amp;mapU,
00518    <a class="code" href="classAlm.html">Alm&lt;xcomplex&lt;double&gt;</a> &gt; &amp;almT,
00519    <a class="code" href="classAlm.html">Alm&lt;xcomplex&lt;double&gt;</a> &gt; &amp;almG,
00520    <a class="code" href="classAlm.html">Alm&lt;xcomplex&lt;double&gt;</a> &gt; &amp;almC,
00521    <span class="keywordtype">int</span> num_iter,
00522    <span class="keyword">const</span> <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> &amp;weightT,
00523    <span class="keyword">const</span> <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> &amp;weightQ,
00524    <span class="keyword">const</span> <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> &amp;weightU);
00525 
00526 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> map2alm_pol_iter2
00527   (<span class="keyword">const</span> <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;T&gt;</a> &amp;mapT,
00528    <span class="keyword">const</span> <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;T&gt;</a> &amp;mapQ,
00529    <span class="keyword">const</span> <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;T&gt;</a> &amp;mapU,
00530    <a class="code" href="classAlm.html">Alm&lt;xcomplex&lt;T&gt;</a> &gt; &amp;almT,
00531    <a class="code" href="classAlm.html">Alm&lt;xcomplex&lt;T&gt;</a> &gt; &amp;almG,
00532    <a class="code" href="classAlm.html">Alm&lt;xcomplex&lt;T&gt;</a> &gt; &amp;almC,
00533    <span class="keywordtype">double</span> err_abs, <span class="keywordtype">double</span> err_rel)
00534   {
00535   <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> wgt(2*mapT.Nside());
00536   wgt.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html#a8">fill</a>(1);
00537   <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;T&gt;</a> mapT2(mapT), mapQ2(mapQ), mapU2(mapU);
00538   almT.SetToZero(); almG.SetToZero(); almC.SetToZero();
00539   <span class="keywordflow">while</span>(<span class="keyword">true</span>)
00540     {
00541     <a class="code" href="group__alm__map__group.html#ga4">map2alm_pol</a>(mapT2,mapQ2,mapU2,almT,almG,almC,wgt,wgt,wgt,<span class="keyword">true</span>);
00542     <a class="code" href="group__alm__map__group.html#ga9">alm2map_pol</a>(almT,almG,almC,mapT2,mapQ2,mapU2);
00543     <span class="keywordtype">double</span> errmeasure=0;
00544     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;mapT.Npix(); ++m)
00545       {
00546       <span class="keywordtype">double</span> err = abs(mapT[m]-mapT2[m]);
00547       <span class="keywordtype">double</span> rel = (mapT[m]!=0) ? abs(err/mapT[m]) : 1e300;
00548       errmeasure = max(errmeasure,min(err/err_abs,rel/err_rel));
00549       mapT2[m] = mapT[m]-mapT2[m];
00550       err = abs(mapQ[m]-mapQ2[m]);
00551       rel = (mapQ[m]!=0) ? abs(err/mapQ[m]) : 1e300;
00552       errmeasure = max(errmeasure,min(err/err_abs,rel/err_rel));
00553       mapQ2[m] = mapQ[m]-mapQ2[m];
00554       err = abs(mapU[m]-mapU2[m]);
00555       rel = (mapU[m]!=0) ? abs(err/mapU[m]) : 1e300;
00556       errmeasure = max(errmeasure,min(err/err_abs,rel/err_rel));
00557       mapU2[m] = mapU[m]-mapU2[m];
00558       }
00559 cout &lt;&lt; <span class="stringliteral">"map error measure: "</span> &lt;&lt; errmeasure &lt;&lt; endl;
00560     <span class="keywordflow">if</span> (errmeasure&lt;1) <span class="keywordflow">break</span>;
00561     }
00562   }
00563 
00564 <span class="keyword">template</span> <span class="keywordtype">void</span> map2alm_pol_iter2
00565   (<span class="keyword">const</span> <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;double&gt;</a> &amp;mapT,
00566    <span class="keyword">const</span> <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;double&gt;</a> &amp;mapQ,
00567    <span class="keyword">const</span> <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;double&gt;</a> &amp;mapU,
00568    <a class="code" href="classAlm.html">Alm&lt;xcomplex&lt;double&gt;</a> &gt; &amp;almT,
00569    <a class="code" href="classAlm.html">Alm&lt;xcomplex&lt;double&gt;</a> &gt; &amp;almG,
00570    <a class="code" href="classAlm.html">Alm&lt;xcomplex&lt;double&gt;</a> &gt; &amp;almC,
00571    <span class="keywordtype">double</span> err_abs, <span class="keywordtype">double</span> err_rel);
00572 
<a name="l00573"></a><a class="code" href="group__alm__map__group.html#ga8">00573</a> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> <a class="code" href="group__alm__map__group.html#ga8">alm2map</a> (<span class="keyword">const</span> <a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;T&gt;</a> &gt; &amp;alm,
00574   <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;T&gt;</a> &amp;map)
00575   {
00576   <span class="keywordtype">int</span> lmax = alm.Lmax(), mmax = alm.Mmax(), nside = map.<a class="code" href="classHealpix__Base.html#a20">Nside</a>();
00577 
00578   <span class="keywordtype">int</span> nchunks, chunksize;
00579   get_chunk_info(2*nside,nchunks,chunksize);
00580 
00581   <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr2.html">arr2&lt;xcomplex&lt;double&gt;</a> &gt; b_north(chunksize,mmax+1), b_south(chunksize,mmax+1);
00582   <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> cth(chunksize),sth(chunksize);
00583 
00584   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> chunk=0; chunk&lt;nchunks; ++chunk)
00585     {
00586     <span class="keywordtype">int</span> llim=chunk*chunksize, ulim=min(llim+chunksize,2*nside);
00587     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ith=llim; ith&lt;ulim; ++ith)
00588       {
00589       <span class="keywordtype">int</span> nph, istart_north;
00590       <span class="keywordtype">bool</span> shifted;
00591       map.<a class="code" href="classHealpix__Base.html#a14">get_ring_info</a> (ith+1,istart_north,nph, cth[ith-llim],sth[ith-llim],
00592                          shifted);
00593       }
00594 
00595 <span class="preprocessor">#pragma omp parallel</span>
00596 <span class="preprocessor"></span>{
00597     <a class="code" href="classYlmgen.html">Ylmgen</a> generator(lmax,mmax,1e-30);
00598     <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> Ylm;
00599     <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;xcomplex&lt;double&gt;</a> &gt; alm_tmp(lmax+1);
00600     <span class="keywordtype">int</span> m;
00601 <span class="preprocessor">#pragma omp for schedule(dynamic,1)</span>
00602 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (m=0; m&lt;=mmax; ++m)
00603       {
00604       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> l=m; l&lt;=lmax; ++l)
00605         alm_tmp[l]=alm(l,m);
00606 
00607       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ith=0; ith&lt;ulim-llim; ++ith)
00608         {
00609         <span class="keywordtype">int</span> l;
00610         generator.<a class="code" href="classYlmgen.html#a1">get_Ylm</a>(cth[ith],sth[ith],m,Ylm,l);
00611         <span class="keywordflow">if</span> (l&lt;=lmax)
00612           {
00613           <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> p1=0, p2=0;
00614 
00615           <span class="keywordflow">if</span> ((l-m)&amp;1) <span class="keywordflow">goto</span> middle;
00616 start:    p1.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html#o0">re</a> += alm_tmp[l].re*Ylm[l]; p1.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html#o1">im</a> += alm_tmp[l].im*Ylm[l];
00617           <span class="keywordflow">if</span> (++l&gt;lmax) <span class="keywordflow">goto</span> end;
00618 middle:   p2.re += alm_tmp[l].re*Ylm[l]; p2.im += alm_tmp[l].im*Ylm[l];
00619           <span class="keywordflow">if</span> (++l&lt;=lmax) <span class="keywordflow">goto</span> start;
00620 end:      b_north[ith][m] = p1+p2; b_south[ith][m] = p1-p2;
00621           }
00622         <span class="keywordflow">else</span>
00623           {
00624           b_north[ith][m] = b_south[ith][m] = 0;
00625           }
00626         }
00627       }
00628 } <span class="comment">// end of parallel region</span>
00629 
00630 <span class="preprocessor">#pragma omp parallel</span>
00631 <span class="preprocessor"></span>{
00632     <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;xcomplex&lt;double&gt;</a> &gt; shiftarr(mmax+1), work(4*nside);
00633     rfft plan;
00634     <span class="keywordtype">int</span> ith;
00635 <span class="preprocessor">#pragma omp for schedule(dynamic,1)</span>
00636 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (ith=llim; ith&lt;ulim; ++ith)
00637       {
00638       <span class="keywordtype">int</span> istart_north, istart_south, nph;
00639       <span class="keywordtype">double</span> dum1, dum2;
00640       <span class="keywordtype">bool</span> shifted;
00641       map.<a class="code" href="classHealpix__Base.html#a14">get_ring_info</a> (ith+1,istart_north,nph,dum1,dum2,shifted);
00642       istart_south = map.<a class="code" href="classHealpix__Base.html#a21">Npix</a>()-istart_north-nph;
00643       recalc_alm2map (nph, mmax, plan, shiftarr);
00644       fft_alm2map (nph, mmax, shifted, plan, &amp;map[istart_north],
00645         &amp;map[istart_south], b_north[ith-llim], b_south[ith-llim],
00646         shiftarr, work);
00647       }
00648 } <span class="comment">// end of parallel region</span>
00649     }
00650   }
00651 
00652 <span class="keyword">template</span> <span class="keywordtype">void</span> <a class="code" href="group__alm__map__group.html#ga8">alm2map</a> (<span class="keyword">const</span> <a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> &gt; &amp;alm,
00653   <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;double&gt;</a> &amp;map);
00654 <span class="keyword">template</span> <span class="keywordtype">void</span> <a class="code" href="group__alm__map__group.html#ga8">alm2map</a> (<span class="keyword">const</span> <a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;float&gt;</a> &gt; &amp;alm,
00655   <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;float&gt;</a> &amp;map);
00656 
00657 <span class="preprocessor">#define ALM2MAP_POL_MACRO(bT1,bQ1,bQ2,bU1,bU2) \</span>
00658 <span class="preprocessor">  { \</span>
00659 <span class="preprocessor">  double lam_lm1m = lam_lm; \</span>
00660 <span class="preprocessor">  lam_lm = Ylm[l]; \</span>
00661 <span class="preprocessor">  SETUP_LAMBDA \</span>
00662 <span class="preprocessor">  bT1.re+=alm_tmp[l][0].re*lam_lm;   bT1.im+=alm_tmp[l][0].im*lam_lm; \</span>
00663 <span class="preprocessor">  bQ1.re+=alm_tmp[l][1].re*lambda_w; bQ1.im+=alm_tmp[l][1].im*lambda_w; \</span>
00664 <span class="preprocessor">  bQ2.re-=alm_tmp[l][2].im*lambda_x; bQ2.im+=alm_tmp[l][2].re*lambda_x; \</span>
00665 <span class="preprocessor">  bU1.re-=alm_tmp[l][2].re*lambda_w; bU1.im-=alm_tmp[l][2].im*lambda_w; \</span>
00666 <span class="preprocessor">  bU2.re-=alm_tmp[l][1].im*lambda_x; bU2.im+=alm_tmp[l][1].re*lambda_x; \</span>
00667 <span class="preprocessor">  }</span>
00668 <span class="preprocessor"></span>
00669 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> <a class="code" href="group__alm__map__group.html#ga9">alm2map_pol</a>
<a name="l00670"></a><a class="code" href="group__alm__map__group.html#ga9">00670</a>   (<span class="keyword">const</span> <a class="code" href="classAlm.html">Alm&lt;xcomplex&lt;T&gt;</a> &gt; &amp;almT,
00671    <span class="keyword">const</span> <a class="code" href="classAlm.html">Alm&lt;xcomplex&lt;T&gt;</a> &gt; &amp;almG,
00672    <span class="keyword">const</span> <a class="code" href="classAlm.html">Alm&lt;xcomplex&lt;T&gt;</a> &gt; &amp;almC,
00673    <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;T&gt;</a> &amp;mapT,
00674    <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;T&gt;</a> &amp;mapQ,
00675    <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;T&gt;</a> &amp;mapU)
00676   {
00677   <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__assertgroup.html#gga1">planck_assert</a> (mapT.Scheme()==RING,
00678     <span class="stringliteral">"alm2map_pol: maps must be in RING scheme"</span>);
00679   <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__assertgroup.html#gga1">planck_assert</a> (mapT.conformable(mapQ) &amp;&amp; mapT.conformable(mapU),
00680     <span class="stringliteral">"alm2map_pol: maps are not conformable"</span>);
00681   <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__assertgroup.html#gga1">planck_assert</a> (almT.conformable(almG) &amp;&amp; almT.conformable(almC),
00682     <span class="stringliteral">"alm2map_pol: a_lms are not conformable"</span>);
00683 
00684   <span class="keywordtype">int</span> lmax = almT.Lmax(), mmax = almT.Mmax(), nside = mapT.<a class="code" href="classHealpix__Base.html#a20">Nside</a>();
00685 
00686   <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> normal_l (lmax+1);
00687   init_normal_l (normal_l);
00688 
00689   <span class="keywordtype">int</span> nchunks, chunksize;
00690   get_chunk_info(2*nside,nchunks,chunksize);
00691 
00692   <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr2.html">arr2&lt;xcomplex&lt;double&gt;</a> &gt;
00693     b_north_T(chunksize,mmax+1), b_south_T(chunksize,mmax+1),
00694     b_north_Q(chunksize,mmax+1), b_south_Q(chunksize,mmax+1),
00695     b_north_U(chunksize,mmax+1), b_south_U(chunksize,mmax+1);
00696 
00697   <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> cth(chunksize),sth(chunksize);
00698 
00699   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> chunk=0; chunk&lt;nchunks; ++chunk)
00700     {
00701     <span class="keywordtype">int</span> llim=chunk*chunksize, ulim=min(llim+chunksize,2*nside);
00702     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ith=llim; ith&lt;ulim; ++ith)
00703       {
00704       <span class="keywordtype">int</span> nph, istart_north;
00705       <span class="keywordtype">bool</span> shifted;
00706       mapT.get_ring_info (ith+1,istart_north,nph, cth[ith-llim],sth[ith-llim],
00707                           shifted);
00708       }
00709 
00710 <span class="preprocessor">#pragma omp parallel</span>
00711 <span class="preprocessor"></span>{
00712     <a class="code" href="classYlmgen.html">Ylmgen</a> generator(lmax,mmax,1e-30);
00713     <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> Ylm;
00714     <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> lam_fact (lmax+1);
00715     <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;xcomplex&lt;double&gt;</a>[3]&gt; alm_tmp(lmax+1);
00716     <span class="keywordtype">int</span> m;
00717 <span class="preprocessor">#pragma omp for schedule(dynamic,1)</span>
00718 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (m=0; m&lt;=mmax; ++m)
00719       {
00720       <span class="keywordtype">int</span> m2 = m*m;
00721       init_lam_fact_1d (m,lam_fact);
00722       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> l=m; l&lt;=lmax; ++l)
00723         {
00724         alm_tmp[l][0] = almT(l,m);
00725         alm_tmp[l][1] = almG(l,m)*(-normal_l[l]);
00726         alm_tmp[l][2] = almC(l,m)*(-normal_l[l]);
00727         }
00728       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ith=0; ith&lt;ulim-llim; ++ith)
00729         {
00730         <span class="keywordtype">int</span> l;
00731         generator.<a class="code" href="classYlmgen.html#a1">get_Ylm</a>(cth[ith],sth[ith],m,Ylm,l);
00732         <span class="keywordflow">if</span> (l&lt;=lmax)
00733           {
00734           <span class="keywordtype">double</span> one_on_s2 = 1/(sth[ith]*sth[ith]);
00735           <span class="keywordtype">double</span> c_on_s2 = cth[ith] * one_on_s2;
00736           <span class="keywordtype">double</span> two_on_s2 = 2*one_on_s2;
00737           <span class="keywordtype">double</span> m_on_s2 = m*one_on_s2;
00738           <span class="keywordtype">double</span> twocth = 2*cth[ith];
00739 
00740           <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> bT1=0, bT2=0, bQ1=0, bQ2=0, bU1=0, bU2=0;
00741 
00742           <span class="keywordtype">double</span> lam_lm = 0;
00743           <span class="keywordflow">if</span> ((l-m)&amp;1) <span class="keywordflow">goto</span> middle;
00744 start:    ALM2MAP_POL_MACRO(bT1,bQ1,bQ2,bU1,bU2)
00745           <span class="keywordflow">if</span> (++l&gt;lmax) <span class="keywordflow">goto</span> end;
00746 middle:   ALM2MAP_POL_MACRO(bT2,bQ2,bQ1,bU2,bU1)
00747           <span class="keywordflow">if</span> (++l&lt;=lmax) <span class="keywordflow">goto</span> start;
00748 end:      b_north_T[ith][m] = bT1+bT2; b_south_T[ith][m] = bT1-bT2;
00749           b_north_Q[ith][m] =-bQ1-bQ2; b_south_Q[ith][m] =-bQ1+bQ2;
00750           b_north_U[ith][m] = bU1+bU2; b_south_U[ith][m] = bU1-bU2;
00751           }
00752         <span class="keywordflow">else</span>
00753           {
00754           b_north_T[ith][m] = b_south_T[ith][m] = 0;
00755           b_north_Q[ith][m] = b_south_Q[ith][m] = 0;
00756           b_north_U[ith][m] = b_south_U[ith][m] = 0;
00757           }
00758         }
00759       }
00760 } <span class="comment">// end of parallel region</span>
00761 
00762 <span class="preprocessor">#pragma omp parallel</span>
00763 <span class="preprocessor"></span>{
00764     <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;xcomplex&lt;double&gt;</a> &gt; shiftarr(mmax+1), work(4*nside);
00765     rfft plan;
00766     <span class="keywordtype">int</span> ith;
00767 <span class="preprocessor">#pragma omp for schedule(dynamic,1)</span>
00768 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (ith=llim; ith&lt;ulim; ++ith)
00769       {
00770       <span class="keywordtype">int</span> nph, istart_north, istart_south;
00771       <span class="keywordtype">double</span> dum1, dum2;
00772       <span class="keywordtype">bool</span> shifted;
00773       mapT.get_ring_info (ith+1,istart_north,nph,dum1,dum2,shifted);
00774       istart_south = mapT.Npix()-istart_north-nph;
00775       recalc_alm2map (nph, mmax, plan, shiftarr);
00776       fft_alm2map (nph, mmax, shifted, plan, &amp;mapT[istart_north],
00777         &amp;mapT[istart_south], b_north_T[ith-llim], b_south_T[ith-llim],
00778         shiftarr, work);
00779       fft_alm2map (nph, mmax, shifted, plan, &amp;mapQ[istart_north],
00780         &amp;mapQ[istart_south], b_north_Q[ith-llim], b_south_Q[ith-llim],
00781         shiftarr, work);
00782       fft_alm2map (nph, mmax, shifted, plan, &amp;mapU[istart_north],
00783         &amp;mapU[istart_south], b_north_U[ith-llim], b_south_U[ith-llim],
00784         shiftarr, work);
00785       }
00786 } <span class="comment">// end of parallel region</span>
00787     }
00788   }
00789 
00790 <span class="keyword">template</span> <span class="keywordtype">void</span> <a class="code" href="group__alm__map__group.html#ga9">alm2map_pol</a> (<span class="keyword">const</span> <a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> &gt; &amp;almT,
00791                            <span class="keyword">const</span> <a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> &gt; &amp;almG,
00792                            <span class="keyword">const</span> <a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> &gt; &amp;almC,
00793                            <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;double&gt;</a> &amp;mapT,
00794                            <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;double&gt;</a> &amp;mapQ,
00795                            <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;double&gt;</a> &amp;mapU);
00796 
00797 <span class="keyword">template</span> <span class="keywordtype">void</span> <a class="code" href="group__alm__map__group.html#ga9">alm2map_pol</a> (<span class="keyword">const</span> <a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;float&gt;</a> &gt; &amp;almT,
00798                            <span class="keyword">const</span> <a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;float&gt;</a> &gt; &amp;almG,
00799                            <span class="keyword">const</span> <a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;float&gt;</a> &gt; &amp;almC,
00800                            <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;float&gt;</a> &amp;mapT,
00801                            <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;float&gt;</a> &amp;mapQ,
00802                            <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;float&gt;</a> &amp;mapU);
00803 
00804 <span class="preprocessor">#define ALM2MAP_DER1_MACRO(b1,bdth1,bdph1) \</span>
00805 <span class="preprocessor">  { \</span>
00806 <span class="preprocessor">  double lam_lm1m = lam_lm; \</span>
00807 <span class="preprocessor">  lam_lm = Ylm[l]; \</span>
00808 <span class="preprocessor">  const double t1 = alm_tmp[l].re*lam_lm; \</span>
00809 <span class="preprocessor">  const double t2 = alm_tmp[l].im*lam_lm; \</span>
00810 <span class="preprocessor">  const double t3 = l*cotanth; \</span>
00811 <span class="preprocessor">  const double t4 = one_on_s*lam_lm1m*lam_fact[l]; \</span>
00812 <span class="preprocessor">  b1.re+=t1; b1.im+=t2; \</span>
00813 <span class="preprocessor">  bdth1.re+=t3*t1-t4*alm_tmp[l].re; bdth1.im+=t3*t2-t4*alm_tmp[l].im; \</span>
00814 <span class="preprocessor">  bdph1.re-=m*t2; bdph1.im+=m*t1; \</span>
00815 <span class="preprocessor">  }</span>
00816 <span class="preprocessor"></span>
00817 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> <a class="code" href="group__alm__map__group.html#ga10">alm2map_der1</a>
<a name="l00818"></a><a class="code" href="group__alm__map__group.html#ga10">00818</a>   (<span class="keyword">const</span> <a class="code" href="classAlm.html">Alm&lt;xcomplex&lt;T&gt;</a> &gt; &amp;alm,
00819    <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;T&gt;</a> &amp;map,
00820    <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;T&gt;</a> &amp;mapdth,
00821    <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;T&gt;</a> &amp;mapdph)
00822   {
00823   <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__assertgroup.html#gga1">planck_assert</a> (map.Scheme()==RING,
00824     <span class="stringliteral">"alm2map_der1: maps must be in RING scheme"</span>);
00825   <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__assertgroup.html#gga1">planck_assert</a> (map.conformable(mapdth) &amp;&amp; map.conformable(mapdph),
00826     <span class="stringliteral">"alm2map_der1: maps are not conformable"</span>);
00827 
00828   <span class="keywordtype">int</span> lmax = alm.Lmax(), mmax = alm.Mmax(), nside = map.Nside();
00829 
00830   <span class="keywordtype">int</span> nchunks, chunksize;
00831   get_chunk_info(2*nside,nchunks,chunksize);
00832 
00833   <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr2.html">arr2&lt;xcomplex&lt;double&gt;</a> &gt;
00834     b_north(chunksize,mmax+1), b_south(chunksize,mmax+1),
00835     b_north_dth(chunksize,mmax+1), b_south_dth(chunksize,mmax+1),
00836     b_north_dph(chunksize,mmax+1), b_south_dph(chunksize,mmax+1);
00837 
00838   <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> cth(chunksize),sth(chunksize);
00839 
00840   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> chunk=0; chunk&lt;nchunks; ++chunk)
00841     {
00842     <span class="keywordtype">int</span> llim=chunk*chunksize, ulim=min(llim+chunksize,2*nside);
00843     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ith=llim; ith&lt;ulim; ++ith)
00844       {
00845       <span class="keywordtype">int</span> nph, istart_north;
00846       <span class="keywordtype">bool</span> shifted;
00847       map.get_ring_info (ith+1,istart_north,nph, cth[ith-llim],sth[ith-llim],
00848                          shifted);
00849       }
00850 
00851 <span class="preprocessor">#pragma omp parallel</span>
00852 <span class="preprocessor"></span>{
00853     <a class="code" href="classYlmgen.html">Ylmgen</a> generator(lmax,mmax,1e-30);
00854     <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> Ylm;
00855     <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;double&gt;</a> lam_fact (lmax+1);
00856     <span class="keywordtype">int</span> m;
00857 <span class="preprocessor">#pragma omp for schedule(dynamic,1)</span>
00858 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (m=0; m&lt;=mmax; ++m)
00859       {
00860       <span class="keyword">const</span> <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;T&gt;</a> *alm_tmp=alm.mstart(m);
00861       init_lam_fact_deriv_1d (m,lam_fact);
00862       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ith=0; ith&lt;ulim-llim; ++ith)
00863         {
00864         <span class="keywordtype">int</span> l;
00865         generator.<a class="code" href="classYlmgen.html#a1">get_Ylm</a>(cth[ith],sth[ith],m,Ylm,l);
00866         <span class="keywordflow">if</span> (l&lt;=lmax)
00867           {
00868           <span class="keywordtype">double</span> one_on_s = 1/sth[ith];
00869           <span class="keywordtype">double</span> cotanth = cth[ith]*one_on_s;
00870 
00871           <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> b1=0, b2=0, bdth1=0, bdth2=0, bdph1=0, bdph2=0;
00872 
00873           <span class="keywordtype">double</span> lam_lm = 0;
00874           <span class="keywordflow">if</span> ((l-m)&amp;1) <span class="keywordflow">goto</span> middle;
00875 start:    ALM2MAP_DER1_MACRO(b1,bdth1,bdph1)
00876           <span class="keywordflow">if</span> (++l&gt;lmax) <span class="keywordflow">goto</span> end;
00877 middle:   ALM2MAP_DER1_MACRO(b2,bdth2,bdph2)
00878           <span class="keywordflow">if</span> (++l&lt;=lmax) <span class="keywordflow">goto</span> start;
00879 end:      b_north[ith][m] = b1+b2; b_south[ith][m] = b1-b2;
00880           b_north_dth[ith][m] = bdth1+bdth2; b_south_dth[ith][m] = bdth2-bdth1;
00881           b_north_dph[ith][m] = (bdph1+bdph2)*one_on_s;
00882           b_south_dph[ith][m] = (bdph1-bdph2)*one_on_s;
00883           }
00884         <span class="keywordflow">else</span>
00885           {
00886           b_north[ith][m] = b_south[ith][m] = 0;
00887           b_north_dth[ith][m] = b_south_dth[ith][m] = 0;
00888           b_north_dph[ith][m] = b_south_dph[ith][m] = 0;
00889           }
00890         }
00891       }
00892 } <span class="comment">// end of parallel region</span>
00893 
00894 <span class="preprocessor">#pragma omp parallel</span>
00895 <span class="preprocessor"></span>{
00896     <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;xcomplex&lt;double&gt;</a> &gt; shiftarr(mmax+1), work(4*nside);
00897     rfft plan;
00898     <span class="keywordtype">int</span> ith;
00899 <span class="preprocessor">#pragma omp for schedule(dynamic,1)</span>
00900 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (ith=llim; ith&lt;ulim; ++ith)
00901       {
00902       <span class="keywordtype">int</span> nph, istart_north, istart_south;
00903       <span class="keywordtype">double</span> dum1, dum2;
00904       <span class="keywordtype">bool</span> shifted;
00905       map.get_ring_info (ith+1,istart_north,nph,dum1,dum2,shifted);
00906       istart_south = map.Npix()-istart_north-nph;
00907       recalc_alm2map (nph, mmax, plan, shiftarr);
00908       fft_alm2map (nph, mmax, shifted, plan, &amp;map[istart_north],
00909         &amp;map[istart_south], b_north[ith-llim], b_south[ith-llim],
00910         shiftarr, work);
00911       fft_alm2map (nph, mmax, shifted, plan, &amp;mapdth[istart_north],
00912         &amp;mapdth[istart_south], b_north_dth[ith-llim], b_south_dth[ith-llim],
00913         shiftarr, work);
00914       fft_alm2map (nph, mmax, shifted, plan, &amp;mapdph[istart_north],
00915         &amp;mapdph[istart_south], b_north_dph[ith-llim], b_south_dph[ith-llim],
00916         shiftarr, work);
00917       }
00918 } <span class="comment">// end of parallel region</span>
00919     }
00920   }
00921 
00922 <span class="keyword">template</span> <span class="keywordtype">void</span> <a class="code" href="group__alm__map__group.html#ga10">alm2map_der1</a> (<span class="keyword">const</span> <a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> &gt; &amp;alm,
00923                             <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;double&gt;</a> &amp;map,
00924                             <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;double&gt;</a> &amp;map_dth,
00925                             <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;double&gt;</a> &amp;map_dph);
00926 
00927 <span class="keyword">template</span> <span class="keywordtype">void</span> <a class="code" href="group__alm__map__group.html#ga10">alm2map_der1</a> (<span class="keyword">const</span> <a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;float&gt;</a> &gt; &amp;alm,
00928                             <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;float&gt;</a> &amp;map,
00929                             <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;float&gt;</a> &amp;map_dth,
00930                             <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;float&gt;</a> &amp;map_dph);
</pre></div><hr><address style="align: right;"><small>
Generated on Fri Jul 8 09:37:15 2005 for Healpix C++
</a> </small></address>
</body>
</html>
