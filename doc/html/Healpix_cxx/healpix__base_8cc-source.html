<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>healpix_base.cc Source File</title>
<link href="sheet.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>healpix_base.cc</h1><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> *  This file is part of Healpix_cxx.</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> *  Healpix_cxx is free software; you can redistribute it and/or modify</span>
00005 <span class="comment"> *  it under the terms of the GNU General Public License as published by</span>
00006 <span class="comment"> *  the Free Software Foundation; either version 2 of the License, or</span>
00007 <span class="comment"> *  (at your option) any later version.</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> *  Healpix_cxx is distributed in the hope that it will be useful,</span>
00010 <span class="comment"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00012 <span class="comment"> *  GNU General Public License for more details.</span>
00013 <span class="comment"> *</span>
00014 <span class="comment"> *  You should have received a copy of the GNU General Public License</span>
00015 <span class="comment"> *  along with Healpix_cxx; if not, write to the Free Software</span>
00016 <span class="comment"> *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
00017 <span class="comment"> *</span>
00018 <span class="comment"> *  For more information about HEALPix, see http://healpix.jpl.nasa.gov</span>
00019 <span class="comment"> */</span>
00020 
00021 <span class="comment">/*</span>
00022 <span class="comment"> *  Healpix_cxx is being developed at the Max-Planck-Institut fuer Astrophysik</span>
00023 <span class="comment"> *  and financially supported by the Deutsches Zentrum fuer Luft- und Raumfahrt</span>
00024 <span class="comment"> *  (DLR).</span>
00025 <span class="comment"> */</span>
00026 
00027 <span class="comment">/*</span>
00028 <span class="comment"> *  Copyright (C) 2003, 2004, 2005, 2006 Max-Planck-Society</span>
00029 <span class="comment"> *  Author: Martin Reinecke</span>
00030 <span class="comment"> */</span>
00031 
00032 <span class="preprocessor">#include "<a class="code" href="healpix__base_8h.html">healpix_base.h</a>"</span>
00033 <span class="preprocessor">#include "<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/cxxutils_8h.html">cxxutils.h</a>"</span>
00034 <span class="preprocessor">#include "<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/pointing_8h.html">pointing.h</a>"</span>
00035 <span class="preprocessor">#include "<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/arr_8h.html">arr.h</a>"</span>
00036 <span class="preprocessor">#include "<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/geom__utils_8h.html">geom_utils.h</a>"</span>
00037 
00038 <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00039 
00040 <span class="keywordtype">short</span> Healpix_Base::ctab[];
00041 <span class="keywordtype">short</span> Healpix_Base::utab[];
00042 
00043 <span class="keyword">const</span> nside_dummy SET_NSIDE=nside_dummy();
00044 
00045 Healpix_Base::Tablefiller::Tablefiller()
00046   {
00047   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;0x100; ++m)
00048     {
00049     ctab[m] =
00050          (m&amp;0x1 )       | ((m&amp;0x2 ) &lt;&lt; 7) | ((m&amp;0x4 ) &gt;&gt; 1) | ((m&amp;0x8 ) &lt;&lt; 6)
00051       | ((m&amp;0x10) &gt;&gt; 2) | ((m&amp;0x20) &lt;&lt; 5) | ((m&amp;0x40) &gt;&gt; 3) | ((m&amp;0x80) &lt;&lt; 4);
00052     utab[m] =
00053          (m&amp;0x1 )       | ((m&amp;0x2 ) &lt;&lt; 1) | ((m&amp;0x4 ) &lt;&lt; 2) | ((m&amp;0x8 ) &lt;&lt; 3)
00054       | ((m&amp;0x10) &lt;&lt; 4) | ((m&amp;0x20) &lt;&lt; 5) | ((m&amp;0x40) &lt;&lt; 6) | ((m&amp;0x80) &lt;&lt; 7);
00055     }
00056   }
00057 
00058 Healpix_Base::Tablefiller Healpix_Base::Filler;
00059 
00060 <span class="keyword">const</span> <span class="keywordtype">int</span> Healpix_Base::jrll[] = { 2,2,2,2,3,3,3,3,4,4,4,4 };
00061 <span class="keyword">const</span> <span class="keywordtype">int</span> Healpix_Base::jpll[] = { 1,3,5,7,0,2,4,6,1,3,5,7 };
00062 
<a name="l00063"></a><a class="code" href="classHealpix__Base.html#e1">00063</a> <span class="keywordtype">int</span> <a class="code" href="classHealpix__Base.html#e1">Healpix_Base::npix2nside</a> (<span class="keywordtype">int</span> npix)
00064   {
00065   <span class="keywordtype">int</span> res=<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__mathutilsgroup.html#a8">isqrt</a>(npix/12);
00066   <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__assertgroup.html#a1">planck_assert</a> (npix==res*res*12, <span class="stringliteral">"npix2nside: invalid argument"</span>);
00067   <span class="keywordflow">return</span> res;
00068   }
00069 
00070 <span class="keywordtype">int</span> Healpix_Base::ring_above (<span class="keywordtype">double</span> z)<span class="keyword"> const</span>
00071 <span class="keyword">  </span>{
00072   <span class="keywordtype">double</span> az=abs(z);
00073   <span class="keywordflow">if</span> (az&gt;twothird) <span class="comment">// polar caps</span>
00074     {
00075     <span class="keywordtype">int</span> iring = int(nside_*sqrt(3*(1-az)));
00076     <span class="keywordflow">return</span> (z&gt;0) ? iring : 4*<a class="code" href="classHealpix__Base.html#p1">nside_</a>-iring-1;
00077     }
00078   <span class="keywordflow">else</span> <span class="comment">// ----- equatorial region ---------</span>
00079     <span class="keywordflow">return</span> int(nside_*(2-1.5*z));
00080   }
00081 
00082 <span class="keywordtype">void</span> Healpix_Base::in_ring(<span class="keywordtype">int</span> iz, <span class="keywordtype">double</span> phi0, <span class="keywordtype">double</span> dphi,
00083   vector&lt;int&gt; &amp;listir)<span class="keyword"> const</span>
00084 <span class="keyword">  </span>{
00085   <span class="keywordtype">int</span> nr, ir, ipix1;
00086   <span class="keywordtype">double</span> shift=0.5;
00087 
00088   <span class="keywordflow">if</span> (iz&lt;<a class="code" href="classHealpix__Base.html#p1">nside_</a>) <span class="comment">// north pole</span>
00089     {
00090     ir = iz;
00091     nr = ir*4;
00092     ipix1 = 2*ir*(ir-1);        <span class="comment">//    lowest pixel number in the ring</span>
00093     }
00094   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (iz&gt;(3*<a class="code" href="classHealpix__Base.html#p1">nside_</a>)) <span class="comment">// south pole</span>
00095     {
00096     ir = 4*<a class="code" href="classHealpix__Base.html#p1">nside_</a> - iz;
00097     nr = ir*4;
00098     ipix1 = npix_ - 2*ir*(ir+1); <span class="comment">// lowest pixel number in the ring</span>
00099     }
00100   <span class="keywordflow">else</span> <span class="comment">// equatorial region</span>
00101     {
00102     ir = iz - <a class="code" href="classHealpix__Base.html#p1">nside_</a> + 1;           <span class="comment">//    within {1, 2*nside + 1}</span>
00103     nr = <a class="code" href="classHealpix__Base.html#p1">nside_</a>*4;
00104     <span class="keywordflow">if</span> ((ir&amp;1)==0) shift = 0;
00105     ipix1 = ncap_ + (ir-1)*nr; <span class="comment">// lowest pixel number in the ring</span>
00106     }
00107 
00108   <span class="keywordtype">int</span> ipix2 = ipix1 + nr - 1;       <span class="comment">//    highest pixel number in the ring</span>
00109 
00110    <span class="comment">// ----------- constructs the pixel list --------------</span>
00111   <span class="keywordflow">if</span> (dphi &gt; (pi-1e-7))
00112     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=ipix1; i&lt;=ipix2; ++i) listir.push_back(i);
00113   <span class="keywordflow">else</span>
00114     {
00115     <span class="keywordtype">int</span> ip_lo = ifloor&lt;int&gt;(nr*inv_twopi*(phi0-dphi) - shift)+1;
00116     <span class="keywordtype">int</span> ip_hi = ifloor&lt;int&gt;(nr*inv_twopi*(phi0+dphi) - shift);
00117     <span class="keywordtype">int</span> pixnum = ip_lo+ipix1;
00118     <span class="keywordflow">if</span> (pixnum&lt;ipix1) pixnum += nr;
00119     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=ip_lo; i&lt;=ip_hi; ++i, ++pixnum)
00120       {
00121       <span class="keywordflow">if</span> (pixnum&gt;ipix2) pixnum -= nr;
00122       listir.push_back(pixnum);
00123       }
00124     }
00125   }
00126 
00127 <span class="keywordtype">void</span> Healpix_Base::nest2xyf (<span class="keywordtype">int</span> pix, <span class="keywordtype">int</span> &amp;ix, <span class="keywordtype">int</span> &amp;iy, <span class="keywordtype">int</span> &amp;face_num)<span class="keyword"> const</span>
00128 <span class="keyword">  </span>{
00129   face_num = pix&gt;&gt;(2*<a class="code" href="classHealpix__Base.html#p0">order_</a>);
00130   pix &amp;= (npface_-1);
00131   <span class="keywordtype">int</span> raw = (pix&amp;0x5555) | ((pix&amp;0x55550000)&gt;&gt;15);
00132   ix = ctab[raw&amp;0xff] | (ctab[raw&gt;&gt;8]&lt;&lt;4);
00133   pix &gt;&gt;= 1;
00134   raw = (pix&amp;0x5555) | ((pix&amp;0x55550000)&gt;&gt;15);
00135   iy = ctab[raw&amp;0xff] | (ctab[raw&gt;&gt;8]&lt;&lt;4);
00136   }
00137 
00138 <span class="keywordtype">int</span> Healpix_Base::xyf2nest (<span class="keywordtype">int</span> ix, <span class="keywordtype">int</span> iy, <span class="keywordtype">int</span> face_num)<span class="keyword"> const</span>
00139 <span class="keyword">  </span>{
00140   <span class="keywordflow">return</span> (face_num&lt;&lt;(2*<a class="code" href="classHealpix__Base.html#p0">order_</a>)) +
00141       (utab[ix&amp;0xff] | (utab[ix&gt;&gt;8]&lt;&lt;16)
00142     | (utab[iy&amp;0xff]&lt;&lt;1) | (utab[iy&gt;&gt;8]&lt;&lt;17));
00143   }
00144 
00145 <span class="keywordtype">void</span> Healpix_Base::ring2xyf (<span class="keywordtype">int</span> pix, <span class="keywordtype">int</span> &amp;ix, <span class="keywordtype">int</span> &amp;iy, <span class="keywordtype">int</span> &amp;face_num)<span class="keyword"> const</span>
00146 <span class="keyword">  </span>{
00147   <span class="keywordtype">int</span> iring, iphi, kshift, nr;
00148 
00149   <span class="keywordtype">int</span> nl2 = 2*<a class="code" href="classHealpix__Base.html#p1">nside_</a>;
00150 
00151   <span class="keywordflow">if</span> (pix&lt;ncap_) <span class="comment">// North Polar cap</span>
00152     {
00153     iring = int(0.5*(1+<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__mathutilsgroup.html#a8">isqrt</a>(1+2*pix))); <span class="comment">//counted from North pole</span>
00154     iphi  = (pix+1) - 2*iring*(iring-1);
00155     kshift = 0;
00156     nr = iring;
00157     face_num=0;
00158     <span class="keywordtype">int</span> tmp = iphi-1;
00159     <span class="keywordflow">if</span> (tmp&gt;=(2*iring))
00160       {
00161       face_num=2;
00162       tmp-=2*iring;
00163       }
00164     <span class="keywordflow">if</span> (tmp&gt;=iring) ++face_num;
00165     }
00166   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pix&lt;(npix_-ncap_)) <span class="comment">// Equatorial region</span>
00167     {
00168     <span class="keywordtype">int</span> ip = pix - ncap_;
00169     <span class="keywordflow">if</span> (<a class="code" href="classHealpix__Base.html#p0">order_</a>&gt;=0)
00170       {
00171       iring = (ip&gt;&gt;(<a class="code" href="classHealpix__Base.html#p0">order_</a>+2)) + nside_; <span class="comment">// counted from North pole</span>
00172       iphi  = (ip&amp;(4*nside_-1)) + 1;
00173       }
00174     <span class="keywordflow">else</span>
00175       {
00176       iring = (ip/(4*nside_)) + nside_; <span class="comment">// counted from North pole</span>
00177       iphi  = (ip%(4*nside_)) + 1;
00178       }
00179     kshift = (iring+nside_)&amp;1;
00180     nr = nside_;
00181     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ire = iring-nside_+1;
00182     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> irm = nl2+2-ire;
00183     <span class="keywordtype">int</span> ifm, ifp;
00184     <span class="keywordflow">if</span> (<a class="code" href="classHealpix__Base.html#p0">order_</a>&gt;=0)
00185       {
00186       ifm = (iphi - ire/2 + nside_ -1) &gt;&gt; <a class="code" href="classHealpix__Base.html#p0">order_</a>;
00187       ifp = (iphi - irm/2 + nside_ -1) &gt;&gt; <a class="code" href="classHealpix__Base.html#p0">order_</a>;
00188       }
00189     <span class="keywordflow">else</span>
00190       {
00191       ifm = (iphi - ire/2 + nside_ -1) / nside_;
00192       ifp = (iphi - irm/2 + nside_ -1) / nside_;
00193       }
00194     <span class="keywordflow">if</span> (ifp == ifm) <span class="comment">// faces 4 to 7</span>
00195       face_num = (ifp==4) ? 4 : ifp+4;
00196     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ifp&lt;ifm) <span class="comment">// (half-)faces 0 to 3</span>
00197       face_num = ifp;
00198     <span class="keywordflow">else</span> <span class="comment">// (half-)faces 8 to 11</span>
00199       face_num = ifm + 8;
00200     }
00201   <span class="keywordflow">else</span> <span class="comment">// South Polar cap</span>
00202     {
00203     <span class="keywordtype">int</span> ip = npix_ - pix;
00204     iring = int(0.5*(1+<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__mathutilsgroup.html#a8">isqrt</a>(2*ip-1))); <span class="comment">//counted from South pole</span>
00205     iphi  = 4*iring + 1 - (ip - 2*iring*(iring-1));
00206     kshift = 0;
00207     nr = iring;
00208     iring = 2*nl2-iring;
00209     face_num=8;
00210     <span class="keywordtype">int</span> tmp = iphi-1;
00211     <span class="keywordflow">if</span> (tmp&gt;=(2*nr))
00212       {
00213       face_num=10;
00214       tmp-=2*nr;
00215       }
00216     <span class="keywordflow">if</span> (tmp&gt;=nr) ++face_num;
00217     }
00218 
00219   <span class="keywordtype">int</span> irt = iring - (jrll[face_num]*nside_) + 1;
00220   <span class="keywordtype">int</span> ipt = 2*iphi- jpll[face_num]*nr - kshift -1;
00221   <span class="keywordflow">if</span> (ipt&gt;=nl2) ipt-=8*nside_;
00222 
00223   ix =  (ipt-irt) &gt;&gt;1;
00224   iy =(-(ipt+irt))&gt;&gt;1;
00225   }
00226 
00227 <span class="keywordtype">int</span> Healpix_Base::xyf2ring (<span class="keywordtype">int</span> ix, <span class="keywordtype">int</span> iy, <span class="keywordtype">int</span> face_num)<span class="keyword"> const</span>
00228 <span class="keyword">  </span>{
00229   <span class="keywordtype">int</span> nl4 = 4*nside_;
00230   <span class="keywordtype">int</span> jr = (jrll[face_num]*nside_) - ix - iy  - 1;
00231 
00232   <span class="keywordtype">int</span> nr, kshift, n_before;
00233   <span class="keywordflow">if</span> (jr&lt;nside_)
00234     {
00235     nr = jr;
00236     n_before = 2*nr*(nr-1);
00237     kshift = 0;
00238     }
00239   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (jr &gt; 3*nside_)
00240     {
00241     nr = nl4-jr;
00242     n_before = npix_ - 2*(nr+1)*nr;
00243     kshift = 0;
00244     }
00245   <span class="keywordflow">else</span>
00246     {
00247     nr = nside_;
00248     n_before = ncap_ + (jr-nside_)*nl4;
00249     kshift = (jr-nside_)&amp;1;
00250     }
00251 
00252   <span class="keywordtype">int</span> jp = (jpll[face_num]*nr + ix - iy + 1 + kshift) / 2;
00253   <span class="keywordflow">if</span> (jp&gt;nl4)
00254     jp-=nl4;
00255   <span class="keywordflow">else</span>
00256     <span class="keywordflow">if</span> (jp&lt;1) jp+=nl4;
00257 
00258   <span class="keywordflow">return</span> n_before + jp - 1;
00259   }
00260 
<a name="l00261"></a><a class="code" href="classHealpix__Base.html#a5">00261</a> <span class="keywordtype">double</span> <a class="code" href="classHealpix__Base.html#a5">Healpix_Base::ring2z</a> (<span class="keywordtype">int</span> ring)<span class="keyword"> const</span>
00262 <span class="keyword">  </span>{
00263   <span class="keywordflow">if</span> (ring&lt;nside_)
00264     <span class="keywordflow">return</span> 1 - ring*ring*fact2_;
00265   <span class="keywordflow">if</span> (ring &lt;=3*nside_)
00266     <span class="keywordflow">return</span> (2*nside_-ring)*fact1_;
00267   ring=4*nside_ - ring;
00268   <span class="keywordflow">return</span> ring*ring*fact2_ - 1;
00269   }
00270 
<a name="l00271"></a><a class="code" href="classHealpix__Base.html#a6">00271</a> <span class="keywordtype">int</span> <a class="code" href="classHealpix__Base.html#a6">Healpix_Base::pix2ring</a> (<span class="keywordtype">int</span> pix)<span class="keyword"> const</span>
00272 <span class="keyword">  </span>{
00273   <span class="keywordflow">if</span> (<a class="code" href="classHealpix__Base.html#p7">scheme_</a>==<a class="code" href="healpix__base_8h.html#a3a1">RING</a>)
00274     {
00275     <span class="keywordflow">if</span> (pix&lt;ncap_) <span class="comment">// North Polar cap</span>
00276       <span class="keywordflow">return</span> int(0.5*(1+<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__mathutilsgroup.html#a8">isqrt</a>(1+2*pix))); <span class="comment">//counted from North pole</span>
00277     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pix&lt;(npix_-ncap_)) <span class="comment">// Equatorial region</span>
00278       {
00279       <span class="keywordtype">int</span> ip  = pix - ncap_;
00280       <span class="keywordflow">return</span> ip/(4*nside_) + nside_; <span class="comment">// counted from North pole</span>
00281       }
00282     <span class="keywordflow">else</span> <span class="comment">// South Polar cap</span>
00283       {
00284       <span class="keywordtype">int</span> ip = npix_ - pix;
00285       <span class="keywordflow">return</span> 4*nside_ - int(0.5*(1+<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__mathutilsgroup.html#a8">isqrt</a>(2*ip-1))); <span class="comment">//counted from South pole</span>
00286       }
00287     }
00288   <span class="keywordflow">else</span>
00289     {
00290     <span class="keywordtype">int</span> face_num, ix, iy;
00291     nest2xyf(pix,ix,iy,face_num);
00292     <span class="keywordflow">return</span> (jrll[face_num]&lt;&lt;<a class="code" href="classHealpix__Base.html#p0">order_</a>) - ix - iy - 1;
00293     }
00294   }
00295 
<a name="l00296"></a><a class="code" href="classHealpix__Base.html#a7">00296</a> <span class="keywordtype">int</span> <a class="code" href="classHealpix__Base.html#a7">Healpix_Base::nest2ring</a> (<span class="keywordtype">int</span> pix)<span class="keyword"> const</span>
00297 <span class="keyword">  </span>{
00298   <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__assertgroup.html#a1">planck_assert</a>(<a class="code" href="classHealpix__Base.html#p0">order_</a>&gt;=0, <span class="stringliteral">"nest2ring: need hierarchical map"</span>);
00299   <span class="keywordtype">int</span> ix, iy, face_num;
00300   nest2xyf (pix, ix, iy, face_num);
00301   <span class="keywordflow">return</span> xyf2ring (ix, iy, face_num);
00302   }
00303 
<a name="l00304"></a><a class="code" href="classHealpix__Base.html#a8">00304</a> <span class="keywordtype">int</span> <a class="code" href="classHealpix__Base.html#a8">Healpix_Base::ring2nest</a> (<span class="keywordtype">int</span> pix)<span class="keyword"> const</span>
00305 <span class="keyword">  </span>{
00306   <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__assertgroup.html#a1">planck_assert</a>(<a class="code" href="classHealpix__Base.html#p0">order_</a>&gt;=0, <span class="stringliteral">"ring2nest: need hierarchical map"</span>);
00307   <span class="keywordtype">int</span> ix, iy, face_num;
00308   ring2xyf (pix, ix, iy, face_num);
00309   <span class="keywordflow">return</span> xyf2nest (ix, iy, face_num);
00310   }
00311 
<a name="l00312"></a><a class="code" href="classHealpix__Base.html#a9">00312</a> <span class="keywordtype">int</span> <a class="code" href="classHealpix__Base.html#a9">Healpix_Base::nest2peano</a> (<span class="keywordtype">int</span> pix)<span class="keyword"> const</span>
00313 <span class="keyword">  </span>{
00314   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> subpix[8][4] = {
00315     { 0, 1, 3, 2 }, { 3, 0, 2, 1 }, { 2, 3, 1, 0 }, { 1, 2, 0, 3 },
00316     { 0, 3, 1, 2 }, { 1, 0, 2, 3 }, { 2, 1, 3, 0 }, { 3, 2, 0, 1 } };
00317   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> subpath[8][4] = {
00318     { 4, 0, 6, 0 }, { 7, 5, 1, 1 }, { 2, 4, 2, 6 }, { 3, 3, 7, 5 },
00319     { 0, 2, 4, 4 }, { 5, 1, 5, 3 }, { 6, 6, 0, 2 }, { 1, 7, 3, 7 } };
00320   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> face2path[12] = {
00321     2, 5, 2, 5, 3, 6, 3, 6, 2, 3, 2, 3 };
00322   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> face2peanoface[12] = {
00323     0, 5, 6, 11, 10, 1, 4, 7, 2, 3, 8, 9 };
00324 
00325   <span class="keywordtype">int</span> face = pix&gt;&gt;(2*<a class="code" href="classHealpix__Base.html#p0">order_</a>);
00326   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> path = face2path[face];
00327   <span class="keywordtype">int</span> result = 0;
00328 
00329   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> shift=2*<a class="code" href="classHealpix__Base.html#p0">order_</a>-2; shift&gt;=0; shift-=2)
00330     {
00331     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> spix = (pix&gt;&gt;shift) &amp; 0x3;
00332     result &lt;&lt;= 2;
00333     result |= subpix[path][spix];
00334     path=subpath[path][spix];
00335     }
00336 
00337   <span class="keywordflow">return</span> result + (int(face2peanoface[face])&lt;&lt;(2*<a class="code" href="classHealpix__Base.html#p0">order_</a>));
00338   }
00339 
<a name="l00340"></a><a class="code" href="classHealpix__Base.html#a10">00340</a> <span class="keywordtype">int</span> <a class="code" href="classHealpix__Base.html#a10">Healpix_Base::peano2nest</a> (<span class="keywordtype">int</span> pix)<span class="keyword"> const</span>
00341 <span class="keyword">  </span>{
00342   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> subpix[8][4] = {
00343     { 0, 1, 3, 2 }, { 1, 3, 2, 0 }, { 3, 2, 0, 1 }, { 2, 0, 1, 3 },
00344     { 0, 2, 3, 1 }, { 1, 0, 2, 3 }, { 3, 1, 0, 2 }, { 2, 3, 1, 0 } };
00345   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> subpath[8][4] = {
00346     { 4, 0, 0, 6 }, { 5, 1, 1, 7 }, { 6, 2, 2, 4 }, { 7, 3, 3, 5 },
00347     { 0, 4, 4, 2 }, { 1, 5, 5, 3 }, { 2, 6, 6, 0 }, { 3, 7, 7, 1 } };
00348   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> face2path[12] = {
00349     2, 6, 2, 3, 3, 5, 2, 6, 2, 3, 3, 5 };
00350   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> peanoface2face[12] = {
00351     0, 5, 8, 9, 6, 1, 2, 7, 10, 11, 4, 3 };
00352 
00353   <span class="keywordtype">int</span> face = pix&gt;&gt;(2*<a class="code" href="classHealpix__Base.html#p0">order_</a>);
00354   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> path = face2path[face];
00355   <span class="keywordtype">int</span> result = 0;
00356 
00357   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> shift=2*<a class="code" href="classHealpix__Base.html#p0">order_</a>-2; shift&gt;=0; shift-=2)
00358     {
00359     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> spix = (pix&gt;&gt;shift) &amp; 0x3;
00360     result &lt;&lt;= 2;
00361     result |= subpix[path][spix];
00362     path=subpath[path][spix];
00363     }
00364 
00365   <span class="keywordflow">return</span> result + (int(peanoface2face[face])&lt;&lt;(2*<a class="code" href="classHealpix__Base.html#p0">order_</a>));
00366   }
00367 
00368 <span class="keywordtype">int</span> Healpix_Base::ang2pix_z_phi (<span class="keywordtype">double</span> z, <span class="keywordtype">double</span> phi)<span class="keyword"> const</span>
00369 <span class="keyword">  </span>{
00370   <span class="keywordtype">double</span> za = abs(z);
00371   <span class="keywordtype">double</span> tt = <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__mathutilsgroup.html#a5">fmodulo</a>(phi,twopi) * inv_halfpi; <span class="comment">// in [0,4)</span>
00372 
00373   <span class="keywordflow">if</span> (<a class="code" href="classHealpix__Base.html#p7">scheme_</a>==<a class="code" href="healpix__base_8h.html#a3a1">RING</a>)
00374     {
00375     <span class="keywordflow">if</span> (za&lt;=twothird) <span class="comment">// Equatorial region</span>
00376       {
00377       <span class="keywordtype">double</span> temp1 = nside_*(0.5+tt);
00378       <span class="keywordtype">double</span> temp2 = nside_*z*0.75;
00379       <span class="keywordtype">int</span> jp = int(temp1-temp2); <span class="comment">// index of  ascending edge line</span>
00380       <span class="keywordtype">int</span> jm = int(temp1+temp2); <span class="comment">// index of descending edge line</span>
00381 
00382       <span class="comment">// ring number counted from z=2/3</span>
00383       <span class="keywordtype">int</span> ir = nside_ + 1 + jp - jm; <span class="comment">// in {1,2n+1}</span>
00384       <span class="keywordtype">int</span> kshift = 1-(ir&amp;1); <span class="comment">// kshift=1 if ir even, 0 otherwise</span>
00385 
00386       <span class="keywordtype">int</span> ip = (jp+jm-nside_+kshift+1)/2; <span class="comment">// in {0,4n-1}</span>
00387       ip = <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__mathutilsgroup.html#a6">imodulo</a>(ip,4*nside_);
00388 
00389       <span class="keywordflow">return</span> ncap_ + (ir-1)*4*nside_ + ip;
00390       }
00391     <span class="keywordflow">else</span>  <span class="comment">// North &amp; South polar caps</span>
00392       {
00393       <span class="keywordtype">double</span> tp = tt-int(tt);
00394       <span class="keywordtype">double</span> tmp = nside_*sqrt(3*(1-za));
00395 
00396       <span class="keywordtype">int</span> jp = int(tp*tmp); <span class="comment">// increasing edge line index</span>
00397       <span class="keywordtype">int</span> jm = int((1.0-tp)*tmp); <span class="comment">// decreasing edge line index</span>
00398 
00399       <span class="keywordtype">int</span> ir = jp+jm+1; <span class="comment">// ring number counted from the closest pole</span>
00400       <span class="keywordtype">int</span> ip = int(tt*ir); <span class="comment">// in {0,4*ir-1}</span>
00401       ip = <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__mathutilsgroup.html#a6">imodulo</a>(ip,4*ir);
00402 
00403       <span class="keywordflow">if</span> (z&gt;0)
00404         <span class="keywordflow">return</span> 2*ir*(ir-1) + ip;
00405       <span class="keywordflow">else</span>
00406         <span class="keywordflow">return</span> npix_ - 2*ir*(ir+1) + ip;
00407       }
00408     }
00409   <span class="keywordflow">else</span> <span class="comment">// scheme_ == NEST</span>
00410     {
00411     <span class="keywordtype">int</span> face_num, ix, iy;
00412 
00413     <span class="keywordflow">if</span> (za&lt;=twothird) <span class="comment">// Equatorial region</span>
00414       {
00415       <span class="keywordtype">double</span> temp1 = nside_*(0.5+tt);
00416       <span class="keywordtype">double</span> temp2 = nside_*(z*0.75);
00417       <span class="keywordtype">int</span> jp = int(temp1-temp2); <span class="comment">// index of  ascending edge line</span>
00418       <span class="keywordtype">int</span> jm = int(temp1+temp2); <span class="comment">// index of descending edge line</span>
00419       <span class="keywordtype">int</span> ifp = jp &gt;&gt; <a class="code" href="classHealpix__Base.html#p0">order_</a>;  <span class="comment">// in {0,4}</span>
00420       <span class="keywordtype">int</span> ifm = jm &gt;&gt; order_;
00421       <span class="keywordflow">if</span> (ifp == ifm)           <span class="comment">// faces 4 to 7</span>
00422         face_num = (ifp==4) ? 4: ifp+4;
00423       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ifp &lt; ifm)       <span class="comment">// (half-)faces 0 to 3</span>
00424         face_num = ifp;
00425       <span class="keywordflow">else</span>                      <span class="comment">// (half-)faces 8 to 11</span>
00426         face_num = ifm + 8;
00427 
00428       ix = jm &amp; (nside_-1);
00429       iy = nside_ - (jp &amp; (nside_-1)) - 1;
00430       }
00431     <span class="keywordflow">else</span> <span class="comment">// polar region, za &gt; 2/3</span>
00432       {
00433       <span class="keywordtype">int</span> ntt = int(tt);
00434       <span class="keywordtype">double</span> tp = tt-ntt;
00435       <span class="keywordtype">double</span> tmp = nside_*sqrt(3*(1-za));
00436 
00437       <span class="keywordtype">int</span> jp = int(tp*tmp); <span class="comment">// increasing edge line index</span>
00438       <span class="keywordtype">int</span> jm = int((1.0-tp)*tmp); <span class="comment">// decreasing edge line index</span>
00439       <span class="keywordflow">if</span> (jp&gt;=nside_) jp = nside_-1; <span class="comment">// for points too close to the boundary</span>
00440       <span class="keywordflow">if</span> (jm&gt;=nside_) jm = nside_-1;
00441       <span class="keywordflow">if</span> (z &gt;= 0)
00442         {
00443         face_num = ntt;  <span class="comment">// in {0,3}</span>
00444         ix = nside_ - jm - 1;
00445         iy = nside_ - jp - 1;
00446         }
00447       <span class="keywordflow">else</span>
00448         {
00449         face_num = ntt + 8; <span class="comment">// in {8,11}</span>
00450         ix =  jp;
00451         iy =  jm;
00452         }
00453       }
00454 
00455     <span class="keywordflow">return</span> xyf2nest(ix,iy,face_num);
00456     }
00457   }
00458 
00459 <span class="keywordtype">void</span> Healpix_Base::pix2ang_z_phi (<span class="keywordtype">int</span> pix, <span class="keywordtype">double</span> &amp;z, <span class="keywordtype">double</span> &amp;phi)<span class="keyword"> const</span>
00460 <span class="keyword">  </span>{
00461   <span class="keywordflow">if</span> (<a class="code" href="classHealpix__Base.html#p7">scheme_</a>==<a class="code" href="healpix__base_8h.html#a3a1">RING</a>)
00462     {
00463     <span class="keywordflow">if</span> (pix&lt;ncap_) <span class="comment">// North Polar cap</span>
00464       {
00465       <span class="keywordtype">int</span> iring = int(0.5*(1+<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__mathutilsgroup.html#a8">isqrt</a>(1+2*pix))); <span class="comment">//counted from North pole</span>
00466       <span class="keywordtype">int</span> iphi  = (pix+1) - 2*iring*(iring-1);
00467 
00468       z = 1.0 - (iring*iring)*fact2_;
00469       phi = (iphi-0.5) * halfpi/iring;
00470       }
00471     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pix&lt;(npix_-ncap_)) <span class="comment">// Equatorial region</span>
00472       {
00473       <span class="keywordtype">int</span> ip  = pix - ncap_;
00474       <span class="keywordtype">int</span> iring = ip/(4*nside_) + nside_; <span class="comment">// counted from North pole</span>
00475       <span class="keywordtype">int</span> iphi  = ip%(4*nside_) + 1;
00476       <span class="comment">// 1 if iring+nside is odd, 1/2 otherwise</span>
00477       <span class="keywordtype">double</span> fodd = ((iring+nside_)&amp;1) ? 1 : 0.5;
00478 
00479       <span class="keywordtype">int</span> nl2 = 2*nside_;
00480       z = (nl2-iring)*fact1_;
00481       phi = (iphi-fodd) * pi/nl2;
00482       }
00483     <span class="keywordflow">else</span> <span class="comment">// South Polar cap</span>
00484       {
00485       <span class="keywordtype">int</span> ip = npix_ - pix;
00486       <span class="keywordtype">int</span> iring = int(0.5*(1+<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__mathutilsgroup.html#a8">isqrt</a>(2*ip-1))); <span class="comment">//counted from South pole</span>
00487       <span class="keywordtype">int</span> iphi  = 4*iring + 1 - (ip - 2*iring*(iring-1));
00488 
00489       z = -1.0 + (iring*iring)*fact2_;
00490       phi = (iphi-0.5) * halfpi/iring;
00491       }
00492     }
00493   <span class="keywordflow">else</span>
00494     {
00495     <span class="keywordtype">int</span> nl4 = nside_*4;
00496 
00497     <span class="keywordtype">int</span> face_num, ix, iy;
00498     nest2xyf(pix,ix,iy,face_num);
00499 
00500     <span class="keywordtype">int</span> jr = (jrll[face_num]&lt;&lt;<a class="code" href="classHealpix__Base.html#p0">order_</a>) - ix - iy - 1;
00501 
00502     <span class="keywordtype">int</span> nr, kshift;
00503     <span class="keywordflow">if</span> (jr&lt;nside_)
00504       {
00505       nr = jr;
00506       z = 1 - nr*nr*fact2_;
00507       kshift = 0;
00508       }
00509     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (jr &gt; 3*nside_)
00510       {
00511       nr = nl4-jr;
00512       z = nr*nr*fact2_ - 1;
00513       kshift = 0;
00514       }
00515     <span class="keywordflow">else</span>
00516       {
00517       nr = nside_;
00518       z = (2*nside_-jr)*fact1_;
00519       kshift = (jr-nside_)&amp;1;
00520       }
00521 
00522     <span class="keywordtype">int</span> jp = (jpll[face_num]*nr + ix -iy + 1 + kshift) / 2;
00523     <span class="keywordflow">if</span> (jp&gt;nl4) jp-=nl4;
00524     <span class="keywordflow">if</span> (jp&lt;1) jp+=nl4;
00525 
00526     phi = (jp-(kshift+1)*0.5)*(halfpi/nr);
00527     }
00528   }
00529 
<a name="l00530"></a><a class="code" href="classHealpix__Base.html#a17">00530</a> <span class="keywordtype">void</span> <a class="code" href="classHealpix__Base.html#a17">Healpix_Base::query_disc</a> (<span class="keyword">const</span> <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classpointing.html">pointing</a> &amp;ptg, <span class="keywordtype">double</span> radius,
00531   vector&lt;int&gt;&amp; listpix)<span class="keyword"> const</span>
00532 <span class="keyword">  </span>{
00533   listpix.clear();
00534 
00535   <span class="keywordtype">double</span> dth1 = fact2_;
00536   <span class="keywordtype">double</span> dth2 = fact1_;
00537   <span class="keywordtype">double</span> cosang = cos(radius);
00538 
00539   <span class="keywordtype">double</span> z0 = cos(ptg.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classpointing.html#o0">theta</a>);
00540   <span class="keywordtype">double</span> xa = 1./sqrt((1-z0)*(1+z0));
00541 
00542   <span class="keywordtype">double</span> rlat1  = ptg.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classpointing.html#o0">theta</a> - radius;
00543   <span class="keywordtype">double</span> zmax = cos(rlat1);
00544   <span class="keywordtype">int</span> irmin = ring_above (zmax)+1;
00545 
00546   <span class="keywordflow">if</span> (rlat1&lt;=0) <span class="comment">// north pole in the disc</span>
00547     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=1; m&lt;irmin; ++m) <span class="comment">// rings completely in the disc</span>
00548       in_ring (m, 0, pi, listpix);
00549 
00550   <span class="keywordtype">double</span> rlat2  = ptg.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classpointing.html#o0">theta</a> + radius;
00551   <span class="keywordtype">double</span> zmin = cos(rlat2);
00552   <span class="keywordtype">int</span> irmax = ring_above (zmin);
00553 
00554 <span class="comment">// ------------- loop on ring number ---------------------</span>
00555   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iz=irmin; iz&lt;=irmax; ++iz) <span class="comment">// rings partially in the disc</span>
00556     {
00557     <span class="keywordtype">double</span> z;
00558     <span class="keywordflow">if</span> (iz&lt;nside_) <span class="comment">// north polar cap</span>
00559       z = 1.0 - iz*iz*dth1;
00560     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (iz &lt;= (3*nside_)) <span class="comment">// tropical band + equat.</span>
00561       z = (2*nside_-iz) * dth2;
00562     <span class="keywordflow">else</span>
00563       z = -1.0 + (4*nside_-iz)*(4*nside_-iz)*dth1;
00564 
00565 <span class="comment">// --------- phi range in the disc for each z ---------</span>
00566     <span class="keywordtype">double</span> x = (cosang-z*z0)*xa;
00567     <span class="keywordtype">double</span> ysq = 1-z*z-x*x;
00568     <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__assertgroup.html#a1">planck_assert</a>(ysq&gt;=0, <span class="stringliteral">"error in query_disc()"</span>);
00569     <span class="keywordtype">double</span> dphi=atan2(sqrt(ysq),x);
00570     in_ring (iz, ptg.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classpointing.html#o1">phi</a>, dphi, listpix);
00571     }
00572 
00573   <span class="keywordflow">if</span> (rlat2&gt;=pi) <span class="comment">// south pole in the disc</span>
00574     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=irmax+1; m&lt;(4*nside_); ++m)  <span class="comment">// rings completely in the disc</span>
00575       in_ring (m, 0, pi, listpix);
00576 
00577   <span class="keywordflow">if</span> (<a class="code" href="classHealpix__Base.html#p7">scheme_</a>==<a class="code" href="healpix__base_8h.html#a3a2">NEST</a>)
00578     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> m=0; m&lt;listpix.size(); ++m)
00579       listpix[m] = <a class="code" href="classHealpix__Base.html#a8">ring2nest</a>(listpix[m]);
00580   }
00581 
<a name="l00582"></a><a class="code" href="classHealpix__Base.html#a19">00582</a> <span class="keywordtype">void</span> <a class="code" href="classHealpix__Base.html#a19">Healpix_Base::get_ring_info</a> (<span class="keywordtype">int</span> ring, <span class="keywordtype">int</span> &amp;startpix, <span class="keywordtype">int</span> &amp;ringpix,
00583   <span class="keywordtype">double</span> &amp;costheta, <span class="keywordtype">double</span> &amp;sintheta, <span class="keywordtype">bool</span> &amp;shifted)<span class="keyword"> const</span>
00584 <span class="keyword">  </span>{
00585   <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__assertgroup.html#a1">planck_assert</a>(<a class="code" href="classHealpix__Base.html#p7">scheme_</a>==<a class="code" href="healpix__base_8h.html#a3a1">RING</a>,<span class="stringliteral">"map must be in RING scheme"</span>);
00586   <span class="keywordtype">int</span> northring = (ring&gt;2*nside_) ? 4*nside_-ring : ring;
00587   <span class="keywordflow">if</span> (northring &lt; nside_)
00588     {
00589     <span class="keywordtype">double</span> tmp = northring*northring*fact2_;
00590     costheta = 1 - tmp;
00591     sintheta = sqrt(tmp*(2-tmp));
00592     ringpix = 4*northring;
00593     shifted = <span class="keyword">true</span>;
00594     startpix = 2*northring*(northring-1);
00595     }
00596   <span class="keywordflow">else</span>
00597     {
00598     costheta = (2*nside_-northring)*fact1_;
00599     sintheta = sqrt((1+costheta)*(1-costheta));
00600     ringpix = 4*nside_;
00601     shifted = ((northring-nside_) &amp; 1) == 0;
00602     startpix = ncap_ + (northring-nside_)*ringpix;
00603     }
00604   <span class="keywordflow">if</span> (northring != ring) <span class="comment">// southern hemisphere</span>
00605     {
00606     costheta = -costheta;
00607     startpix = npix_ - startpix - ringpix;
00608     }
00609   }
00610 
<a name="l00611"></a><a class="code" href="classHealpix__Base.html#a21">00611</a> <span class="keywordtype">void</span> <a class="code" href="classHealpix__Base.html#a21">Healpix_Base::neighbors</a> (<span class="keywordtype">int</span> pix, <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classfix__arr.html">fix_arr&lt;int,8&gt;</a> &amp;result)<span class="keyword"> const</span>
00612 <span class="keyword">  </span>{
00613   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> xoffset[] = { -1,-1, 0, 1, 1, 1, 0,-1 };
00614   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> yoffset[] = {  0, 1, 1, 1, 0,-1,-1,-1 };
00615   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> facearray[][12] =
00616         { {  8, 9,10,11,-1,-1,-1,-1,10,11, 8, 9 },   <span class="comment">// S</span>
00617           {  5, 6, 7, 4, 8, 9,10,11, 9,10,11, 8 },   <span class="comment">// SE</span>
00618           { -1,-1,-1,-1, 5, 6, 7, 4,-1,-1,-1,-1 },   <span class="comment">// E</span>
00619           {  4, 5, 6, 7,11, 8, 9,10,11, 8, 9,10 },   <span class="comment">// SW</span>
00620           {  0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11 },   <span class="comment">// center</span>
00621           {  1, 2, 3, 0, 0, 1, 2, 3, 5, 6, 7, 4 },   <span class="comment">// NE</span>
00622           { -1,-1,-1,-1, 7, 4, 5, 6,-1,-1,-1,-1 },   <span class="comment">// W</span>
00623           {  3, 0, 1, 2, 3, 0, 1, 2, 4, 5, 6, 7 },   <span class="comment">// NW</span>
00624           {  2, 3, 0, 1,-1,-1,-1,-1, 0, 1, 2, 3 } }; <span class="comment">// N</span>
00625   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> swaparray[][12] =
00626         { {  0,0,0,0,0,0,0,0,3,3,3,3 },   <span class="comment">// S</span>
00627           {  0,0,0,0,0,0,0,0,6,6,6,6 },   <span class="comment">// SE</span>
00628           {  0,0,0,0,0,0,0,0,0,0,0,0 },   <span class="comment">// E</span>
00629           {  0,0,0,0,0,0,0,0,5,5,5,5 },   <span class="comment">// SW</span>
00630           {  0,0,0,0,0,0,0,0,0,0,0,0 },   <span class="comment">// center</span>
00631           {  5,5,5,5,0,0,0,0,0,0,0,0 },   <span class="comment">// NE</span>
00632           {  0,0,0,0,0,0,0,0,0,0,0,0 },   <span class="comment">// W</span>
00633           {  6,6,6,6,0,0,0,0,0,0,0,0 },   <span class="comment">// NW</span>
00634           {  3,3,3,3,0,0,0,0,0,0,0,0 } }; <span class="comment">// N</span>
00635 
00636   <span class="keywordtype">int</span> ix, iy, face_num;
00637   (<a class="code" href="classHealpix__Base.html#p7">scheme_</a>==<a class="code" href="healpix__base_8h.html#a3a1">RING</a>) ?
00638     ring2xyf(pix,ix,iy,face_num) : nest2xyf(pix,ix,iy,face_num);
00639 
00640   <span class="keyword">const</span> <span class="keywordtype">int</span> nsm1 = nside_-1;
00641   <span class="keywordflow">if</span> ((ix&gt;0)&amp;&amp;(ix&lt;nsm1)&amp;&amp;(iy&gt;0)&amp;&amp;(iy&lt;nsm1))
00642     {
00643     <span class="keywordflow">if</span> (<a class="code" href="classHealpix__Base.html#p7">scheme_</a>==<a class="code" href="healpix__base_8h.html#a3a1">RING</a>)
00644       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;8; ++m)
00645         result[m] = xyf2ring(ix+xoffset[m],iy+yoffset[m],face_num);
00646     <span class="keywordflow">else</span>
00647       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;8; ++m)
00648         result[m] = xyf2nest(ix+xoffset[m],iy+yoffset[m],face_num);
00649     }
00650   <span class="keywordflow">else</span>
00651     {
00652     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;8; ++i)
00653       {
00654       <span class="keywordtype">int</span> x=ix+xoffset[i];
00655       <span class="keywordtype">int</span> y=iy+yoffset[i];
00656       <span class="keywordtype">int</span> nbnum=4;
00657       <span class="keywordflow">if</span> (x&lt;0)
00658         { x+=nside_; nbnum-=1; }
00659       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (x&gt;=nside_)
00660         { x-=nside_; nbnum+=1; }
00661       <span class="keywordflow">if</span> (y&lt;0)
00662         { y+=nside_; nbnum-=3; }
00663       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (y&gt;=nside_)
00664         { y-=nside_; nbnum+=3; }
00665 
00666       <span class="keywordtype">int</span> f = facearray[nbnum][face_num];
00667       <span class="keywordflow">if</span> (f&gt;=0)
00668         {
00669         <span class="keywordflow">if</span> (swaparray[nbnum][face_num]&amp;1) x=nside_-x-1;
00670         <span class="keywordflow">if</span> (swaparray[nbnum][face_num]&amp;2) y=nside_-y-1;
00671         <span class="keywordflow">if</span> (swaparray[nbnum][face_num]&amp;4) std::swap(x,y);
00672         result[i] = (<a class="code" href="classHealpix__Base.html#p7">scheme_</a>==<a class="code" href="healpix__base_8h.html#a3a1">RING</a>) ? xyf2ring(x,y,f) : xyf2nest(x,y,f);
00673         }
00674       <span class="keywordflow">else</span>
00675         result[i] = -1;
00676       }
00677     }
00678   }
00679 
<a name="l00680"></a><a class="code" href="classHealpix__Base.html#a20">00680</a> <span class="keywordtype">void</span> <a class="code" href="classHealpix__Base.html#a20">Healpix_Base::get_ring_info2</a> (<span class="keywordtype">int</span> ring, <span class="keywordtype">int</span> &amp;startpix, <span class="keywordtype">int</span> &amp;ringpix,
00681   <span class="keywordtype">double</span> &amp;theta, <span class="keywordtype">bool</span> &amp;shifted)<span class="keyword"> const</span>
00682 <span class="keyword">  </span>{
00683   <span class="keywordtype">int</span> northring = (ring&gt;2*nside_) ? 4*nside_-ring : ring;
00684   <span class="keywordflow">if</span> (northring &lt; nside_)
00685     {
00686     <span class="keywordtype">double</span> tmp = northring*northring*fact2_;
00687     <span class="keywordtype">double</span> costheta = 1 - tmp;
00688     <span class="keywordtype">double</span> sintheta = sqrt(tmp*(2-tmp));
00689     theta = atan2(sintheta,costheta);
00690     ringpix = 4*northring;
00691     shifted = <span class="keyword">true</span>;
00692     startpix = 2*northring*(northring-1);
00693     }
00694   <span class="keywordflow">else</span>
00695     {
00696     theta = acos((2*nside_-northring)*fact1_);
00697     ringpix = 4*nside_;
00698     shifted = ((northring-nside_) &amp; 1) == 0;
00699     startpix = ncap_ + (northring-nside_)*ringpix;
00700     }
00701   <span class="keywordflow">if</span> (northring != ring) <span class="comment">// southern hemisphere</span>
00702     {
00703     theta = pi-theta;
00704     startpix = npix_ - startpix - ringpix;
00705     }
00706   }
00707 
<a name="l00708"></a><a class="code" href="classHealpix__Base.html#a22">00708</a> <span class="keywordtype">void</span> <a class="code" href="classHealpix__Base.html#a22">Healpix_Base::get_interpol</a> (<span class="keyword">const</span> <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classpointing.html">pointing</a> &amp;ptg, <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classfix__arr.html">fix_arr&lt;int,4&gt;</a> &amp;pix,
00709   <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classfix__arr.html">fix_arr&lt;double,4&gt;</a> &amp;wgt)<span class="keyword"> const</span>
00710 <span class="keyword">  </span>{
00711   <span class="keywordtype">double</span> z = cos (ptg.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classpointing.html#o0">theta</a>);
00712   <span class="keywordtype">int</span> ir1 = ring_above(z);
00713   <span class="keywordtype">int</span> ir2 = ir1+1;
00714   <span class="keywordtype">double</span> theta1, theta2, w1, tmp, dphi;
00715   <span class="keywordtype">int</span> sp,nr;
00716   <span class="keywordtype">bool</span> shift;
00717   <span class="keywordtype">int</span> i1,i2;
00718   <span class="keywordflow">if</span> (ir1&gt;0)
00719     {
00720     <a class="code" href="classHealpix__Base.html#a20">get_ring_info2</a> (ir1, sp, nr, theta1, shift);
00721     dphi = twopi/nr;
00722     tmp = (ptg.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classpointing.html#o1">phi</a>/dphi - .5*shift);
00723     i1 = (tmp&lt;0) ? int(tmp)-1 : int(tmp);
00724     w1 = (ptg.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classpointing.html#o1">phi</a>-(i1+.5*shift)*dphi)/dphi;
00725     i2 = i1+1;
00726     <span class="keywordflow">if</span> (i1&lt;0) i1 +=nr;
00727     <span class="keywordflow">if</span> (i2&gt;=nr) i2 -=nr;
00728     pix[0] = sp+i1; pix[1] = sp+i2;
00729     wgt[0] = 1-w1; wgt[1] = w1;
00730     }
00731   <span class="keywordflow">if</span> (ir2&lt;(4*nside_))
00732     {
00733     <a class="code" href="classHealpix__Base.html#a20">get_ring_info2</a> (ir2, sp, nr, theta2, shift);
00734     dphi = twopi/nr;
00735     tmp = (ptg.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classpointing.html#o1">phi</a>/dphi - .5*shift);
00736     i1 = (tmp&lt;0) ? int(tmp)-1 : int(tmp);
00737     w1 = (ptg.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classpointing.html#o1">phi</a>-(i1+.5*shift)*dphi)/dphi;
00738     i2 = i1+1;
00739     <span class="keywordflow">if</span> (i1&lt;0) i1 +=nr;
00740     <span class="keywordflow">if</span> (i2&gt;=nr) i2 -=nr;
00741     pix[2] = sp+i1; pix[3] = sp+i2;
00742     wgt[2] = 1-w1; wgt[3] = w1;
00743     }
00744 
00745   <span class="keywordflow">if</span> (ir1==0)
00746     {
00747     <span class="keywordtype">double</span> wtheta = ptg.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classpointing.html#o0">theta</a>/theta2;
00748     wgt[2] *= wtheta; wgt[3] *= wtheta;
00749     <span class="keywordtype">double</span> fac = (1-wtheta)*0.25;
00750     wgt[0] = fac; wgt[1] = fac; wgt[2] += fac; wgt[3] +=fac;
00751     pix[0] = (pix[2]+2)%4;
00752     pix[1] = (pix[3]+2)%4;
00753     }
00754   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ir2==4*nside_)
00755     {
00756     <span class="keywordtype">double</span> wtheta = (ptg.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classpointing.html#o0">theta</a>-theta1)/(pi-theta1);
00757     wgt[0] *= (1-wtheta); wgt[1] *= (1-wtheta);
00758     <span class="keywordtype">double</span> fac = wtheta*0.25;
00759     wgt[0] += fac; wgt[1] += fac; wgt[2] = fac; wgt[3] =fac;
00760     pix[2] = ((pix[0]+2)&amp;3)+npix_-4;
00761     pix[3] = ((pix[1]+2)&amp;3)+npix_-4;
00762     }
00763   <span class="keywordflow">else</span>
00764     {
00765     <span class="keywordtype">double</span> wtheta = (ptg.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classpointing.html#o0">theta</a>-theta1)/(theta2-theta1);
00766     wgt[0] *= (1-wtheta); wgt[1] *= (1-wtheta);
00767     wgt[2] *= wtheta; wgt[3] *= wtheta;
00768     }
00769 
00770   <span class="keywordflow">if</span> (<a class="code" href="classHealpix__Base.html#p7">scheme_</a>==<a class="code" href="healpix__base_8h.html#a3a2">NEST</a>)
00771     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;pix.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classfix__arr.html#a0">size</a>(); ++m)
00772       pix[m] = <a class="code" href="classHealpix__Base.html#a8">ring2nest</a>(pix[m]);
00773   }
00774 
<a name="l00775"></a><a class="code" href="classHealpix__Base.html#a29">00775</a> <span class="keywordtype">double</span> <a class="code" href="classHealpix__Base.html#a29">Healpix_Base::max_pixrad</a>()<span class="keyword"> const</span>
00776 <span class="keyword">  </span>{
00777   <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classvec3.html">vec3</a> va,vb;
00778   va.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classvec3.html#a2">set_z_phi</a> (2./3., pi/(4*nside_));
00779   <span class="keywordtype">double</span> t1 = 1.-1./nside_;
00780   t1*=t1;
00781   vb.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classvec3.html#a2">set_z_phi</a> (1-t1/3, 0);
00782   <span class="keywordflow">return</span> <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/geom__utils_8h.html#a1">v_angle</a>(va,vb);
00783   }
</pre></div><hr><address style="align: right;"><small>
Generated on Thu Nov 13 18:48:51 2008 for Healpix C++
</a> </small></address>
</body>
</html>
