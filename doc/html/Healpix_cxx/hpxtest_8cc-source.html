<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>hpxtest.cc Source File</title>
<link href="sheet.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>hpxtest.cc</h1><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> *  This file is part of Healpix_cxx.</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> *  Healpix_cxx is free software; you can redistribute it and/or modify</span>
00005 <span class="comment"> *  it under the terms of the GNU General Public License as published by</span>
00006 <span class="comment"> *  the Free Software Foundation; either version 2 of the License, or</span>
00007 <span class="comment"> *  (at your option) any later version.</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> *  Healpix_cxx is distributed in the hope that it will be useful,</span>
00010 <span class="comment"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00012 <span class="comment"> *  GNU General Public License for more details.</span>
00013 <span class="comment"> *</span>
00014 <span class="comment"> *  You should have received a copy of the GNU General Public License</span>
00015 <span class="comment"> *  along with Healpix_cxx; if not, write to the Free Software</span>
00016 <span class="comment"> *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
00017 <span class="comment"> *</span>
00018 <span class="comment"> *  For more information about HEALPix, see http://healpix.jpl.nasa.gov</span>
00019 <span class="comment"> */</span>
00020 
00021 <span class="comment">/*</span>
00022 <span class="comment"> *  Healpix_cxx is being developed at the Max-Planck-Institut fuer Astrophysik</span>
00023 <span class="comment"> *  and financially supported by the Deutsches Zentrum fuer Luft- und Raumfahrt</span>
00024 <span class="comment"> *  (DLR).</span>
00025 <span class="comment"> */</span>
00026 
00027 <span class="comment">/*</span>
00028 <span class="comment"> *  Copyright (C) 2004, 2005, 2006 Max-Planck-Society</span>
00029 <span class="comment"> *  Author: Martin Reinecke</span>
00030 <span class="comment"> */</span>
00031 
00032 <span class="comment">/*</span>
00033 <span class="comment"></span>
00034 <span class="comment">Candidates for testing the validity of the Healpix routines:</span>
00035 <span class="comment"></span>
00036 <span class="comment">- done: ang2pix(pix2ang(i)) = i for all Healpix_Bases</span>
00037 <span class="comment">- done: pix2ang(ang2pix(ptg)) dot ptg &gt; 1-delta for all Healpix_Bases</span>
00038 <span class="comment">- done: ring2nest(nest2ring(i)) = i for all hierarchical Healpix_Bases</span>
00039 <span class="comment">- done: downgrade(upgrade(map)) = map for all maps</span>
00040 <span class="comment">- done: map and downgraded map should have same average</span>
00041 <span class="comment">- done: alm2map(map2alm(map)) approx map (same for pol)</span>
00042 <span class="comment">- partly done: neighbor tests</span>
00043 <span class="comment">- powspec -&gt; alm -&gt; powspec (should produce similar powspecs, also for pol)</span>
00044 <span class="comment">- done: two swap_schemes() should produce original map</span>
00045 <span class="comment">- done: query_disc tests (dot products etc.)</span>
00046 <span class="comment">- a_lms: test Set(), Scale(), Add(), alm(l,m) = alm.mstart(m)[l], etc.</span>
00047 <span class="comment"></span>
00048 <span class="comment">*/</span>
00049 
00050 <span class="preprocessor">#include &lt;iostream&gt;</span>
00051 <span class="preprocessor">#include "<a class="code" href="healpix__base_8h.html">healpix_base.h</a>"</span>
00052 <span class="preprocessor">#include "<a class="code" href="healpix__base2_8h.html">healpix_base2.h</a>"</span>
00053 <span class="preprocessor">#include "<a class="code" href="healpix__map_8h.html">healpix_map.h</a>"</span>
00054 <span class="preprocessor">#include "<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/arr_8h.html">arr.h</a>"</span>
00055 <span class="preprocessor">#include "<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/planck__rng_8h.html">planck_rng.h</a>"</span>
00056 <span class="preprocessor">#include "<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/lsconstants_8h.html">lsconstants.h</a>"</span>
00057 <span class="preprocessor">#include "<a class="code" href="alm_8h.html">alm.h</a>"</span>
00058 <span class="preprocessor">#include "<a class="code" href="alm__healpix__tools_8h.html">alm_healpix_tools.h</a>"</span>
00059 <span class="preprocessor">#include "<a class="code" href="alm__powspec__tools_8h.html">alm_powspec_tools.h</a>"</span>
00060 <span class="preprocessor">#include "<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/geom__utils_8h.html">geom_utils.h</a>"</span>
00061 
00062 <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00063 
00064 <span class="keyword">const</span> <span class="keywordtype">int</span> nsamples = 1000000;
00065 
00066 <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html">planck_rng</a> rng;
00067 
00068 <span class="keywordtype">void</span> random_dir (<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classpointing.html">pointing</a> &amp;ptg)
00069   {
00070   ptg.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classpointing.html#o0">theta</a> = acos(rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a3">rand_uni</a>()*2-1);
00071   ptg.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classpointing.html#o1">phi</a> = rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a3">rand_uni</a>()*twopi;
00072   }
00073 
00074 <span class="keywordtype">void</span> check_ringnestring()
00075   {
00076   cout &lt;&lt; <span class="stringliteral">"testing ring2nest(nest2ring(m))==m"</span> &lt;&lt; endl;
00077   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> order=0; order&lt;=13; ++order)
00078     {
00079     cout &lt;&lt; <span class="stringliteral">"order = "</span> &lt;&lt; order &lt;&lt; endl;
00080     <a class="code" href="classHealpix__Base.html">Healpix_Base</a> base (order,RING);
00081     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;nsamples; ++m)
00082       {
00083       <span class="keywordtype">int</span> pix = int(rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a3">rand_uni</a>()*base.<a class="code" href="classHealpix__Base.html#a25">Npix</a>());
00084       <span class="keywordflow">if</span> (base.<a class="code" href="classHealpix__Base.html#a8">ring2nest</a>(base.<a class="code" href="classHealpix__Base.html#a7">nest2ring</a>(pix))!=pix)
00085         cout &lt;&lt; <span class="stringliteral">"  PROBLEM: order = "</span> &lt;&lt; order &lt;&lt; <span class="stringliteral">", pixel = "</span> &lt;&lt; pix &lt;&lt; endl;
00086       }
00087     }
00088   }
00089 <span class="keywordtype">void</span> check_ringnestring2()
00090   {
00091   cout &lt;&lt; <span class="stringliteral">"testing ring2nest(nest2ring(m))==m"</span> &lt;&lt; endl;
00092   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> order=0; order&lt;=29; ++order)
00093     {
00094     cout &lt;&lt; <span class="stringliteral">"order = "</span> &lt;&lt; order &lt;&lt; endl;
00095     <a class="code" href="classHealpix__Base2.html">Healpix_Base2</a> base (order,RING);
00096     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;nsamples; ++m)
00097       {
00098       int64 pix = int64(rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a3">rand_uni</a>()*base.<a class="code" href="classHealpix__Base2.html#a25">Npix</a>());
00099       <span class="keywordflow">if</span> (base.<a class="code" href="classHealpix__Base2.html#a8">ring2nest</a>(base.<a class="code" href="classHealpix__Base2.html#a7">nest2ring</a>(pix))!=pix)
00100         cout &lt;&lt; <span class="stringliteral">"  PROBLEM: order = "</span> &lt;&lt; order &lt;&lt; <span class="stringliteral">", pixel = "</span> &lt;&lt; pix &lt;&lt; endl;
00101       }
00102     }
00103   }
00104 
00105 <span class="keywordtype">void</span> check_nestpeanonest()
00106   {
00107   cout &lt;&lt; <span class="stringliteral">"testing peano2nest(nest2peano(m))==m"</span> &lt;&lt; endl;
00108   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> order=0; order&lt;=13; ++order)
00109     {
00110     cout &lt;&lt; <span class="stringliteral">"order = "</span> &lt;&lt; order &lt;&lt; endl;
00111     <a class="code" href="classHealpix__Base.html">Healpix_Base</a> base (order,NEST);
00112     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;nsamples; ++m)
00113       {
00114       <span class="keywordtype">int</span> pix = int(rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a3">rand_uni</a>()*base.<a class="code" href="classHealpix__Base.html#a25">Npix</a>());
00115       <span class="keywordflow">if</span> (base.<a class="code" href="classHealpix__Base.html#a10">peano2nest</a>(base.<a class="code" href="classHealpix__Base.html#a9">nest2peano</a>(pix))!=pix)
00116         cout &lt;&lt; <span class="stringliteral">"  PROBLEM: order = "</span> &lt;&lt; order &lt;&lt; <span class="stringliteral">", pixel = "</span> &lt;&lt; pix &lt;&lt; endl;
00117       }
00118     }
00119   }
00120 <span class="keywordtype">void</span> check_nestpeanonest2()
00121   {
00122   cout &lt;&lt; <span class="stringliteral">"testing peano2nest(nest2peano(m))==m"</span> &lt;&lt; endl;
00123   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> order=0; order&lt;=29; ++order)
00124     {
00125     cout &lt;&lt; <span class="stringliteral">"order = "</span> &lt;&lt; order &lt;&lt; endl;
00126     <a class="code" href="classHealpix__Base2.html">Healpix_Base2</a> base (order,NEST);
00127     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;nsamples; ++m)
00128       {
00129       int64 pix = int64(rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a3">rand_uni</a>()*base.<a class="code" href="classHealpix__Base2.html#a25">Npix</a>());
00130       <span class="keywordflow">if</span> (base.<a class="code" href="classHealpix__Base2.html#a10">peano2nest</a>(base.<a class="code" href="classHealpix__Base2.html#a9">nest2peano</a>(pix))!=pix)
00131         cout &lt;&lt; <span class="stringliteral">"  PROBLEM: order = "</span> &lt;&lt; order &lt;&lt; <span class="stringliteral">", pixel = "</span> &lt;&lt; pix &lt;&lt; endl;
00132       }
00133     }
00134   }
00135 
00136 <span class="keywordtype">void</span> check_pixangpix()
00137   {
00138   cout &lt;&lt; <span class="stringliteral">"testing ang2pix(pix2ang(m))==m"</span> &lt;&lt; endl;
00139   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> order=0; order&lt;=13; ++order)
00140     {
00141     cout &lt;&lt; <span class="stringliteral">"order = "</span> &lt;&lt; order &lt;&lt; endl;
00142     <a class="code" href="classHealpix__Base.html">Healpix_Base</a> base1 (order,RING);
00143     <a class="code" href="classHealpix__Base.html">Healpix_Base</a> base2 (order,NEST);
00144     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;nsamples; ++m)
00145       {
00146       <span class="keywordtype">int</span> pix = int(rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a3">rand_uni</a>()*base1.<a class="code" href="classHealpix__Base.html#a25">Npix</a>());
00147       <span class="keywordflow">if</span> (base1.<a class="code" href="classHealpix__Base.html#a12">ang2pix</a>(base1.<a class="code" href="classHealpix__Base.html#a15">pix2ang</a>(pix))!=pix)
00148         cout &lt;&lt; <span class="stringliteral">"  PROBLEM: order = "</span> &lt;&lt; order &lt;&lt; <span class="stringliteral">", pixel = "</span> &lt;&lt; pix &lt;&lt; endl;
00149       <span class="keywordflow">if</span> (base2.<a class="code" href="classHealpix__Base.html#a12">ang2pix</a>(base2.<a class="code" href="classHealpix__Base.html#a15">pix2ang</a>(pix))!=pix)
00150         cout &lt;&lt; <span class="stringliteral">"  PROBLEM: order = "</span> &lt;&lt; order &lt;&lt; <span class="stringliteral">", pixel = "</span> &lt;&lt; pix &lt;&lt; endl;
00151       }
00152     }
00153   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> nside=3; nside&lt;(1&lt;&lt;13); nside+=nside/2+1)
00154     {
00155     cout &lt;&lt; <span class="stringliteral">"nside = "</span> &lt;&lt; nside &lt;&lt; endl;
00156     <a class="code" href="classHealpix__Base.html">Healpix_Base</a> base (nside,RING,SET_NSIDE);
00157     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;nsamples; ++m)
00158       {
00159       <span class="keywordtype">int</span> pix = int(rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a3">rand_uni</a>()*base.<a class="code" href="classHealpix__Base.html#a25">Npix</a>());
00160       <span class="keywordflow">if</span> (base.<a class="code" href="classHealpix__Base.html#a12">ang2pix</a>(base.<a class="code" href="classHealpix__Base.html#a15">pix2ang</a>(pix))!=pix)
00161         cout &lt;&lt; <span class="stringliteral">"  PROBLEM: nside = "</span> &lt;&lt; nside &lt;&lt; <span class="stringliteral">", pixel = "</span> &lt;&lt; pix &lt;&lt; endl;
00162       }
00163     }
00164   }
00165 <span class="keywordtype">void</span> check_pixangpix2()
00166   {
00167   cout &lt;&lt; <span class="stringliteral">"testing ang2pix(pix2ang(m))==m"</span> &lt;&lt; endl;
00168   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> order=0; order&lt;=29; ++order)
00169     {
00170     cout &lt;&lt; <span class="stringliteral">"order = "</span> &lt;&lt; order &lt;&lt; endl;
00171     <a class="code" href="classHealpix__Base2.html">Healpix_Base2</a> base1 (order,RING);
00172     <a class="code" href="classHealpix__Base2.html">Healpix_Base2</a> base2 (order,NEST);
00173     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;nsamples; ++m)
00174       {
00175       int64 pix = int64(rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a3">rand_uni</a>()*base1.<a class="code" href="classHealpix__Base2.html#a25">Npix</a>());
00176       <span class="keywordflow">if</span> (base1.<a class="code" href="classHealpix__Base2.html#a12">ang2pix</a>(base1.<a class="code" href="classHealpix__Base2.html#a15">pix2ang</a>(pix))!=pix)
00177         cout &lt;&lt; <span class="stringliteral">"  PROBLEM: order = "</span> &lt;&lt; order &lt;&lt; <span class="stringliteral">", pixel = "</span> &lt;&lt; pix &lt;&lt; endl;
00178       <span class="keywordflow">if</span> (base2.<a class="code" href="classHealpix__Base2.html#a12">ang2pix</a>(base2.<a class="code" href="classHealpix__Base2.html#a15">pix2ang</a>(pix))!=pix)
00179         cout &lt;&lt; <span class="stringliteral">"  PROBLEM: order = "</span> &lt;&lt; order &lt;&lt; <span class="stringliteral">", pixel = "</span> &lt;&lt; pix &lt;&lt; endl;
00180       }
00181     }
00182   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> nside=3; nside&lt;(1&lt;&lt;29); nside+=nside/2+1)
00183     {
00184     cout &lt;&lt; <span class="stringliteral">"nside = "</span> &lt;&lt; nside &lt;&lt; endl;
00185     <a class="code" href="classHealpix__Base2.html">Healpix_Base2</a> base (nside,RING,SET_NSIDE);
00186     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;nsamples; ++m)
00187       {
00188       int64 pix = int64(rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a3">rand_uni</a>()*base.<a class="code" href="classHealpix__Base2.html#a25">Npix</a>());
00189       <span class="keywordflow">if</span> (base.<a class="code" href="classHealpix__Base2.html#a12">ang2pix</a>(base.<a class="code" href="classHealpix__Base2.html#a15">pix2ang</a>(pix))!=pix)
00190         cout &lt;&lt; <span class="stringliteral">"  PROBLEM: nside = "</span> &lt;&lt; nside &lt;&lt; <span class="stringliteral">", pixel = "</span> &lt;&lt; pix &lt;&lt; endl;
00191       }
00192     }
00193   }
00194 
00195 <span class="keywordtype">void</span> check_pixvecpix()
00196   {
00197   cout &lt;&lt; <span class="stringliteral">"testing vec2pix(pix2vec(m))==m"</span> &lt;&lt; endl;
00198   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> order=0; order&lt;=13; ++order)
00199     {
00200     cout &lt;&lt; <span class="stringliteral">"order = "</span> &lt;&lt; order &lt;&lt; endl;
00201     <a class="code" href="classHealpix__Base.html">Healpix_Base</a> base1 (order,RING);
00202     <a class="code" href="classHealpix__Base.html">Healpix_Base</a> base2 (order,NEST);
00203     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;nsamples; ++m)
00204       {
00205       <span class="keywordtype">int</span> pix = int(rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a3">rand_uni</a>()*base1.<a class="code" href="classHealpix__Base.html#a25">Npix</a>());
00206       <span class="keywordflow">if</span> (base1.<a class="code" href="classHealpix__Base.html#a13">vec2pix</a>(base1.<a class="code" href="classHealpix__Base.html#a16">pix2vec</a>(pix))!=pix)
00207         cout &lt;&lt; <span class="stringliteral">"  PROBLEM: order = "</span> &lt;&lt; order &lt;&lt; <span class="stringliteral">", pixel = "</span> &lt;&lt; pix &lt;&lt; endl;
00208       <span class="keywordflow">if</span> (base2.<a class="code" href="classHealpix__Base.html#a13">vec2pix</a>(base2.<a class="code" href="classHealpix__Base.html#a16">pix2vec</a>(pix))!=pix)
00209         cout &lt;&lt; <span class="stringliteral">"  PROBLEM: order = "</span> &lt;&lt; order &lt;&lt; <span class="stringliteral">", pixel = "</span> &lt;&lt; pix &lt;&lt; endl;
00210       }
00211     }
00212   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> nside=3; nside&lt;(1&lt;&lt;13); nside+=nside/2+1)
00213     {
00214     cout &lt;&lt; <span class="stringliteral">"nside = "</span> &lt;&lt; nside &lt;&lt; endl;
00215     <a class="code" href="classHealpix__Base.html">Healpix_Base</a> base (nside,RING,SET_NSIDE);
00216     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;nsamples; ++m)
00217       {
00218       <span class="keywordtype">int</span> pix = int(rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a3">rand_uni</a>()*base.<a class="code" href="classHealpix__Base.html#a25">Npix</a>());
00219       <span class="keywordflow">if</span> (base.<a class="code" href="classHealpix__Base.html#a13">vec2pix</a>(base.<a class="code" href="classHealpix__Base.html#a16">pix2vec</a>(pix))!=pix)
00220         cout &lt;&lt; <span class="stringliteral">"  PROBLEM: nside = "</span> &lt;&lt; nside &lt;&lt; <span class="stringliteral">", pixel = "</span> &lt;&lt; pix &lt;&lt; endl;
00221       }
00222     }
00223   }
00224 <span class="keywordtype">void</span> check_pixvecpix2()
00225   {
00226   cout &lt;&lt; <span class="stringliteral">"testing vec2pix(pix2vec(m))==m"</span> &lt;&lt; endl;
00227   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> order=0; order&lt;=29; ++order)
00228     {
00229     cout &lt;&lt; <span class="stringliteral">"order = "</span> &lt;&lt; order &lt;&lt; endl;
00230     <a class="code" href="classHealpix__Base2.html">Healpix_Base2</a> base1 (order,RING);
00231     <a class="code" href="classHealpix__Base2.html">Healpix_Base2</a> base2 (order,NEST);
00232     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;nsamples; ++m)
00233       {
00234       int64 pix = int64(rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a3">rand_uni</a>()*base1.<a class="code" href="classHealpix__Base2.html#a25">Npix</a>());
00235       <span class="keywordflow">if</span> (base1.<a class="code" href="classHealpix__Base2.html#a13">vec2pix</a>(base1.<a class="code" href="classHealpix__Base2.html#a16">pix2vec</a>(pix))!=pix)
00236         cout &lt;&lt; <span class="stringliteral">"  PROBLEM: order = "</span> &lt;&lt; order &lt;&lt; <span class="stringliteral">", pixel = "</span> &lt;&lt; pix &lt;&lt; endl;
00237       <span class="keywordflow">if</span> (base2.<a class="code" href="classHealpix__Base2.html#a13">vec2pix</a>(base2.<a class="code" href="classHealpix__Base2.html#a16">pix2vec</a>(pix))!=pix)
00238         cout &lt;&lt; <span class="stringliteral">"  PROBLEM: order = "</span> &lt;&lt; order &lt;&lt; <span class="stringliteral">", pixel = "</span> &lt;&lt; pix &lt;&lt; endl;
00239       }
00240     }
00241   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> nside=3; nside&lt;(1&lt;&lt;29); nside+=nside/2+1)
00242     {
00243     cout &lt;&lt; <span class="stringliteral">"nside = "</span> &lt;&lt; nside &lt;&lt; endl;
00244     <a class="code" href="classHealpix__Base2.html">Healpix_Base2</a> base (nside,RING,SET_NSIDE);
00245     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;nsamples; ++m)
00246       {
00247       int64 pix = int64(rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a3">rand_uni</a>()*base.<a class="code" href="classHealpix__Base2.html#a25">Npix</a>());
00248       <span class="keywordflow">if</span> (base.<a class="code" href="classHealpix__Base2.html#a13">vec2pix</a>(base.<a class="code" href="classHealpix__Base2.html#a16">pix2vec</a>(pix))!=pix)
00249         cout &lt;&lt; <span class="stringliteral">"  PROBLEM: nside = "</span> &lt;&lt; nside &lt;&lt; <span class="stringliteral">", pixel = "</span> &lt;&lt; pix &lt;&lt; endl;
00250       }
00251     }
00252   }
00253 
00254 <span class="keywordtype">void</span> check_angpixang()
00255   {
00256   cout &lt;&lt; <span class="stringliteral">"testing pix2ang(ang2pix(ptg)) approx ptg"</span> &lt;&lt; endl;
00257   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> order=0; order&lt;=13; ++order)
00258     {
00259     cout &lt;&lt; <span class="stringliteral">"order = "</span> &lt;&lt; order &lt;&lt; endl;
00260     <a class="code" href="classHealpix__Base.html">Healpix_Base</a> base1 (order,NEST);
00261     <a class="code" href="classHealpix__Base.html">Healpix_Base</a> base2 (order,RING);
00262     <span class="keywordtype">double</span> maxang = base1.<a class="code" href="classHealpix__Base.html#a29">max_pixrad</a>();
00263     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;nsamples; ++m)
00264       {
00265       <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classpointing.html">pointing</a> ptg;
00266       random_dir (ptg);
00267       <span class="keywordflow">if</span> (<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/geom__utils_8h.html#a1">v_angle</a>(base1.<a class="code" href="classHealpix__Base.html#a15">pix2ang</a>(base1.<a class="code" href="classHealpix__Base.html#a12">ang2pix</a>(ptg)),ptg)&gt;maxang)
00268         cout &lt;&lt; <span class="stringliteral">"  PROBLEM: order = "</span> &lt;&lt; order &lt;&lt; <span class="stringliteral">", ptg = "</span> &lt;&lt; ptg &lt;&lt; endl;
00269       <span class="keywordflow">if</span> (<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/geom__utils_8h.html#a1">v_angle</a>(base2.<a class="code" href="classHealpix__Base.html#a15">pix2ang</a>(base2.<a class="code" href="classHealpix__Base.html#a12">ang2pix</a>(ptg)),ptg)&gt;maxang)
00270         cout &lt;&lt; <span class="stringliteral">"  PROBLEM: order = "</span> &lt;&lt; order &lt;&lt; <span class="stringliteral">", ptg = "</span> &lt;&lt; ptg &lt;&lt; endl;
00271       }
00272     }
00273   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> nside=3; nside&lt;(1&lt;&lt;13); nside+=nside/2+1)
00274     {
00275     cout &lt;&lt; <span class="stringliteral">"nside = "</span> &lt;&lt; nside &lt;&lt; endl;
00276     <a class="code" href="classHealpix__Base.html">Healpix_Base</a> base (nside,RING,SET_NSIDE);
00277     <span class="keywordtype">double</span> maxang = base.<a class="code" href="classHealpix__Base.html#a29">max_pixrad</a>();
00278     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;nsamples; ++m)
00279       {
00280       <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classpointing.html">pointing</a> ptg;
00281       random_dir (ptg);
00282       <span class="keywordflow">if</span> (<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/geom__utils_8h.html#a1">v_angle</a>(base.<a class="code" href="classHealpix__Base.html#a15">pix2ang</a>(base.<a class="code" href="classHealpix__Base.html#a12">ang2pix</a>(ptg)),ptg)&gt;maxang)
00283         cout &lt;&lt; <span class="stringliteral">"  PROBLEM: nside = "</span> &lt;&lt; nside &lt;&lt; <span class="stringliteral">", ptg = "</span> &lt;&lt; ptg &lt;&lt; endl;
00284       }
00285     }
00286   }
00287 <span class="keywordtype">void</span> check_angpixang2()
00288   {
00289   cout &lt;&lt; <span class="stringliteral">"testing pix2ang(ang2pix(ptg)) approx ptg"</span> &lt;&lt; endl;
00290   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> order=0; order&lt;=29; ++order)
00291     {
00292     cout &lt;&lt; <span class="stringliteral">"order = "</span> &lt;&lt; order &lt;&lt; endl;
00293     <a class="code" href="classHealpix__Base2.html">Healpix_Base2</a> base1 (order,NEST);
00294     <a class="code" href="classHealpix__Base2.html">Healpix_Base2</a> base2 (order,RING);
00295     <span class="keywordtype">double</span> maxang = base1.<a class="code" href="classHealpix__Base2.html#a29">max_pixrad</a>();
00296     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;nsamples; ++m)
00297       {
00298       <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classpointing.html">pointing</a> ptg;
00299       random_dir (ptg);
00300       <span class="keywordflow">if</span> (<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/geom__utils_8h.html#a1">v_angle</a>(base1.<a class="code" href="classHealpix__Base2.html#a15">pix2ang</a>(base1.<a class="code" href="classHealpix__Base2.html#a12">ang2pix</a>(ptg)),ptg)&gt;maxang)
00301         cout &lt;&lt; <span class="stringliteral">"  PROBLEM: order = "</span> &lt;&lt; order &lt;&lt; <span class="stringliteral">", ptg = "</span> &lt;&lt; ptg &lt;&lt; endl;
00302       <span class="keywordflow">if</span> (<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/geom__utils_8h.html#a1">v_angle</a>(base2.<a class="code" href="classHealpix__Base2.html#a15">pix2ang</a>(base2.<a class="code" href="classHealpix__Base2.html#a12">ang2pix</a>(ptg)),ptg)&gt;maxang)
00303         cout &lt;&lt; <span class="stringliteral">"  PROBLEM: order = "</span> &lt;&lt; order &lt;&lt; <span class="stringliteral">", ptg = "</span> &lt;&lt; ptg &lt;&lt; endl;
00304       }
00305     }
00306   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> nside=3; nside&lt;(1&lt;&lt;29); nside+=nside/2+1)
00307     {
00308     cout &lt;&lt; <span class="stringliteral">"nside = "</span> &lt;&lt; nside &lt;&lt; endl;
00309     <a class="code" href="classHealpix__Base2.html">Healpix_Base2</a> base (nside,RING,SET_NSIDE);
00310     <span class="keywordtype">double</span> maxang = base.<a class="code" href="classHealpix__Base2.html#a29">max_pixrad</a>();
00311     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;nsamples; ++m)
00312       {
00313       <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classpointing.html">pointing</a> ptg;
00314       random_dir (ptg);
00315       <span class="keywordflow">if</span> (<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/geom__utils_8h.html#a1">v_angle</a>(base.<a class="code" href="classHealpix__Base2.html#a15">pix2ang</a>(base.<a class="code" href="classHealpix__Base2.html#a12">ang2pix</a>(ptg)),ptg)&gt;maxang)
00316         cout &lt;&lt; <span class="stringliteral">"  PROBLEM: nside = "</span> &lt;&lt; nside &lt;&lt; <span class="stringliteral">", ptg = "</span> &lt;&lt; ptg &lt;&lt; endl;
00317       }
00318     }
00319   }
00320 
00321 <span class="keywordtype">void</span> check_neighbors()
00322   {
00323   cout &lt;&lt; <span class="stringliteral">"testing neighbor function"</span> &lt;&lt; endl;
00324   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> order=0; order&lt;=13; ++order)
00325     {
00326     cout &lt;&lt; <span class="stringliteral">"order = "</span> &lt;&lt; order &lt;&lt; endl;
00327     <a class="code" href="classHealpix__Base.html">Healpix_Base</a> base (order,NEST), base2(order,RING);
00328     <span class="keywordtype">double</span> maxang = 2.01*base.<a class="code" href="classHealpix__Base.html#a29">max_pixrad</a>();
00329     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;nsamples/10; ++m)
00330       {
00331       <span class="keywordtype">int</span> pix = int(rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a3">rand_uni</a>()*base.<a class="code" href="classHealpix__Base.html#a25">Npix</a>());
00332       <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classfix__arr.html">fix_arr&lt;int,8&gt;</a> nb;
00333       <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classvec3.html">vec3</a> pixpt = base.<a class="code" href="classHealpix__Base.html#a15">pix2ang</a>(pix);
00334       base.<a class="code" href="classHealpix__Base.html#a21">neighbors</a>(pix,nb);
00335       sort(&amp;nb[0],&amp;nb[0]+8);
00336       <span class="keywordtype">int</span> check=0;
00337       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n=0; n&lt;8; ++n)
00338         {
00339         <span class="keywordflow">if</span> (nb[n]&lt;0)
00340           {
00341           ++check;
00342           }
00343         <span class="keywordflow">else</span>
00344           {
00345           <span class="keywordflow">if</span> (<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/geom__utils_8h.html#a1">v_angle</a>(base.<a class="code" href="classHealpix__Base.html#a15">pix2ang</a>(nb[n]),pixpt)&gt;maxang)
00346             cout &lt;&lt; <span class="stringliteral">" PROBLEM: order = "</span> &lt;&lt; order &lt;&lt; <span class="stringliteral">", pix = "</span> &lt;&lt; pix &lt;&lt; endl;
00347           <span class="keywordflow">if</span> ((n&gt;0) &amp;&amp; (nb[n]==nb[n-1]))
00348             cout &lt;&lt; <span class="stringliteral">" PROBLEM: order = "</span> &lt;&lt; order &lt;&lt; <span class="stringliteral">", pix = "</span> &lt;&lt; pix &lt;&lt; endl;
00349           }
00350         }
00351       <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__assertgroup.html#a1">planck_assert</a>((check&lt;=1)||((order==0)&amp;&amp;(check&lt;=2)),<span class="stringliteral">"too few neighbors"</span>);
00352       pixpt = base2.<a class="code" href="classHealpix__Base.html#a15">pix2ang</a>(pix);
00353       base2.<a class="code" href="classHealpix__Base.html#a21">neighbors</a>(pix,nb);
00354       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n=0; n&lt;8; ++n)
00355         <span class="keywordflow">if</span> ((nb[n]&gt;=0) &amp;&amp; (<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/geom__utils_8h.html#a1">v_angle</a>(base2.<a class="code" href="classHealpix__Base.html#a15">pix2ang</a>(nb[n]),pixpt)&gt;maxang))
00356           cout &lt;&lt; <span class="stringliteral">"  PROBLEM2: order = "</span> &lt;&lt; order &lt;&lt; <span class="stringliteral">", pix = "</span> &lt;&lt; pix &lt;&lt; endl;
00357       }
00358     }
00359   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> nside=3; nside&lt;(1&lt;&lt;13); nside+=nside/2+1)
00360     {
00361     cout &lt;&lt; <span class="stringliteral">"nside = "</span> &lt;&lt; nside &lt;&lt; endl;
00362     <a class="code" href="classHealpix__Base.html">Healpix_Base</a> base (nside,RING,SET_NSIDE);
00363     <span class="keywordtype">double</span> maxang = 2.01*base.<a class="code" href="classHealpix__Base.html#a29">max_pixrad</a>();
00364     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;nsamples/10; ++m)
00365       {
00366       <span class="keywordtype">int</span> pix = int(rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a3">rand_uni</a>()*base.<a class="code" href="classHealpix__Base.html#a25">Npix</a>());
00367       <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classfix__arr.html">fix_arr&lt;int,8&gt;</a> nb;
00368       <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classvec3.html">vec3</a> pixpt = base.<a class="code" href="classHealpix__Base.html#a15">pix2ang</a>(pix);
00369       base.<a class="code" href="classHealpix__Base.html#a21">neighbors</a>(pix,nb);
00370       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n=0; n&lt;8; ++n)
00371         <span class="keywordflow">if</span> ((nb[n]&gt;=0) &amp;&amp; (<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/geom__utils_8h.html#a1">v_angle</a>(base.<a class="code" href="classHealpix__Base.html#a15">pix2ang</a>(nb[n]),pixpt)&gt;maxang))
00372           cout &lt;&lt; <span class="stringliteral">"  PROBLEM: nside = "</span> &lt;&lt; nside &lt;&lt; <span class="stringliteral">", pix = "</span> &lt;&lt; pix &lt;&lt; endl;
00373       }
00374     }
00375   }
00376 <span class="keywordtype">void</span> check_neighbors2()
00377   {
00378   cout &lt;&lt; <span class="stringliteral">"testing neighbor function"</span> &lt;&lt; endl;
00379   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> order=0; order&lt;=29; ++order)
00380     {
00381     cout &lt;&lt; <span class="stringliteral">"order = "</span> &lt;&lt; order &lt;&lt; endl;
00382     <a class="code" href="classHealpix__Base2.html">Healpix_Base2</a> base (order,NEST), base2(order,RING);
00383     <span class="keywordtype">double</span> maxang = 2.01*base.<a class="code" href="classHealpix__Base2.html#a29">max_pixrad</a>();
00384     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;nsamples/10; ++m)
00385       {
00386       int64 pix = int64(rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a3">rand_uni</a>()*base.<a class="code" href="classHealpix__Base2.html#a25">Npix</a>());
00387       <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classfix__arr.html">fix_arr&lt;int64,8&gt;</a> nb;
00388       <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classvec3.html">vec3</a> pixpt = base.<a class="code" href="classHealpix__Base2.html#a15">pix2ang</a>(pix);
00389       base.<a class="code" href="classHealpix__Base2.html#a21">neighbors</a>(pix,nb);
00390       sort(&amp;nb[0],&amp;nb[0]+8);
00391       <span class="keywordtype">int</span> check=0;
00392       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n=0; n&lt;8; ++n)
00393         {
00394         <span class="keywordflow">if</span> (nb[n]&lt;0)
00395           {
00396           ++check;
00397           }
00398         <span class="keywordflow">else</span>
00399           {
00400           <span class="keywordflow">if</span> (<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/geom__utils_8h.html#a1">v_angle</a>(base.<a class="code" href="classHealpix__Base2.html#a15">pix2ang</a>(nb[n]),pixpt)&gt;maxang)
00401             cout &lt;&lt; <span class="stringliteral">" PROBLEM: order = "</span> &lt;&lt; order &lt;&lt; <span class="stringliteral">", pix = "</span> &lt;&lt; pix &lt;&lt; endl;
00402           <span class="keywordflow">if</span> ((n&gt;0) &amp;&amp; (nb[n]==nb[n-1]))
00403             cout &lt;&lt; <span class="stringliteral">" PROBLEM: order = "</span> &lt;&lt; order &lt;&lt; <span class="stringliteral">", pix = "</span> &lt;&lt; pix &lt;&lt; endl;
00404           }
00405         }
00406       <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__assertgroup.html#a1">planck_assert</a>((check&lt;=1)||((order==0)&amp;&amp;(check&lt;=2)),<span class="stringliteral">"too few neighbors"</span>);
00407       pixpt = base2.<a class="code" href="classHealpix__Base2.html#a15">pix2ang</a>(pix);
00408       base2.<a class="code" href="classHealpix__Base2.html#a21">neighbors</a>(pix,nb);
00409       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n=0; n&lt;8; ++n)
00410         <span class="keywordflow">if</span> ((nb[n]&gt;=0) &amp;&amp; (<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/geom__utils_8h.html#a1">v_angle</a>(base2.<a class="code" href="classHealpix__Base2.html#a15">pix2ang</a>(nb[n]),pixpt)&gt;maxang))
00411           cout &lt;&lt; <span class="stringliteral">"  PROBLEM2: order = "</span> &lt;&lt; order &lt;&lt; <span class="stringliteral">", pix = "</span> &lt;&lt; pix &lt;&lt; endl;
00412       }
00413     }
00414   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> nside=3; nside&lt;(1&lt;&lt;29); nside+=nside/2+1)
00415     {
00416     cout &lt;&lt; <span class="stringliteral">"nside = "</span> &lt;&lt; nside &lt;&lt; endl;
00417     <a class="code" href="classHealpix__Base2.html">Healpix_Base2</a> base (nside,RING,SET_NSIDE);
00418     <span class="keywordtype">double</span> maxang = 2.01*base.<a class="code" href="classHealpix__Base2.html#a29">max_pixrad</a>();
00419     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;nsamples/10; ++m)
00420       {
00421       int64 pix = int64(rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a3">rand_uni</a>()*base.<a class="code" href="classHealpix__Base2.html#a25">Npix</a>());
00422       <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classfix__arr.html">fix_arr&lt;int64,8&gt;</a> nb;
00423       <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classvec3.html">vec3</a> pixpt = base.<a class="code" href="classHealpix__Base2.html#a15">pix2ang</a>(pix);
00424       base.<a class="code" href="classHealpix__Base2.html#a21">neighbors</a>(pix,nb);
00425       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n=0; n&lt;8; ++n)
00426         <span class="keywordflow">if</span> ((nb[n]&gt;=0) &amp;&amp; (<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/geom__utils_8h.html#a1">v_angle</a>(base.<a class="code" href="classHealpix__Base2.html#a15">pix2ang</a>(nb[n]),pixpt)&gt;maxang))
00427           cout &lt;&lt; <span class="stringliteral">"  PROBLEM: nside = "</span> &lt;&lt; nside &lt;&lt; <span class="stringliteral">", pix = "</span> &lt;&lt; pix &lt;&lt; endl;
00428       }
00429     }
00430   }
00431 
00432 <span class="keywordtype">void</span> check_swap_scheme()
00433   {
00434   cout &lt;&lt; <span class="stringliteral">"testing whether double swap_scheme() returns the original map"</span>
00435        &lt;&lt; endl &lt;&lt; <span class="stringliteral">"(for orders 0 to 10)."</span> &lt;&lt; endl;
00436   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> order=0; order&lt;=10; ++order)
00437     {
00438     cout &lt;&lt; <span class="stringliteral">"order = "</span> &lt;&lt; order &lt;&lt; endl;
00439     <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;unsigned char&gt;</a> map(order,NEST);
00440     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;map.<a class="code" href="classHealpix__Base.html#a25">Npix</a>(); ++m) map[m]=m&amp;0xFF;
00441     map.<a class="code" href="classHealpix__Map.html#a14">swap_scheme</a>();
00442     map.<a class="code" href="classHealpix__Map.html#a14">swap_scheme</a>();
00443     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;map.<a class="code" href="classHealpix__Base.html#a25">Npix</a>(); ++m)
00444       <span class="keywordflow">if</span> (map[m]!=(m&amp;0xFF))
00445         cout &lt;&lt; <span class="stringliteral">"  PROBLEM: order = "</span> &lt;&lt; order &lt;&lt; <span class="stringliteral">", pix = "</span> &lt;&lt; m &lt;&lt; endl;
00446     }
00447   }
00448 
00449 <span class="keywordtype">void</span> check_query_disc()
00450   {
00451   cout &lt;&lt; <span class="stringliteral">"testing whether all pixels found by query_disc() really"</span> &lt;&lt; endl
00452        &lt;&lt; <span class="stringliteral">"lie inside the disk (and vice versa)"</span> &lt;&lt; endl;
00453   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> order=0; order&lt;=5; ++order)
00454     {
00455     cout &lt;&lt; <span class="stringliteral">"order = "</span> &lt;&lt; order &lt;&lt; endl;
00456     Healpix_Map &lt;bool&gt; map (order,RING);
00457     map.<a class="code" href="classHealpix__Map.html#a7">fill</a>(<span class="keyword">false</span>);
00458     vector&lt;int&gt; list;
00459     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;100000; ++m)
00460       {
00461       <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classpointing.html">pointing</a> ptg;
00462       random_dir (ptg);
00463       <span class="keywordtype">double</span> rad = pi/1 * rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a3">rand_uni</a>();
00464       map.<a class="code" href="classHealpix__Base.html#a17">query_disc</a>(ptg,rad,list);
00465       <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classvec3.html">vec3</a> vptg=ptg;
00466       <span class="keywordtype">double</span> cosrad=cos(rad);
00467       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;list.size(); ++i)
00468         map[list[i]] = <span class="keyword">true</span>;
00469       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;map.<a class="code" href="classHealpix__Base.html#a25">Npix</a>(); ++i)
00470         {
00471         <span class="keywordtype">bool</span> inside = <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__vec3group.html#a0">dotprod</a>(map.<a class="code" href="classHealpix__Base.html#a15">pix2ang</a>(i),vptg)&gt;cosrad;
00472         <span class="keywordflow">if</span> (inside^map[i])
00473           cout &lt;&lt; <span class="stringliteral">"  PROBLEM: order = "</span> &lt;&lt; order &lt;&lt; <span class="stringliteral">", ptg = "</span> &lt;&lt; ptg &lt;&lt; endl;
00474         }
00475       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;list.size(); ++i)
00476         map[list[i]] = <span class="keyword">false</span>;
00477       }
00478     }
00479   }
00480 
00481 <span class="keywordtype">void</span> helper_oop (<span class="keywordtype">int</span> order)
00482   {
00483   <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;double&gt;</a> map (order,RING), map2 (order,NEST), map3 (order,RING);
00484   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;map.<a class="code" href="classHealpix__Base.html#a25">Npix</a>(); ++m) map[m] = rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a3">rand_uni</a>()+0.01;
00485   map2.<a class="code" href="classHealpix__Map.html#a11">Import</a>(map);
00486   map3.<a class="code" href="classHealpix__Map.html#a11">Import</a>(map2);
00487   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;map.<a class="code" href="classHealpix__Base.html#a25">Npix</a>(); ++m)
00488     <span class="keywordflow">if</span> (!<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__mathutilsgroup.html#a0">approx</a>(map[m],map3[m],1e-12))
00489       cout &lt;&lt; <span class="stringliteral">"PROBLEM: order = "</span> &lt;&lt; order &lt;&lt; endl;
00490   }
00491 <span class="keywordtype">void</span> helper_udgrade (<span class="keywordtype">int</span> order, Healpix_Ordering_Scheme s1,
00492   Healpix_Ordering_Scheme s2)
00493   {
00494   <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;double&gt;</a> map (order,s1), map2 (order+2,s2), map3 (order, s1);
00495   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;map.<a class="code" href="classHealpix__Base.html#a25">Npix</a>(); ++m) map[m] = rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a3">rand_uni</a>()+0.01;
00496   map2.<a class="code" href="classHealpix__Map.html#a11">Import</a>(map);
00497   map3.<a class="code" href="classHealpix__Map.html#a11">Import</a>(map2);
00498   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;map.<a class="code" href="classHealpix__Base.html#a25">Npix</a>(); ++m)
00499     <span class="keywordflow">if</span> (!<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__mathutilsgroup.html#a0">approx</a>(map[m],map3[m],1e-12))
00500       cout &lt;&lt; <span class="stringliteral">"PROBLEM: order = "</span> &lt;&lt; order &lt;&lt; endl;
00501   }
00502 <span class="keywordtype">void</span> helper_udgrade2 (<span class="keywordtype">int</span> nside)
00503   {
00504   <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;double&gt;</a> map (nside,RING,SET_NSIDE), map2 (nside*3,RING,SET_NSIDE),
00505     map3 (nside, RING,SET_NSIDE);
00506   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;map.<a class="code" href="classHealpix__Base.html#a25">Npix</a>(); ++m) map[m] = rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a3">rand_uni</a>()+0.01;
00507   map2.<a class="code" href="classHealpix__Map.html#a11">Import</a>(map);
00508   map3.<a class="code" href="classHealpix__Map.html#a11">Import</a>(map2);
00509   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;map.<a class="code" href="classHealpix__Base.html#a25">Npix</a>(); ++m)
00510     <span class="keywordflow">if</span> (!<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__mathutilsgroup.html#a0">approx</a>(map[m],map3[m],1e-12))
00511       cout &lt;&lt; <span class="stringliteral">"PROBLEM: nside = "</span> &lt;&lt; nside &lt;&lt; endl;
00512   }
00513 
00514 <span class="keywordtype">void</span> check_import()
00515   {
00516   cout &lt;&lt; <span class="stringliteral">"testing out-of-place swapping"</span> &lt;&lt; endl;
00517   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> order=0; order&lt;=7; ++order)
00518     {
00519     cout &lt;&lt; <span class="stringliteral">"order = "</span> &lt;&lt; order &lt;&lt; endl;
00520     helper_oop(order);
00521     }
00522   cout &lt;&lt; <span class="stringliteral">"testing downgrade(upgrade(map)) == map"</span> &lt;&lt; endl;
00523   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> order=0; order&lt;=7; ++order)
00524     {
00525     cout &lt;&lt; <span class="stringliteral">"order = "</span> &lt;&lt; order &lt;&lt; endl;
00526     cout &lt;&lt; <span class="stringliteral">"RING, RING"</span> &lt;&lt; endl;
00527     helper_udgrade(order,RING,RING);
00528     cout &lt;&lt; <span class="stringliteral">"RING, NEST"</span> &lt;&lt; endl;
00529     helper_udgrade(order,RING,NEST);
00530     cout &lt;&lt; <span class="stringliteral">"NEST, NEST"</span> &lt;&lt; endl;
00531     helper_udgrade(order,NEST,NEST);
00532     cout &lt;&lt; <span class="stringliteral">"NEST, RING"</span> &lt;&lt; endl;
00533     helper_udgrade(order,NEST,RING);
00534     }
00535   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> nside=3; nside&lt;500; nside+=nside/2+1)
00536     {
00537     cout &lt;&lt; <span class="stringliteral">"nside = "</span> &lt;&lt; nside &lt;&lt; endl;
00538     helper_udgrade2(nside);
00539     }
00540   }
00541 
00542 <span class="keywordtype">void</span> check_average()
00543   {
00544   cout &lt;&lt; <span class="stringliteral">"testing whether average(map) == average(downgraded map)"</span> &lt;&lt; endl;
00545   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> order=1; order&lt;=10; ++order)
00546     {
00547     cout &lt;&lt; <span class="stringliteral">"order = "</span> &lt;&lt; order &lt;&lt; endl;
00548     <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;double&gt;</a> map (order,RING), map2(1,RING);
00549     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;map.<a class="code" href="classHealpix__Base.html#a25">Npix</a>(); ++m)
00550       map[m] = rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a3">rand_uni</a>()+0.01;
00551     map2.<a class="code" href="classHealpix__Map.html#a11">Import</a>(map);
00552     <span class="keywordtype">double</span> avg=map.<a class="code" href="classHealpix__Map.html#a20">average</a>(), avg2=map2.<a class="code" href="classHealpix__Map.html#a20">average</a>();
00553     <span class="keywordflow">if</span> (!<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__mathutilsgroup.html#a0">approx</a>(avg,avg2,1e-10))
00554       cout &lt;&lt; <span class="stringliteral">"PROBLEM: order = "</span> &lt;&lt; order &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; avg/avg2-1 &lt;&lt; endl;
00555     }
00556   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> nside=3; nside&lt;1000; nside += nside/2+1)
00557     {
00558     cout &lt;&lt; <span class="stringliteral">"nside = "</span> &lt;&lt; nside &lt;&lt; endl;
00559     <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;double&gt;</a> map (nside,RING,SET_NSIDE), map2(1,RING,SET_NSIDE);
00560     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;map.<a class="code" href="classHealpix__Base.html#a25">Npix</a>(); ++m)
00561       map[m] = rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a3">rand_uni</a>()+0.01;
00562     map2.<a class="code" href="classHealpix__Map.html#a11">Import</a>(map);
00563     <span class="keywordtype">double</span> avg=map.<a class="code" href="classHealpix__Map.html#a20">average</a>(), avg2=map2.<a class="code" href="classHealpix__Map.html#a20">average</a>();
00564     <span class="keywordflow">if</span> (!<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__mathutilsgroup.html#a0">approx</a>(avg,avg2,1e-10))
00565       cout &lt;&lt; <span class="stringliteral">"PROBLEM: nside = "</span> &lt;&lt; nside &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; avg/avg2-1 &lt;&lt; endl;
00566     }
00567   }
00568 
00569 <span class="keywordtype">void</span> random_alm (<a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> &gt;&amp;almT, <a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> &gt;&amp;almG,
00570   <a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> &gt;&amp;almC, <span class="keywordtype">int</span> lmax, <span class="keywordtype">int</span> mmax)
00571   {
00572   almT.Set(lmax,mmax); almG.Set(lmax,mmax); almC.Set(lmax,mmax);
00573 
00574   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> l=0; l&lt;=lmax; ++l)
00575     {
00576     almT(l,0).re=rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a4">rand_gauss</a>(); almT(l,0).im=0.;
00577     almG(l,0).re=rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a4">rand_gauss</a>(); almG(l,0).im=0.;
00578     almC(l,0).re=rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a4">rand_gauss</a>(); almC(l,0).im=0.;
00579     }
00580 
00581   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=1; m&lt;=mmax; ++m)
00582     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> l=m; l&lt;=lmax; ++l)
00583       {
00584       almT(l,m).re=rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a4">rand_gauss</a>(); almT(l,m).im=rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a4">rand_gauss</a>();
00585       almG(l,m).re=rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a4">rand_gauss</a>(); almG(l,m).im=rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a4">rand_gauss</a>();
00586       almC(l,m).re=rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a4">rand_gauss</a>(); almC(l,m).im=rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a4">rand_gauss</a>();
00587       }
00588   almG(0,0)=almC(0,0)=almG(1,0)=almC(1,0)=almG(1,1)=almC(1,1)=0;
00589   }
00590 
00591 <span class="keywordtype">void</span> random_alm (<a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> &gt;&amp;alm, <span class="keywordtype">int</span> lmax, <span class="keywordtype">int</span> mmax)
00592   {
00593   alm.Set(lmax,mmax);
00594 
00595   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> l=0; l&lt;=lmax; ++l)
00596     { alm(l,0).re=rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a4">rand_gauss</a>(); alm(l,0).im=0.; }
00597 
00598   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=1; m&lt;=mmax; ++m)
00599     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> l=m; l&lt;=lmax; ++l)
00600       { alm(l,m).re=rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a4">rand_gauss</a>(); alm(l,m).im=rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a4">rand_gauss</a>(); }
00601   }
00602 
00603 <span class="keywordtype">void</span> check_alm (<span class="keyword">const</span> <a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> &gt;&amp;oalm,
00604   <span class="keyword">const</span> <a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> &gt;&amp;alm, <span class="keywordtype">double</span> epsilon)
00605   {
00606   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;=alm.Mmax(); ++m)
00607     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> l=m; l&lt;=alm.Lmax(); ++l)
00608       {
00609       <span class="keywordflow">if</span> (!<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__mathutilsgroup.html#a1">abs_approx</a>(oalm(l,m).re,alm(l,m).re,epsilon))
00610         cout &lt;&lt; <span class="stringliteral">"Problemr "</span> &lt;&lt; l &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; m &lt;&lt; endl;
00611       <span class="keywordflow">if</span> (!<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__mathutilsgroup.html#a1">abs_approx</a>(oalm(l,m).im,alm(l,m).im,epsilon))
00612         cout &lt;&lt; <span class="stringliteral">"Problemi "</span> &lt;&lt; l &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; m &lt;&lt;  endl;
00613       }
00614   }
00615 
00616 <span class="keywordtype">void</span> check_alm2map2alm (<span class="keywordtype">int</span> lmax, <span class="keywordtype">int</span> mmax, <span class="keywordtype">int</span> nside)
00617   {
00618   cout &lt;&lt; <span class="stringliteral">"testing whether a_lm-&gt;map-&gt;a_lm returns original a_lm"</span> &lt;&lt; endl;
00619   cout &lt;&lt; <span class="stringliteral">"lmax="</span> &lt;&lt; lmax &lt;&lt;<span class="stringliteral">", mmax="</span> &lt;&lt; mmax &lt;&lt; <span class="stringliteral">", nside="</span> &lt;&lt; nside &lt;&lt; endl;
00620   <span class="keyword">const</span> <span class="keywordtype">double</span> epsilon = 1e-8;
00621   <a class="code" href="classAlm.html">Alm&lt;xcomplex&lt;double&gt;</a> &gt; oalmT(lmax,mmax),almT(lmax,mmax),
00622     oalmG(lmax,mmax),almG(lmax,mmax),oalmC(lmax,mmax),almC(lmax,mmax);
00623   <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;double&gt;</a> mapT(nside,RING,SET_NSIDE), mapQ(nside,RING,SET_NSIDE),
00624     mapU(nside,RING,SET_NSIDE);
00625 
00626   random_alm(oalmT,oalmG,oalmC,lmax,mmax);
00627   <a class="code" href="group__alm__healpix__group.html#a8">alm2map</a>(oalmT,mapT);
00628   map2alm_iter2(mapT,almT,1e-12,1e-12);
00629   check_alm (oalmT, almT, epsilon);
00630 
00631   <a class="code" href="group__alm__healpix__group.html#a9">alm2map_pol</a>(oalmT,oalmG,oalmC,mapT,mapQ,mapU);
00632   map2alm_pol_iter2(mapT,mapQ,mapU,almT,almG,almC,1e-12,1e-12);
00633   check_alm (oalmT, almT, epsilon);
00634   check_alm (oalmG, almG, epsilon);
00635   check_alm (oalmC, almC, epsilon);
00636   }
00637 
00638 <span class="keywordtype">void</span> check_smooth_alm ()
00639   {
00640   cout &lt;&lt; <span class="stringliteral">"testing whether unsmooth(smooth(a_lm)) returns a_lm"</span> &lt;&lt; endl;
00641   <span class="keyword">const</span> <span class="keywordtype">double</span> epsilon = 1e-14;
00642   <span class="keyword">const</span> <span class="keywordtype">double</span> fwhm_arcmin = 100;
00643   <span class="keyword">const</span> <span class="keywordtype">int</span> lmax=300, mmax=300;
00644   <a class="code" href="classAlm.html">Alm&lt;xcomplex&lt;double&gt;</a> &gt; oalmT(lmax,mmax),almT(lmax,mmax),
00645     oalmG(lmax,mmax),almG(lmax,mmax),oalmC(lmax,mmax),almC(lmax,mmax);
00646 
00647   random_alm(oalmT,oalmG,oalmC,lmax,mmax);
00648 
00649   almT=oalmT; almG=oalmG; almC=oalmC;
00650   smooth_with_Gauss (almT, fwhm_arcmin);
00651   smooth_with_Gauss (almT, -fwhm_arcmin);
00652   check_alm (oalmT, almT, epsilon);
00653   almT=oalmT;
00654   smooth_with_Gauss (almT, almG, almC, fwhm_arcmin);
00655   smooth_with_Gauss (almT, almG, almC, -fwhm_arcmin);
00656   check_alm (oalmT, almT, epsilon);
00657   check_alm (oalmG, almG, epsilon);
00658   check_alm (oalmC, almC, epsilon);
00659   }
00660 
00661 <span class="keywordtype">void</span> check_rot_alm ()
00662   {
00663   cout &lt;&lt; <span class="stringliteral">"testing whether rot^-1(rot(a_lm)) returns a_lm"</span> &lt;&lt; endl;
00664   <span class="keyword">const</span> <span class="keywordtype">double</span> epsilon = 2e-13;
00665   <span class="keyword">const</span> <span class="keywordtype">int</span> lmax=300;
00666   <a class="code" href="classAlm.html">Alm&lt;xcomplex&lt;double&gt;</a> &gt; oalm(lmax,lmax),alm(lmax,lmax);
00667 
00668   random_alm(oalm,lmax,lmax);
00669 
00670   alm=oalm;
00671   rotate_alm (alm,3,4,5);
00672   rotate_alm (alm,-5,-4,-3);
00673   check_alm (oalm, alm, epsilon);
00674   }
00675 
00676 <span class="keywordtype">int</span> main()
00677   {
00678   check_smooth_alm();
00679   check_rot_alm();
00680   check_alm2map2alm(620,620,256);
00681   check_alm2map2alm(620,2,256);
00682   check_average();
00683   check_import();
00684   check_neighbors();
00685   check_neighbors2();
00686   check_pixangpix();
00687   check_pixangpix2();
00688   check_pixvecpix();
00689   check_pixvecpix2();
00690   check_angpixang();
00691   check_angpixang2();
00692   check_ringnestring();
00693   check_ringnestring2();
00694   check_nestpeanonest();
00695   check_nestpeanonest2();
00696   check_query_disc();
00697   check_swap_scheme();
00698   }
</pre></div><hr><address style="align: right;"><small>
Generated on Thu Nov 13 18:48:51 2008 for Healpix C++
</a> </small></address>
</body>
</html>
