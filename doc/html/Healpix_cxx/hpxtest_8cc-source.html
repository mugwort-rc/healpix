<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Healpix C++: hpxtest.cc Source File</title>
<link href="sheet.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">Healpix_cxx</a></div>
<h1>hpxtest.cc</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> *  This file is part of Healpix_cxx.</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> *  Healpix_cxx is free software; you can redistribute it and/or modify</span>
00005 <span class="comment"> *  it under the terms of the GNU General Public License as published by</span>
00006 <span class="comment"> *  the Free Software Foundation; either version 2 of the License, or</span>
00007 <span class="comment"> *  (at your option) any later version.</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> *  Healpix_cxx is distributed in the hope that it will be useful,</span>
00010 <span class="comment"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00012 <span class="comment"> *  GNU General Public License for more details.</span>
00013 <span class="comment"> *</span>
00014 <span class="comment"> *  You should have received a copy of the GNU General Public License</span>
00015 <span class="comment"> *  along with Healpix_cxx; if not, write to the Free Software</span>
00016 <span class="comment"> *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
00017 <span class="comment"> *</span>
00018 <span class="comment"> *  For more information about HEALPix, see http://healpix.jpl.nasa.gov</span>
00019 <span class="comment"> */</span>
00020 
00021 <span class="comment">/*</span>
00022 <span class="comment"> *  Healpix_cxx is being developed at the Max-Planck-Institut fuer Astrophysik</span>
00023 <span class="comment"> *  and financially supported by the Deutsches Zentrum fuer Luft- und Raumfahrt</span>
00024 <span class="comment"> *  (DLR).</span>
00025 <span class="comment"> */</span>
00026 
00027 <span class="comment">/*</span>
00028 <span class="comment"> *  Copyright (C) 2004, 2005 Max-Planck-Society</span>
00029 <span class="comment"> *  Author: Martin Reinecke</span>
00030 <span class="comment"> */</span>
00031 
00032 <span class="comment">/*</span>
00033 <span class="comment"></span>
00034 <span class="comment">Candidates for testing the validity of the Healpix routines:</span>
00035 <span class="comment"></span>
00036 <span class="comment">- done: ang2pix(pix2ang(i)) = i for all Healpix_Bases</span>
00037 <span class="comment">- done: pix2ang(ang2pix(ptg)) dot ptg &gt; 1-delta for all Healpix_Bases</span>
00038 <span class="comment">- done: ring2nest(nest2ring(i)) = i for all hierarchical Healpix_Bases</span>
00039 <span class="comment">- done: downgrade(upgrade(map)) = map for all maps</span>
00040 <span class="comment">- done: map and downgraded map should have same average</span>
00041 <span class="comment">- done: alm2map(map2alm(map)) approx map (same for pol)</span>
00042 <span class="comment">- partly done: neighbor tests</span>
00043 <span class="comment">- powspec -&gt; alm -&gt; powspec (should produce similar powspecs, also for pol)</span>
00044 <span class="comment">- done: two swap_schemes() should produce original map</span>
00045 <span class="comment">- done: query_disc tests (dot products etc.)</span>
00046 <span class="comment">- a_lms: test Set(), Scale(), Add(), alm(l,m) = alm.mstart(m)[l], etc.</span>
00047 <span class="comment"></span>
00048 <span class="comment">*/</span>
00049 
00050 <span class="preprocessor">#include &lt;iostream&gt;</span>
00051 <span class="preprocessor">#include "<a class="code" href="healpix__base_8h.html">healpix_base.h</a>"</span>
00052 <span class="preprocessor">#include "<a class="code" href="healpix__map_8h.html">healpix_map.h</a>"</span>
00053 <span class="preprocessor">#include "<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/arr_8h.html">arr.h</a>"</span>
00054 <span class="preprocessor">#include "<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/planck__rng_8h.html">planck_rng.h</a>"</span>
00055 <span class="preprocessor">#include "<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/constants_8h.html">constants.h</a>"</span>
00056 <span class="preprocessor">#include "<a class="code" href="alm_8h.html">alm.h</a>"</span>
00057 <span class="preprocessor">#include "<a class="code" href="alm__map__tools_8h.html">alm_map_tools.h</a>"</span>
00058 <span class="preprocessor">#include "<a class="code" href="alm__powspec__tools_8h.html">alm_powspec_tools.h</a>"</span>
00059 
00060 <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00061 
00062 <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html">planck_rng</a> rng;
00063 
00064 <span class="keywordtype">void</span> random_dir (<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classpointing.html">pointing</a> &amp;ptg)
00065   {
00066   ptg.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classpointing.html#o0">theta</a> = acos(rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a3">rand_uni</a>()*2-1);
00067   ptg.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classpointing.html#o1">phi</a> = rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a3">rand_uni</a>()*twopi;
00068   }
00069 
00070 <span class="keywordtype">void</span> check_ringnestring()
00071   {
00072   cout &lt;&lt; <span class="stringliteral">"testing ring2nest(nest2ring(m))==m"</span> &lt;&lt; endl;
00073   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> order=0; order&lt;=13; ++order)
00074     {
00075     cout &lt;&lt; <span class="stringliteral">"order = "</span> &lt;&lt; order &lt;&lt; endl;
00076     <a class="code" href="classHealpix__Base.html">Healpix_Base</a> base (order,RING);
00077     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;base.Npix(); ++m)
00078       {
00079       <span class="keywordflow">if</span> (base.ring2nest(base.nest2ring(m))!=m)
00080         cout &lt;&lt; <span class="stringliteral">"  PROBLEM: order = "</span> &lt;&lt; order &lt;&lt; <span class="stringliteral">", pixel = "</span> &lt;&lt; m &lt;&lt; endl;
00081       }
00082     }
00083   }
00084 
00085 <span class="keywordtype">void</span> check_pixangpix()
00086   {
00087   cout &lt;&lt; <span class="stringliteral">"testing ang2pix(pix2ang(m))==m"</span> &lt;&lt; endl;
00088   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> order=0; order&lt;=13; ++order)
00089     {
00090     cout &lt;&lt; <span class="stringliteral">"order = "</span> &lt;&lt; order &lt;&lt; endl;
00091     <a class="code" href="classHealpix__Base.html">Healpix_Base</a> base1 (order,RING);
00092     <a class="code" href="classHealpix__Base.html">Healpix_Base</a> base2 (order,NEST);
00093     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;base1.Npix(); ++m)
00094       {
00095       <span class="keywordflow">if</span> (base1.ang2pix(base1.pix2ang(m))!=m)
00096         cout &lt;&lt; <span class="stringliteral">"  PROBLEM: order = "</span> &lt;&lt; order &lt;&lt; <span class="stringliteral">", pixel = "</span> &lt;&lt; m &lt;&lt; endl;
00097       <span class="keywordflow">if</span> (base2.ang2pix(base2.pix2ang(m))!=m)
00098         cout &lt;&lt; <span class="stringliteral">"  PROBLEM: order = "</span> &lt;&lt; order &lt;&lt; <span class="stringliteral">", pixel = "</span> &lt;&lt; m &lt;&lt; endl;
00099       }
00100     }
00101   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> nside=3; nside&lt;1000; nside+=nside/2+1)
00102     {
00103     cout &lt;&lt; <span class="stringliteral">"nside = "</span> &lt;&lt; nside &lt;&lt; endl;
00104     <a class="code" href="classHealpix__Base.html">Healpix_Base</a> base (nside,RING,SET_NSIDE);
00105     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;base.Npix(); ++m)
00106       {
00107       <span class="keywordflow">if</span> (base.ang2pix(base.pix2ang(m))!=m)
00108         cout &lt;&lt; <span class="stringliteral">"  PROBLEM: nside = "</span> &lt;&lt; nside &lt;&lt; <span class="stringliteral">", pixel = "</span> &lt;&lt; m &lt;&lt; endl;
00109       }
00110     }
00111   }
00112 
00113 <span class="keywordtype">void</span> check_angpixang()
00114   {
00115   cout &lt;&lt; <span class="stringliteral">"testing pix2ang(ang2pix(ptg)) approx ptg"</span> &lt;&lt; endl;
00116   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> nside=3; nside&lt;1000; nside+=nside/2+1)
00117     {
00118     cout &lt;&lt; <span class="stringliteral">"nside = "</span> &lt;&lt; nside &lt;&lt; endl;
00119     <a class="code" href="classHealpix__Base.html">Healpix_Base</a> base (nside,RING,SET_NSIDE);
00120     <span class="keywordtype">double</span> cosmaxang = cos (1.36*twopi/(8*nside));
00121     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;100000; ++m)
00122       {
00123       <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classpointing.html">pointing</a> ptg;
00124       random_dir (ptg);
00125       <span class="keywordflow">if</span> (<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__vec3group.html#gga0">dotprod</a>(base.pix2ang(base.ang2pix(ptg)),ptg)&lt;cosmaxang)
00126         cout &lt;&lt; <span class="stringliteral">"  PROBLEM: nside = "</span> &lt;&lt; nside &lt;&lt; <span class="stringliteral">", ptg = "</span> &lt;&lt; ptg &lt;&lt; endl;
00127       }
00128     }
00129   }
00130 
00131 <span class="keywordtype">void</span> check_neighbors()
00132   {
00133   cout &lt;&lt; <span class="stringliteral">"testing (pix2ang(neighbors(pix))) approx pix2ang(pix)"</span> &lt;&lt; endl;
00134   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> order=0; order&lt;=13; ++order)
00135     {
00136     cout &lt;&lt; <span class="stringliteral">"order = "</span> &lt;&lt; order &lt;&lt; endl;
00137     <a class="code" href="classHealpix__Base.html">Healpix_Base</a> base (order,NEST), base2(order,RING);
00138     <span class="keywordtype">double</span> cosmaxang = cos (2.75*twopi/(8*base.Nside()));
00139     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;100000; ++m)
00140       {
00141       <span class="keywordtype">int</span> pix = rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a2">int_rand_uni</a>()%base.Npix();
00142       <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classfix__arr.html">fix_arr&lt;int,8&gt;</a> nb;
00143       <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classvec3.html">vec3</a> pixpt = base.pix2ang(pix);
00144       base.neighbors(pix,nb);
00145       <span class="keywordtype">int</span> check=0;
00146       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n=0; n&lt;8; ++n)
00147         {
00148         <span class="keywordflow">if</span> (nb[n]&lt;0) ++check;
00149         <span class="keywordflow">if</span> ((nb[n]&gt;=0) &amp;&amp; (<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__vec3group.html#gga0">dotprod</a>(base.pix2ang(nb[n]),pixpt)&lt;cosmaxang))
00150           cout &lt;&lt; <span class="stringliteral">"  PROBLEM: order = "</span> &lt;&lt; order &lt;&lt; <span class="stringliteral">", pix = "</span> &lt;&lt; pix &lt;&lt; endl;
00151         }
00152       <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__assertgroup.html#gga1">planck_assert</a>((check&lt;=1)||((order==0)&amp;&amp;(check&lt;=2)),<span class="stringliteral">"too few neighbors"</span>);
00153       pixpt = base2.pix2ang(pix);
00154       base2.neighbors(pix,nb);
00155       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n=0; n&lt;8; ++n)
00156         <span class="keywordflow">if</span> ((nb[n]&gt;=0) &amp;&amp; (<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__vec3group.html#gga0">dotprod</a>(base2.pix2ang(nb[n]),pixpt)&lt;cosmaxang))
00157           cout &lt;&lt; <span class="stringliteral">"  PROBLEM2: order = "</span> &lt;&lt; order &lt;&lt; <span class="stringliteral">", pix = "</span> &lt;&lt; pix &lt;&lt; endl;
00158       }
00159     }
00160   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> nside=3; nside&lt;1000; nside+=nside/2+1)
00161     {
00162     cout &lt;&lt; <span class="stringliteral">"nside = "</span> &lt;&lt; nside &lt;&lt; endl;
00163     <a class="code" href="classHealpix__Base.html">Healpix_Base</a> base (nside,RING,SET_NSIDE);
00164     <span class="keywordtype">double</span> cosmaxang = cos (2.75*twopi/(8*base.Nside()));
00165     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;100000; ++m)
00166       {
00167       <span class="keywordtype">int</span> pix = rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a2">int_rand_uni</a>()%base.Npix();
00168       <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classfix__arr.html">fix_arr&lt;int,8&gt;</a> nb;
00169       <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classvec3.html">vec3</a> pixpt = base.pix2ang(pix);
00170       base.neighbors(pix,nb);
00171       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n=0; n&lt;8; ++n)
00172         <span class="keywordflow">if</span> ((nb[n]&gt;=0) &amp;&amp; (<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__vec3group.html#gga0">dotprod</a>(base.pix2ang(nb[n]),pixpt)&lt;cosmaxang))
00173           cout &lt;&lt; <span class="stringliteral">"  PROBLEM: nside = "</span> &lt;&lt; nside &lt;&lt; <span class="stringliteral">", pix = "</span> &lt;&lt; pix &lt;&lt; endl;
00174       }
00175     }
00176   }
00177 
00178 <span class="keywordtype">void</span> check_swap_scheme()
00179   {
00180   cout &lt;&lt; <span class="stringliteral">"testing whether double swap_scheme() returns the original map"</span>
00181        &lt;&lt; endl &lt;&lt; <span class="stringliteral">"(for orders 0 to 10)."</span> &lt;&lt; endl;
00182   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> order=0; order&lt;=10; ++order)
00183     {
00184     cout &lt;&lt; <span class="stringliteral">"order = "</span> &lt;&lt; order &lt;&lt; endl;
00185     <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;unsigned char&gt;</a> map(order,NEST);
00186     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;map.Npix(); ++m) map[m]=m&amp;0xFF;
00187     map.swap_scheme();
00188     map.swap_scheme();
00189     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;map.Npix(); ++m)
00190       <span class="keywordflow">if</span> (map[m]!=(m&amp;0xFF))
00191         cout &lt;&lt; <span class="stringliteral">"  PROBLEM: order = "</span> &lt;&lt; order &lt;&lt; <span class="stringliteral">", pix = "</span> &lt;&lt; m &lt;&lt; endl;
00192     }
00193   }
00194 
00195 <span class="keywordtype">void</span> check_query_disc()
00196   {
00197   cout &lt;&lt; <span class="stringliteral">"testing whether all pixels found by query_disc() really"</span> &lt;&lt; endl
00198        &lt;&lt; <span class="stringliteral">"lie inside the disk (and vice versa)"</span> &lt;&lt; endl;
00199   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> order=0; order&lt;=5; ++order)
00200     {
00201     cout &lt;&lt; <span class="stringliteral">"order = "</span> &lt;&lt; order &lt;&lt; endl;
00202     Healpix_Map &lt;bool&gt; map (order,RING);
00203     map.fill(<span class="keyword">false</span>);
00204     vector&lt;int&gt; list;
00205     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;100000; ++m)
00206       {
00207       <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classpointing.html">pointing</a> ptg;
00208       random_dir (ptg);
00209       <span class="keywordtype">double</span> rad = pi/1 * rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a3">rand_uni</a>();
00210       map.query_disc(ptg,rad,list);
00211       <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classvec3.html">vec3</a> vptg=ptg;
00212       <span class="keywordtype">double</span> cosrad=cos(rad);
00213       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;list.size(); ++i)
00214         map[list[i]] = <span class="keyword">true</span>;
00215       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;map.Npix(); ++i)
00216         {
00217         <span class="keywordtype">bool</span> inside = <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__vec3group.html#gga0">dotprod</a>(map.pix2ang(i),vptg)&gt;cosrad;
00218         <span class="keywordflow">if</span> (inside^map[i])
00219           cout &lt;&lt; <span class="stringliteral">"  PROBLEM: order = "</span> &lt;&lt; order &lt;&lt; <span class="stringliteral">", ptg = "</span> &lt;&lt; ptg &lt;&lt; endl;
00220         }
00221       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;list.size(); ++i)
00222         map[list[i]] = <span class="keyword">false</span>;
00223       }
00224     }
00225   }
00226 
00227 <span class="keywordtype">void</span> helper_oop (<span class="keywordtype">int</span> order)
00228   {
00229   <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;double&gt;</a> map (order,RING), map2 (order,NEST), map3 (order,RING);
00230   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;map.Npix(); ++m) map[m] = rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a3">rand_uni</a>()+0.01;
00231   map2.Import(map);
00232   map3.Import(map2);
00233   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;map.Npix(); ++m)
00234     <span class="keywordflow">if</span> (!<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__mathutilsgroup.html#gga0">approx</a>(map[m],map3[m],1e-12))
00235       cout &lt;&lt; <span class="stringliteral">"PROBLEM: order = "</span> &lt;&lt; order &lt;&lt; endl;
00236   }
00237 <span class="keywordtype">void</span> helper_udgrade (<span class="keywordtype">int</span> order, Healpix_Ordering_Scheme s1,
00238   Healpix_Ordering_Scheme s2)
00239   {
00240   <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;double&gt;</a> map (order,s1), map2 (order+2,s2), map3 (order, s1);
00241   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;map.Npix(); ++m) map[m] = rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a3">rand_uni</a>()+0.01;
00242   map2.Import(map);
00243   map3.Import(map2);
00244   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;map.Npix(); ++m)
00245     <span class="keywordflow">if</span> (!<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__mathutilsgroup.html#gga0">approx</a>(map[m],map3[m],1e-12))
00246       cout &lt;&lt; <span class="stringliteral">"PROBLEM: order = "</span> &lt;&lt; order &lt;&lt; endl;
00247   }
00248 <span class="keywordtype">void</span> helper_udgrade2 (<span class="keywordtype">int</span> nside)
00249   {
00250   <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;double&gt;</a> map (nside,RING,SET_NSIDE), map2 (nside*3,RING,SET_NSIDE),
00251     map3 (nside, RING,SET_NSIDE);
00252   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;map.Npix(); ++m) map[m] = rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a3">rand_uni</a>()+0.01;
00253   map2.Import(map);
00254   map3.Import(map2);
00255   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;map.Npix(); ++m)
00256     <span class="keywordflow">if</span> (!<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__mathutilsgroup.html#gga0">approx</a>(map[m],map3[m],1e-12))
00257       cout &lt;&lt; <span class="stringliteral">"PROBLEM: nside = "</span> &lt;&lt; nside &lt;&lt; endl;
00258   }
00259 
00260 <span class="keywordtype">void</span> check_import()
00261   {
00262   cout &lt;&lt; <span class="stringliteral">"testing out-of-place swapping"</span> &lt;&lt; endl;
00263   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> order=0; order&lt;=7; ++order)
00264     {
00265     cout &lt;&lt; <span class="stringliteral">"order = "</span> &lt;&lt; order &lt;&lt; endl;
00266     helper_oop(order);
00267     }
00268   cout &lt;&lt; <span class="stringliteral">"testing downgrade(upgrade(map)) == map"</span> &lt;&lt; endl;
00269   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> order=0; order&lt;=7; ++order)
00270     {
00271     cout &lt;&lt; <span class="stringliteral">"order = "</span> &lt;&lt; order &lt;&lt; endl;
00272     cout &lt;&lt; <span class="stringliteral">"RING, RING"</span> &lt;&lt; endl;
00273     helper_udgrade(order,RING,RING);
00274     cout &lt;&lt; <span class="stringliteral">"RING, NEST"</span> &lt;&lt; endl;
00275     helper_udgrade(order,RING,NEST);
00276     cout &lt;&lt; <span class="stringliteral">"NEST, NEST"</span> &lt;&lt; endl;
00277     helper_udgrade(order,NEST,NEST);
00278     cout &lt;&lt; <span class="stringliteral">"NEST, RING"</span> &lt;&lt; endl;
00279     helper_udgrade(order,NEST,RING);
00280     }
00281   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> nside=3; nside&lt;500; nside+=nside/2+1)
00282     {
00283     cout &lt;&lt; <span class="stringliteral">"nside = "</span> &lt;&lt; nside &lt;&lt; endl;
00284     helper_udgrade2(nside);
00285     }
00286   }
00287 
00288 <span class="keywordtype">void</span> check_average()
00289   {
00290   cout &lt;&lt; <span class="stringliteral">"testing whether average(map) == average(downgraded map)"</span> &lt;&lt; endl;
00291   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> order=1; order&lt;=10; ++order)
00292     {
00293     cout &lt;&lt; <span class="stringliteral">"order = "</span> &lt;&lt; order &lt;&lt; endl;
00294     <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;double&gt;</a> map (order,RING), map2(1,RING);
00295     <span class="keywordtype">double</span> avg=0, avg2=0;
00296     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;map.Npix(); ++m)
00297       {
00298       map[m] = rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a3">rand_uni</a>()+0.01;
00299       avg+=map[m];
00300       }
00301     avg /= map.Npix();
00302     map2.Import(map);
00303     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;map2.Npix(); ++m)
00304       avg2+=map2[m];
00305     avg2 /= map2.Npix();
00306 
00307     <span class="keywordflow">if</span> (!<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__mathutilsgroup.html#gga0">approx</a>(avg,avg2,1e-10))
00308       cout &lt;&lt; <span class="stringliteral">"PROBLEM: order = "</span> &lt;&lt; order &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; avg/avg2-1 &lt;&lt; endl;
00309     }
00310   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> nside=3; nside&lt;1000; nside += nside/2+1)
00311     {
00312     cout &lt;&lt; <span class="stringliteral">"nside = "</span> &lt;&lt; nside &lt;&lt; endl;
00313     <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;double&gt;</a> map (nside,RING,SET_NSIDE), map2(1,RING,SET_NSIDE);
00314     <span class="keywordtype">double</span> avg=0, avg2=0;
00315     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;map.Npix(); ++m)
00316       {
00317       map[m] = rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a3">rand_uni</a>()+0.01;
00318       avg+=map[m];
00319       }
00320     avg /= map.Npix();
00321     map2.Import(map);
00322     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;map2.Npix(); ++m)
00323       avg2+=map2[m];
00324     avg2 /= map2.Npix();
00325 
00326     <span class="keywordflow">if</span> (!<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__mathutilsgroup.html#gga0">approx</a>(avg,avg2,1e-10))
00327       cout &lt;&lt; <span class="stringliteral">"PROBLEM: nside = "</span> &lt;&lt; nside &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; avg/avg2-1 &lt;&lt; endl;
00328     }
00329   }
00330 
00331 <span class="keywordtype">void</span> random_alm (<a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> &gt;&amp;almT, <a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> &gt;&amp;almG,
00332   <a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> &gt;&amp;almC, <span class="keywordtype">int</span> lmax, <span class="keywordtype">int</span> mmax)
00333   {
00334   almT.Set(lmax,mmax); almG.Set(lmax,mmax); almC.Set(lmax,mmax);
00335 
00336   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> l=0; l&lt;=lmax; ++l)
00337     {
00338     almT(l,0).re=rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a4">rand_gauss</a>(); almT(l,0).im=0.;
00339     almG(l,0).re=rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a4">rand_gauss</a>(); almG(l,0).im=0.;
00340     almC(l,0).re=rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a4">rand_gauss</a>(); almC(l,0).im=0.;
00341     }
00342 
00343   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=1; m&lt;=mmax; ++m)
00344     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> l=m; l&lt;=lmax; ++l)
00345       {
00346       almT(l,m).re=rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a4">rand_gauss</a>(); almT(l,m).im=rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a4">rand_gauss</a>();
00347       almG(l,m).re=rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a4">rand_gauss</a>(); almG(l,m).im=rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a4">rand_gauss</a>();
00348       almC(l,m).re=rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a4">rand_gauss</a>(); almC(l,m).im=rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a4">rand_gauss</a>();
00349       }
00350   almG(0,0)=almC(0,0)=almG(1,0)=almC(1,0)=almG(1,1)=almC(1,1)=0;
00351   }
00352 
00353 <span class="keywordtype">void</span> random_alm (<a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> &gt;&amp;alm, <span class="keywordtype">int</span> lmax, <span class="keywordtype">int</span> mmax)
00354   {
00355   alm.Set(lmax,mmax);
00356 
00357   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> l=0; l&lt;=lmax; ++l)
00358     { alm(l,0).re=rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a4">rand_gauss</a>(); alm(l,0).im=0.; }
00359 
00360   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=1; m&lt;=mmax; ++m)
00361     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> l=m; l&lt;=lmax; ++l)
00362       { alm(l,m).re=rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a4">rand_gauss</a>(); alm(l,m).im=rng.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classplanck__rng.html#a4">rand_gauss</a>(); }
00363   }
00364 
00365 <span class="keywordtype">void</span> check_alm (<span class="keyword">const</span> <a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> &gt;&amp;oalm,
00366   <span class="keyword">const</span> <a class="code" href="classAlm.html">Alm</a>&lt;<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classxcomplex.html">xcomplex&lt;double&gt;</a> &gt;&amp;alm, <span class="keywordtype">double</span> epsilon)
00367   {
00368   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;=alm.Mmax(); ++m)
00369     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> l=m; l&lt;=alm.Lmax(); ++l)
00370       {
00371       <span class="keywordflow">if</span> (!<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__mathutilsgroup.html#gga1">abs_approx</a>(oalm(l,m).re,alm(l,m).re,epsilon))
00372         cout &lt;&lt; <span class="stringliteral">"Problemr "</span> &lt;&lt; l &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; m &lt;&lt; endl;
00373       <span class="keywordflow">if</span> (!<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__mathutilsgroup.html#gga1">abs_approx</a>(oalm(l,m).im,alm(l,m).im,epsilon))
00374         cout &lt;&lt; <span class="stringliteral">"Problemi "</span> &lt;&lt; l &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; m &lt;&lt;  endl;
00375       }
00376   }
00377 
00378 <span class="keywordtype">void</span> check_alm2map2alm (<span class="keywordtype">int</span> lmax, <span class="keywordtype">int</span> mmax, <span class="keywordtype">int</span> nside)
00379   {
00380   cout &lt;&lt; <span class="stringliteral">"testing whether a_lm-&gt;map-&gt;a_lm returns original a_lm"</span> &lt;&lt; endl;
00381   cout &lt;&lt; <span class="stringliteral">"lmax="</span> &lt;&lt; lmax &lt;&lt;<span class="stringliteral">", mmax="</span> &lt;&lt; mmax &lt;&lt; <span class="stringliteral">", nside="</span> &lt;&lt; nside &lt;&lt; endl;
00382   <span class="keyword">const</span> <span class="keywordtype">double</span> epsilon = 1e-8;
00383   <a class="code" href="classAlm.html">Alm&lt;xcomplex&lt;double&gt;</a> &gt; oalmT(lmax,mmax),almT(lmax,mmax),
00384     oalmG(lmax,mmax),almG(lmax,mmax),oalmC(lmax,mmax),almC(lmax,mmax);
00385   <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;double&gt;</a> mapT(nside,RING,SET_NSIDE), mapQ(nside,RING,SET_NSIDE),
00386     mapU(nside,RING,SET_NSIDE);
00387 
00388   random_alm(oalmT,oalmG,oalmC,lmax,mmax);
00389   <a class="code" href="group__alm__map__group.html#ga8">alm2map</a>(oalmT,mapT);
00390   map2alm_iter2(mapT,almT,1e-12,1e-12);
00391   check_alm (oalmT, almT, epsilon);
00392 
00393   <a class="code" href="group__alm__map__group.html#ga9">alm2map_pol</a>(oalmT,oalmG,oalmC,mapT,mapQ,mapU);
00394   map2alm_pol_iter2(mapT,mapQ,mapU,almT,almG,almC,1e-12,1e-12);
00395   check_alm (oalmT, almT, epsilon);
00396   check_alm (oalmG, almG, epsilon);
00397   check_alm (oalmC, almC, epsilon);
00398   }
00399 
00400 <span class="keywordtype">void</span> check_smooth_alm ()
00401   {
00402   cout &lt;&lt; <span class="stringliteral">"testing whether unsmooth(smooth(a_lm)) returns a_lm"</span> &lt;&lt; endl;
00403   <span class="keyword">const</span> <span class="keywordtype">double</span> epsilon = 1e-14;
00404   <span class="keyword">const</span> <span class="keywordtype">double</span> fwhm_arcmin = 100;
00405   <span class="keyword">const</span> <span class="keywordtype">int</span> lmax=300, mmax=300;
00406   <a class="code" href="classAlm.html">Alm&lt;xcomplex&lt;double&gt;</a> &gt; oalmT(lmax,mmax),almT(lmax,mmax),
00407     oalmG(lmax,mmax),almG(lmax,mmax),oalmC(lmax,mmax),almC(lmax,mmax);
00408 
00409   random_alm(oalmT,oalmG,oalmC,lmax,mmax);
00410 
00411   almT=oalmT; almG=oalmG; almC=oalmC;
00412   smooth_with_Gauss (almT, fwhm_arcmin);
00413   smooth_with_Gauss (almT, -fwhm_arcmin);
00414   check_alm (oalmT, almT, epsilon);
00415   almT=oalmT;
00416   smooth_with_Gauss (almT, almG, almC, fwhm_arcmin);
00417   smooth_with_Gauss (almT, almG, almC, -fwhm_arcmin);
00418   check_alm (oalmT, almT, epsilon);
00419   check_alm (oalmG, almG, epsilon);
00420   check_alm (oalmC, almC, epsilon);
00421   }
00422 
00423 <span class="keywordtype">void</span> check_rot_alm ()
00424   {
00425   cout &lt;&lt; <span class="stringliteral">"testing whether rot^-1(rot(a_lm)) returns a_lm"</span> &lt;&lt; endl;
00426   <span class="keyword">const</span> <span class="keywordtype">double</span> epsilon = 2e-13;
00427   <span class="keyword">const</span> <span class="keywordtype">int</span> lmax=300;
00428   <a class="code" href="classAlm.html">Alm&lt;xcomplex&lt;double&gt;</a> &gt; oalm(lmax,lmax),alm(lmax,lmax);
00429 
00430   random_alm(oalm,lmax,lmax);
00431 
00432   alm=oalm;
00433   rotate_alm (alm,3,4,5);
00434   rotate_alm (alm,-5,-4,-3);
00435   check_alm (oalm, alm, epsilon);
00436   }
00437 
00438 <span class="keywordtype">int</span> main()
00439   {
00440   check_smooth_alm();
00441   check_rot_alm();
00442   check_alm2map2alm(620,620,256);
00443   check_alm2map2alm(620,2,256);
00444   check_average();
00445   check_import();
00446   check_neighbors();
00447   check_pixangpix();
00448   check_angpixang();
00449   check_ringnestring();
00450   check_query_disc();
00451   check_swap_scheme();
00452   }
</pre></div><hr><address style="align: right;"><small>
Generated on Fri Jul 8 09:37:15 2005 for Healpix C++
</a> </small></address>
</body>
</html>
