<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>healpix_map.h Source File</title>
<link href="sheet.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>healpix_map.h</h1><a href="healpix__map_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> *  This file is part of Healpix_cxx.</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> *  Healpix_cxx is free software; you can redistribute it and/or modify</span>
00005 <span class="comment"> *  it under the terms of the GNU General Public License as published by</span>
00006 <span class="comment"> *  the Free Software Foundation; either version 2 of the License, or</span>
00007 <span class="comment"> *  (at your option) any later version.</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> *  Healpix_cxx is distributed in the hope that it will be useful,</span>
00010 <span class="comment"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00012 <span class="comment"> *  GNU General Public License for more details.</span>
00013 <span class="comment"> *</span>
00014 <span class="comment"> *  You should have received a copy of the GNU General Public License</span>
00015 <span class="comment"> *  along with Healpix_cxx; if not, write to the Free Software</span>
00016 <span class="comment"> *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
00017 <span class="comment"> *</span>
00018 <span class="comment"> *  For more information about HEALPix, see http://healpix.jpl.nasa.gov</span>
00019 <span class="comment"> */</span>
00020 
00021 <span class="comment">/*</span>
00022 <span class="comment"> *  Healpix_cxx is being developed at the Max-Planck-Institut fuer Astrophysik</span>
00023 <span class="comment"> *  and financially supported by the Deutsches Zentrum fuer Luft- und Raumfahrt</span>
00024 <span class="comment"> *  (DLR).</span>
00025 <span class="comment"> */</span>
00026 <span class="comment"></span>
00027 <span class="comment">/*! \file healpix_map.h</span>
00028 <span class="comment"> *  Copyright (C) 2003, 2004, 2005, 2006 Max-Planck-Society</span>
00029 <span class="comment"> *  \author Martin Reinecke</span>
00030 <span class="comment"> */</span>
00031 
00032 <span class="preprocessor">#ifndef HEALPIX_MAP_H</span>
00033 <span class="preprocessor"></span><span class="preprocessor">#define HEALPIX_MAP_H</span>
00034 <span class="preprocessor"></span>
00035 <span class="preprocessor">#include "<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/arr_8h.html">arr.h</a>"</span>
00036 <span class="preprocessor">#include "<a class="code" href="healpix__base_8h.html">healpix_base.h</a>"</span>
00037 <span class="comment"></span>
00038 <span class="comment">/*! A HEALPix map of a given datatype */</span>
<a name="l00039"></a><a class="code" href="classHealpix__Map.html">00039</a> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class </span><a class="code" href="classHealpix__Map.html">Healpix_Map</a>: <span class="keyword">public</span> <a class="code" href="classHealpix__Base.html">Healpix_Base</a>
00040   {
00041   <span class="keyword">private</span>:
00042     <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;T&gt;</a> map;
00043 
00044   <span class="keyword">public</span>:<span class="comment"></span>
00045 <span class="comment">    /*! Constructs an unallocated map. */</span>
<a name="l00046"></a><a class="code" href="classHealpix__Map.html#a0">00046</a>     <a class="code" href="classHealpix__Map.html#a0">Healpix_Map</a> () {}<span class="comment"></span>
00047 <span class="comment">    /*! Constructs a map with a given \a order and the ordering</span>
00048 <span class="comment">        scheme \a scheme. */</span>
<a name="l00049"></a><a class="code" href="classHealpix__Map.html#a1">00049</a>     <a class="code" href="classHealpix__Map.html#a0">Healpix_Map</a> (<span class="keywordtype">int</span> order, Healpix_Ordering_Scheme scheme)
00050       : <a class="code" href="classHealpix__Base.html">Healpix_Base</a> (order, scheme), map(npix_) {}<span class="comment"></span>
00051 <span class="comment">    /*! Constructs a map with a given \a nside and the ordering</span>
00052 <span class="comment">        scheme \a scheme. */</span>
<a name="l00053"></a><a class="code" href="classHealpix__Map.html#a2">00053</a>     <a class="code" href="classHealpix__Map.html#a0">Healpix_Map</a> (<span class="keywordtype">int</span> nside, Healpix_Ordering_Scheme scheme, <span class="keyword">const</span> nside_dummy)
00054       : <a class="code" href="classHealpix__Base.html">Healpix_Base</a> (nside, scheme, SET_NSIDE), map(npix_) {}<span class="comment"></span>
00055 <span class="comment">    /*! Constructs a map from the contents of \a data and sets the ordering</span>
00056 <span class="comment">        scheme to \a Scheme. The size of \a data must be a valid HEALPix</span>
00057 <span class="comment">        map size. */</span>
<a name="l00058"></a><a class="code" href="classHealpix__Map.html#a3">00058</a>     <a class="code" href="classHealpix__Map.html#a0">Healpix_Map</a> (<span class="keyword">const</span> <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;T&gt;</a> &amp;data, Healpix_Ordering_Scheme scheme)
00059       : <a class="code" href="classHealpix__Base.html">Healpix_Base</a> (<a class="code" href="classHealpix__Base.html#e1">npix2nside</a>(data.size()), scheme, SET_NSIDE), map(data) {}
00060 <span class="comment"></span>
00061 <span class="comment">    /*! Deletes the old map, creates a map from the contents of \a data and</span>
00062 <span class="comment">        sets the ordering scheme to \a scheme. The size of \a data must be a</span>
00063 <span class="comment">        valid HEALPix map size. */</span>
<a name="l00064"></a><a class="code" href="classHealpix__Map.html#a4">00064</a>     <span class="keywordtype">void</span> <a class="code" href="classHealpix__Map.html#a4">Set</a> (<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;T&gt;</a> &amp;data, Healpix_Ordering_Scheme scheme)
00065       {
00066       Healpix_Base::SetNside(<a class="code" href="classHealpix__Base.html#e1">npix2nside</a> (data.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html#a6">size</a>()), scheme);
00067       map.transfer(data);
00068       }
00069 <span class="comment"></span>
00070 <span class="comment">    /*! Deletes the old map and creates a new map  with a given \a order</span>
00071 <span class="comment">        and the ordering scheme \a scheme. */</span>
<a name="l00072"></a><a class="code" href="classHealpix__Map.html#a5">00072</a>     <span class="keywordtype">void</span> <a class="code" href="classHealpix__Map.html#a4">Set</a> (<span class="keywordtype">int</span> order, Healpix_Ordering_Scheme scheme)
00073       {
00074       Healpix_Base::Set(order, scheme);
00075       map.alloc(npix_);
00076       }<span class="comment"></span>
00077 <span class="comment">    /*! Deletes the old map and creates a new map  with a given \a nside</span>
00078 <span class="comment">        and the ordering scheme \a scheme. */</span>
<a name="l00079"></a><a class="code" href="classHealpix__Map.html#a6">00079</a>     <span class="keywordtype">void</span> <a class="code" href="classHealpix__Map.html#a6">SetNside</a> (<span class="keywordtype">int</span> nside, Healpix_Ordering_Scheme scheme)
00080       {
00081       Healpix_Base::SetNside(nside, scheme);
00082       map.alloc(npix_);
00083       }
00084 <span class="comment"></span>
00085 <span class="comment">    /*! Fills the map with \a val. */</span>
<a name="l00086"></a><a class="code" href="classHealpix__Map.html#a7">00086</a>     <span class="keywordtype">void</span> <a class="code" href="classHealpix__Map.html#a7">fill</a> (<span class="keyword">const</span> T &amp;val)
00087       { map.fill(val); }
00088 <span class="comment"></span>
00089 <span class="comment">    /*! Imports the map \a orig into the current map, adjusting the</span>
00090 <span class="comment">        ordering scheme. \a orig must have the same resolution as the</span>
00091 <span class="comment">        current map. */</span>
<a name="l00092"></a><a class="code" href="classHealpix__Map.html#a8">00092</a>     <span class="keywordtype">void</span> <a class="code" href="classHealpix__Map.html#a8">Import_nograde</a> (<span class="keyword">const</span> <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;T&gt;</a> &amp;orig)
00093       {
00094       <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__assertgroup.html#a1">planck_assert</a> (<a class="code" href="classHealpix__Base.html#p1">nside_</a>==orig.<a class="code" href="classHealpix__Base.html#p1">nside_</a>,
00095         <span class="stringliteral">"Import_nograde: maps have different nside"</span>);
00096       <span class="keywordflow">if</span> (orig.<a class="code" href="classHealpix__Base.html#p7">scheme_</a> == <a class="code" href="classHealpix__Base.html#p7">scheme_</a>)
00097         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;npix_; ++m) map[m] = orig.<a class="code" href="classHealpix__Map.html#r0">map</a>[m];
00098       <span class="keywordflow">else</span>
00099         {
00100         swapfunc swapper = (<a class="code" href="classHealpix__Base.html#p7">scheme_</a> == <a class="code" href="healpix__base_8h.html#a3a2">NEST</a>) ?
00101           &amp;<a class="code" href="classHealpix__Base.html#a8">Healpix_Base::ring2nest</a> : &amp;<a class="code" href="classHealpix__Base.html#a7">Healpix_Base::nest2ring</a>;
00102 <span class="preprocessor">#pragma omp parallel</span>
00103 <span class="preprocessor"></span>{
00104         <span class="keywordtype">int</span> m;
00105 <span class="preprocessor">#pragma omp for schedule (dynamic,5000)</span>
00106 <span class="preprocessor"></span>        <span class="keywordflow">for</span> (m=0; m&lt;npix_; ++m) map[(this-&gt;*swapper)(m)] = orig.<a class="code" href="classHealpix__Map.html#r0">map</a>[m];
00107 }
00108         }
00109       }
00110 <span class="comment"></span>
00111 <span class="comment">    /*! Imports the map \a orig into the current map, adjusting the</span>
00112 <span class="comment">        ordering scheme and the map resolution. \a orig must have higher</span>
00113 <span class="comment">        resolution than the current map. */</span>
<a name="l00114"></a><a class="code" href="classHealpix__Map.html#a9">00114</a>     <span class="keywordtype">void</span> <a class="code" href="classHealpix__Map.html#a9">Import_upgrade</a> (<span class="keyword">const</span> <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;T&gt;</a> &amp;orig)
00115       {
00116       <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__assertgroup.html#a1">planck_assert</a>(<a class="code" href="classHealpix__Base.html#p1">nside_</a>&gt;orig.<a class="code" href="classHealpix__Base.html#p1">nside_</a>,<span class="stringliteral">"Import_upgrade: this is no upgrade"</span>);
00117       <span class="keywordtype">int</span> fact = <a class="code" href="classHealpix__Base.html#p1">nside_</a>/orig.<a class="code" href="classHealpix__Base.html#p1">nside_</a>;
00118       <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__assertgroup.html#a1">planck_assert</a> (<a class="code" href="classHealpix__Base.html#p1">nside_</a>==orig.<a class="code" href="classHealpix__Base.html#p1">nside_</a>*fact,
00119         <span class="stringliteral">"the larger Nside must be a multiple of the smaller one"</span>);
00120       pix2xyf to_xyf = (orig.<a class="code" href="classHealpix__Base.html#p7">scheme_</a>==<a class="code" href="healpix__base_8h.html#a3a1">RING</a>) ?
00121         &amp;Healpix_Map::ring2xyf : &amp;Healpix_Map::nest2xyf;
00122       xyf2pix from_xyf = (<a class="code" href="classHealpix__Base.html#p7">scheme_</a>==<a class="code" href="healpix__base_8h.html#a3a1">RING</a>) ?
00123         &amp;Healpix_Map::xyf2ring : &amp;Healpix_Map::xyf2nest;
00124 
00125 <span class="preprocessor">#pragma omp parallel</span>
00126 <span class="preprocessor"></span>{
00127       <span class="keywordtype">int</span> m;
00128 <span class="preprocessor">#pragma omp for schedule (dynamic,5000)</span>
00129 <span class="preprocessor"></span>      <span class="keywordflow">for</span> (m=0; m&lt;orig.<a class="code" href="classHealpix__Base.html#p4">npix_</a>; ++m)
00130         {
00131         <span class="keywordtype">int</span> x,y,f;
00132         (orig.*to_xyf)(m,x,y,f);
00133         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=fact*y; j&lt;fact*(y+1); ++j)
00134           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=fact*x; i&lt;fact*(x+1); ++i)
00135             {
00136             <span class="keywordtype">int</span> mypix = (this-&gt;*from_xyf)(i,j,f);
00137             map[mypix] = orig.<a class="code" href="classHealpix__Map.html#r0">map</a>[m];
00138             }
00139         }
00140 }
00141       }
00142 <span class="comment"></span>
00143 <span class="comment">    /*! Imports the map \a orig into the current map, adjusting the</span>
00144 <span class="comment">        ordering scheme and the map resolution. \a orig must have higher</span>
00145 <span class="comment">        resolution than the current map.</span>
00146 <span class="comment">        \a pessimistic determines whether or not</span>
00147 <span class="comment">        pixels are set to \a Healpix_undef when not all of the corresponding</span>
00148 <span class="comment">        high-resolution pixels are defined.</span>
00149 <span class="comment"></span>
00150 <span class="comment">        This method is instantiated for \a float and \a double only. */</span>
00151     <span class="keywordtype">void</span> <a class="code" href="classHealpix__Map.html#a10">Import_degrade</a> (<span class="keyword">const</span> <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;T&gt;</a> &amp;orig, <span class="keywordtype">bool</span> pessimistic=<span class="keyword">false</span>);
00152 <span class="comment"></span>
00153 <span class="comment">    /*! Imports the map \a orig into the current map, adjusting the</span>
00154 <span class="comment">        ordering scheme and the map resolution if necessary.</span>
00155 <span class="comment">        When downgrading, \a pessimistic determines whether or not</span>
00156 <span class="comment">        pixels are set to \a Healpix_undef when not all of the corresponding</span>
00157 <span class="comment">        high-resolution pixels are defined.</span>
00158 <span class="comment"></span>
00159 <span class="comment">        This method is instantiated for \a float and \a double only. */</span>
<a name="l00160"></a><a class="code" href="classHealpix__Map.html#a11">00160</a>     <span class="keywordtype">void</span> <a class="code" href="classHealpix__Map.html#a11">Import</a> (<span class="keyword">const</span> <a class="code" href="classHealpix__Map.html">Healpix_Map&lt;T&gt;</a> &amp;orig, <span class="keywordtype">bool</span> pessimistic=<span class="keyword">false</span>)
00161       {
00162       <span class="keywordflow">if</span> (orig.<a class="code" href="classHealpix__Base.html#p1">nside_</a> == <a class="code" href="classHealpix__Base.html#p1">nside_</a>) <span class="comment">// no up/degrading</span>
00163         <a class="code" href="classHealpix__Map.html#a8">Import_nograde</a>(orig);
00164       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (orig.<a class="code" href="classHealpix__Base.html#p1">nside_</a> &lt; <a class="code" href="classHealpix__Base.html#p1">nside_</a>) <span class="comment">// upgrading</span>
00165         <a class="code" href="classHealpix__Map.html#a9">Import_upgrade</a>(orig);
00166       <span class="keywordflow">else</span>
00167         <a class="code" href="classHealpix__Map.html#a10">Import_degrade</a>(orig,pessimistic);
00168       }
00169 <span class="comment"></span>
00170 <span class="comment">    /*! Returns a constant reference to the pixel with the number \a pix. */</span>
<a name="l00171"></a><a class="code" href="classHealpix__Map.html#a12">00171</a>     <span class="keyword">const</span> T &amp;<a class="code" href="classHealpix__Map.html#a12">operator[] </a>(<span class="keywordtype">int</span> pix)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> map[pix]; }<span class="comment"></span>
00172 <span class="comment">    /*! Returns a reference to the pixel with the number \a pix. */</span>
<a name="l00173"></a><a class="code" href="classHealpix__Map.html#a13">00173</a>     T &amp;<a class="code" href="classHealpix__Map.html#a12">operator[] </a>(<span class="keywordtype">int</span> pix) { <span class="keywordflow">return</span> map[pix]; }
00174 <span class="comment"></span>
00175 <span class="comment">    /*! Swaps the map ordering from RING to NEST and vice versa.</span>
00176 <span class="comment">        This is done in-place (i.e. with negligible space overhead). */</span>
<a name="l00177"></a><a class="code" href="classHealpix__Map.html#a14">00177</a>     <span class="keywordtype">void</span> <a class="code" href="classHealpix__Map.html#a14">swap_scheme</a>()
00178       {
00179       <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> clen[] = { 0,7,5,4,12,10,13,18,14,19,18,17,27,21 };
00180       <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> cycle[][30] = {
00181         { },
00182         { 0,1,8,12,16,21,40 },
00183         { 0,1,2,40,114 },
00184         { 0,4,160,263 },
00185         { 0,4,30,49,51,87,526,1027,1105,1387,1807,2637 },
00186         { 0,8,10,18,39,74,146,307,452,4737 },
00187         { 0,1,2,7,9,17,80,410,1526,1921,32859,33566,38931 },
00188         { 0,5,6,10,12,24,27,95,372,494,924,1409,3492,4248,9137,66043,103369,
00189           156899 },
00190         { 0,1,2,3,4,45,125,351,697,24337,102940,266194,341855,419857 },
00191         { 0,1,2,3,9,16,1705,2082,2126,8177,12753,15410,52642,80493,83235,
00192           88387,99444,1675361,2495125 },
00193         { 0,2,6,8,9,11,20,50,93,152,183,2137,13671,44794,486954,741908,
00194           4803258,5692573 },
00195         { 0,1,5,6,44,53,470,2847,3433,4906,13654,14710,400447,1797382,
00196           2744492,18775974,23541521 },
00197         { 0,4,9,10,16,33,83,117,318,451,5759,10015,128975,171834,211256,
00198           347608,1278690,2154097,2590798,3427694,5581717,21012301,27023976,
00199           72522811,95032729,139166747,171822389 },
00200         { 0,5,10,267,344,363,2968,3159,9083,18437,76602,147614,1246902,
00201           1593138,2035574,6529391,9511830,11340287,29565945,281666026,
00202           677946848 } };
00203 
00204       swapfunc swapper = (<a class="code" href="classHealpix__Base.html#p7">scheme_</a> == <a class="code" href="healpix__base_8h.html#a3a2">NEST</a>) ?
00205         &amp;<a class="code" href="classHealpix__Base.html#a8">Healpix_Base::ring2nest</a> : &amp;<a class="code" href="classHealpix__Base.html#a7">Healpix_Base::nest2ring</a>;
00206 
00207       <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__assertgroup.html#a1">planck_assert</a> (<a class="code" href="classHealpix__Base.html#p0">order_</a>&gt;=0, <span class="stringliteral">"swap_scheme(): need hierarchical map"</span>);
00208 
00209       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;clen[<a class="code" href="classHealpix__Base.html#p0">order_</a>]; ++m)
00210         {
00211         <span class="keywordtype">int</span> istart = cycle[<a class="code" href="classHealpix__Base.html#p0">order_</a>][m];
00212 
00213         T pixbuf = map[istart];
00214         <span class="keywordtype">int</span> iold = istart, inew = (this-&gt;*swapper)(istart);
00215         <span class="keywordflow">while</span> (inew != istart)
00216           {
00217           map[iold] = map[inew];
00218           iold = inew;
00219           inew = (this-&gt;*swapper)(inew);
00220           }
00221         map[iold] = pixbuf;
00222         }
00223       scheme_ = (scheme_==<a class="code" href="healpix__base_8h.html#a3a1">RING</a>) ? <a class="code" href="healpix__base_8h.html#a3a2">NEST</a> : <a class="code" href="healpix__base_8h.html#a3a1">RING</a>;
00224       }
00225 <span class="comment"></span>
00226 <span class="comment">    /*! performs the actual interpolation using \a pix and \a wgt. */</span>
<a name="l00227"></a><a class="code" href="classHealpix__Map.html#a15">00227</a>     T <a class="code" href="classHealpix__Map.html#a15">interpolation</a> (<span class="keyword">const</span> <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classfix__arr.html">fix_arr&lt;int,4&gt;</a> &amp;pix,
00228       <span class="keyword">const</span> <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classfix__arr.html">fix_arr&lt;double,4&gt;</a> &amp;wgt)<span class="keyword"> const</span>
00229 <span class="keyword">      </span>{
00230       <span class="keywordflow">return</span> map[pix[0]]*wgt[0] + map[pix[1]]*wgt[1]
00231            + map[pix[2]]*wgt[2] + map[pix[3]]*wgt[3];
00232       }<span class="comment"></span>
00233 <span class="comment">    /*! Returns the interpolated map value at \a ptg */</span>
<a name="l00234"></a><a class="code" href="classHealpix__Map.html#a16">00234</a>     T <a class="code" href="classHealpix__Map.html#a16">interpolated_value</a> (<span class="keyword">const</span> <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classpointing.html">pointing</a> &amp;ptg)<span class="keyword"> const</span>
00235 <span class="keyword">      </span>{
00236       <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classfix__arr.html">fix_arr&lt;int,4&gt;</a> pix;
00237       <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classfix__arr.html">fix_arr&lt;double,4&gt;</a> wgt;
00238       <a class="code" href="classHealpix__Base.html#a22">get_interpol</a> (ptg, pix, wgt);
00239       <span class="keywordflow">return</span> <a class="code" href="classHealpix__Map.html#a15">interpolation</a> (pix, wgt);
00240       }
00241 <span class="comment"></span>
00242 <span class="comment">    /*! Returns a constant reference to the map data. */</span>
<a name="l00243"></a><a class="code" href="classHealpix__Map.html#a17">00243</a>     <span class="keyword">const</span> <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classarr.html">arr&lt;T&gt;</a> &amp;<a class="code" href="classHealpix__Map.html#a17">Map</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> map; }
00244 <span class="comment"></span>
00245 <span class="comment">    /*! Returns the minimum and maximum value of the map in</span>
00246 <span class="comment">        \a Min and \a Max.</span>
00247 <span class="comment"></span>
00248 <span class="comment">        This method is instantiated for \a float and \a double only. */</span>
00249     <span class="keywordtype">void</span> <a class="code" href="classHealpix__Map.html#a18">minmax</a> (T &amp;Min, T &amp;Max) <span class="keyword">const</span>;
00250 <span class="comment"></span>
00251 <span class="comment">    /*! Swaps the contents of two Healpix_Map objects. */</span>
<a name="l00252"></a><a class="code" href="classHealpix__Map.html#a19">00252</a>     <span class="keywordtype">void</span> <a class="code" href="classHealpix__Map.html#a19">swap</a> (<a class="code" href="classHealpix__Map.html">Healpix_Map</a> &amp;other)
00253       {
00254       <a class="code" href="classHealpix__Base.html#a28">Healpix_Base::swap</a>(other);
00255       map.swap(other.<a class="code" href="classHealpix__Map.html#r0">map</a>);
00256       }
00257 <span class="comment"></span>
00258 <span class="comment">    /*! Returns the average of all defined map pixels. */</span>
<a name="l00259"></a><a class="code" href="classHealpix__Map.html#a20">00259</a>     <span class="keywordtype">double</span> <a class="code" href="classHealpix__Map.html#a20">average</a>()<span class="keyword"> const</span>
00260 <span class="keyword">      </span>{
00261       <span class="keywordtype">double</span> avg=0;
00262       <span class="keywordtype">int</span> pix=0;
00263       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;npix_; ++m)
00264         <span class="keywordflow">if</span> (!approx&lt;double&gt;(map[m],<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/lsconstants_8h.html#a30">Healpix_undef</a>))
00265           { ++pix; avg+=map[m]; }
00266       <span class="keywordflow">return</span> avg/pix;
00267       }
00268 <span class="comment"></span>
00269 <span class="comment">    /*! Adds \a val to all defined map pixels. */</span>
<a name="l00270"></a><a class="code" href="classHealpix__Map.html#a21">00270</a>     <span class="keywordtype">void</span> <a class="code" href="classHealpix__Map.html#a21">add</a> (T val)
00271       {
00272       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;npix_; ++m)
00273         <span class="keywordflow">if</span> (!approx&lt;double&gt;(map[m],<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/lsconstants_8h.html#a30">Healpix_undef</a>))
00274           { map[m]+=val; }
00275       }
00276 <span class="comment"></span>
00277 <span class="comment">    /*! Returns the root mean square of the map, not counting undefined</span>
00278 <span class="comment">        pixels. */</span>
<a name="l00279"></a><a class="code" href="classHealpix__Map.html#a22">00279</a>     <span class="keywordtype">double</span> <a class="code" href="classHealpix__Map.html#a22">rms</a>()<span class="keyword"> const</span>
00280 <span class="keyword">      </span>{
00281       <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00282 
00283       <span class="keywordtype">double</span> result=0;
00284       <span class="keywordtype">int</span> pix=0;
00285       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;npix_; ++m)
00286         <span class="keywordflow">if</span> (!approx&lt;double&gt;(map[m],<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/lsconstants_8h.html#a30">Healpix_undef</a>))
00287           { ++pix; result+=map[m]*map[m]; }
00288       <span class="keywordflow">return</span> sqrt(result/pix);
00289       }<span class="comment"></span>
00290 <span class="comment">    /*! Returns the maximum absolute value in the map, ignoring undefined</span>
00291 <span class="comment">        pixels. */</span>
<a name="l00292"></a><a class="code" href="classHealpix__Map.html#a23">00292</a>     T <a class="code" href="classHealpix__Map.html#a23">absmax</a>()<span class="keyword"> const</span>
00293 <span class="keyword">      </span>{
00294       <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00295 
00296       T result=0;
00297       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;npix_; ++m)
00298         <span class="keywordflow">if</span> (!approx&lt;double&gt;(map[m],<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/lsconstants_8h.html#a30">Healpix_undef</a>))
00299           { result = max(result,abs(map[m])); }
00300       <span class="keywordflow">return</span> result;
00301       }
00302   };
00303 
00304 <span class="preprocessor">#endif</span>
</pre></div><hr><address style="align: right;"><small>
Generated on Thu Nov 13 18:48:51 2008 for Healpix C++
</a> </small></address>
</body>
</html>
