<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>healpix_base2.cc Source File</title>
<link href="sheet.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>healpix_base2.cc</h1><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> *  This file is part of Healpix_cxx.</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> *  Healpix_cxx is free software; you can redistribute it and/or modify</span>
00005 <span class="comment"> *  it under the terms of the GNU General Public License as published by</span>
00006 <span class="comment"> *  the Free Software Foundation; either version 2 of the License, or</span>
00007 <span class="comment"> *  (at your option) any later version.</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> *  Healpix_cxx is distributed in the hope that it will be useful,</span>
00010 <span class="comment"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00012 <span class="comment"> *  GNU General Public License for more details.</span>
00013 <span class="comment"> *</span>
00014 <span class="comment"> *  You should have received a copy of the GNU General Public License</span>
00015 <span class="comment"> *  along with Healpix_cxx; if not, write to the Free Software</span>
00016 <span class="comment"> *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
00017 <span class="comment"> *</span>
00018 <span class="comment"> *  For more information about HEALPix, see http://healpix.jpl.nasa.gov</span>
00019 <span class="comment"> */</span>
00020 
00021 <span class="comment">/*</span>
00022 <span class="comment"> *  Healpix_cxx is being developed at the Max-Planck-Institut fuer Astrophysik</span>
00023 <span class="comment"> *  and financially supported by the Deutsches Zentrum fuer Luft- und Raumfahrt</span>
00024 <span class="comment"> *  (DLR).</span>
00025 <span class="comment"> */</span>
00026 
00027 <span class="comment">/*</span>
00028 <span class="comment"> *  Copyright (C) 2003, 2004, 2005, 2006 Max-Planck-Society</span>
00029 <span class="comment"> *  Author: Martin Reinecke</span>
00030 <span class="comment"> */</span>
00031 
00032 <span class="preprocessor">#include "<a class="code" href="healpix__base2_8h.html">healpix_base2.h</a>"</span>
00033 <span class="preprocessor">#include "<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/cxxutils_8h.html">cxxutils.h</a>"</span>
00034 <span class="preprocessor">#include "<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/pointing_8h.html">pointing.h</a>"</span>
00035 <span class="preprocessor">#include "<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/arr_8h.html">arr.h</a>"</span>
00036 <span class="preprocessor">#include "<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/geom__utils_8h.html">geom_utils.h</a>"</span>
00037 
00038 <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00039 
00040 <span class="keywordtype">short</span> Healpix_Base2::ctab[];
00041 <span class="keywordtype">short</span> Healpix_Base2::utab[];
00042 
00043 Healpix_Base2::Tablefiller::Tablefiller()
00044   {
00045   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;0x100; ++m)
00046     {
00047     ctab[m] =
00048          (m&amp;0x1 )       | ((m&amp;0x2 ) &lt;&lt; 7) | ((m&amp;0x4 ) &gt;&gt; 1) | ((m&amp;0x8 ) &lt;&lt; 6)
00049       | ((m&amp;0x10) &gt;&gt; 2) | ((m&amp;0x20) &lt;&lt; 5) | ((m&amp;0x40) &gt;&gt; 3) | ((m&amp;0x80) &lt;&lt; 4);
00050     utab[m] =
00051          (m&amp;0x1 )       | ((m&amp;0x2 ) &lt;&lt; 1) | ((m&amp;0x4 ) &lt;&lt; 2) | ((m&amp;0x8 ) &lt;&lt; 3)
00052       | ((m&amp;0x10) &lt;&lt; 4) | ((m&amp;0x20) &lt;&lt; 5) | ((m&amp;0x40) &lt;&lt; 6) | ((m&amp;0x80) &lt;&lt; 7);
00053     }
00054   }
00055 
00056 Healpix_Base2::Tablefiller Healpix_Base2::Filler;
00057 
00058 <span class="keyword">const</span> <span class="keywordtype">int</span> Healpix_Base2::jrll[] = { 2,2,2,2,3,3,3,3,4,4,4,4 };
00059 <span class="keyword">const</span> <span class="keywordtype">int</span> Healpix_Base2::jpll[] = { 1,3,5,7,0,2,4,6,1,3,5,7 };
00060 
<a name="l00061"></a><a class="code" href="classHealpix__Base2.html#e1">00061</a> int64 <a class="code" href="classHealpix__Base2.html#e1">Healpix_Base2::npix2nside</a> (int64 npix)
00062   {
00063   int64 res=<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__mathutilsgroup.html#a8">isqrt</a>(npix/12);
00064   <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__assertgroup.html#a1">planck_assert</a> (npix==res*res*12, <span class="stringliteral">"npix2nside: invalid argument"</span>);
00065   <span class="keywordflow">return</span> res;
00066   }
00067 
00068 <span class="keywordtype">void</span> Healpix_Base2::nest2xyf (int64 pix, <span class="keywordtype">int</span> &amp;ix, <span class="keywordtype">int</span> &amp;iy, <span class="keywordtype">int</span> &amp;face_num)
00069   <span class="keyword">const</span>
00070   {
00071   face_num = pix&gt;&gt;(2*order_);
00072   pix &amp;= (npface_-1);
00073   int32 raw = ((pix&amp;0x555500000000ull)&gt;&gt;16) 
00074              | ((pix&amp;0x5555000000000000ull)&gt;&gt;31)
00075              | (pix&amp;0x5555)
00076              | ((pix&amp;0x55550000)&gt;&gt;15);
00077   ix =  ctab[raw&amp;0xff]
00078      | (ctab[(raw&gt;&gt;8)&amp;0xff]&lt;&lt;4)
00079      | (ctab[(raw&gt;&gt;16)&amp;0xff]&lt;&lt;16)
00080      | (ctab[(raw&gt;&gt;24)&amp;0xff]&lt;&lt;20);
00081   pix &gt;&gt;= 1;
00082   raw = ((pix&amp;0x555500000000ull)&gt;&gt;16) 
00083              | ((pix&amp;0x5555000000000000ull)&gt;&gt;31)
00084              | (pix&amp;0x5555)
00085              | ((pix&amp;0x55550000)&gt;&gt;15);
00086   iy =  ctab[raw&amp;0xff]
00087      | (ctab[(raw&gt;&gt;8)&amp;0xff]&lt;&lt;4)
00088      | (ctab[(raw&gt;&gt;16)&amp;0xff]&lt;&lt;16)
00089      | (ctab[(raw&gt;&gt;24)&amp;0xff]&lt;&lt;20);
00090   }
00091 
00092 int64 Healpix_Base2::xyf2nest (<span class="keywordtype">int</span> ix, <span class="keywordtype">int</span> iy, <span class="keywordtype">int</span> face_num)<span class="keyword"> const</span>
00093 <span class="keyword">  </span>{
00094   <span class="keywordflow">return</span> (int64(face_num)&lt;&lt;(2*<a class="code" href="classHealpix__Base2.html#p0">order_</a>)) +
00095     (   (int64(utab[ ix     &amp;0xff]))
00096       | (int64(utab[(ix&gt;&gt; 8)&amp;0xff])&lt;&lt;16)
00097       | (int64(utab[(ix&gt;&gt;16)&amp;0xff])&lt;&lt;32)
00098       | (int64(utab[(ix&gt;&gt;24)&amp;0xff])&lt;&lt;48)
00099       | (int64(utab[ iy     &amp;0xff])&lt;&lt;1)
00100       | (int64(utab[(iy&gt;&gt; 8)&amp;0xff])&lt;&lt;17)
00101       | (int64(utab[(iy&gt;&gt;16)&amp;0xff])&lt;&lt;33)
00102       | (int64(utab[(iy&gt;&gt;24)&amp;0xff])&lt;&lt;49) ); 
00103   }
00104 
00105 <span class="keywordtype">void</span> Healpix_Base2::ring2xyf (int64 pix, <span class="keywordtype">int</span> &amp;ix, <span class="keywordtype">int</span> &amp;iy, <span class="keywordtype">int</span> &amp;face_num)
00106   <span class="keyword">const</span>
00107   {
00108   int64 iring, iphi, kshift, nr;
00109 
00110   int64 nl2 = 2*nside_;
00111 
00112   <span class="keywordflow">if</span> (pix&lt;ncap_) <span class="comment">// North Polar cap</span>
00113     {
00114     iring = int64(0.5*(1+<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__mathutilsgroup.html#a8">isqrt</a>(1+2*pix))); <span class="comment">//counted from North pole</span>
00115     iphi  = (pix+1) - 2*iring*(iring-1);
00116     kshift = 0;
00117     nr = iring;
00118     face_num=0;
00119     int64 tmp = iphi-1;
00120     <span class="keywordflow">if</span> (tmp&gt;=(2*iring))
00121       {
00122       face_num=2;
00123       tmp-=2*iring;
00124       }
00125     <span class="keywordflow">if</span> (tmp&gt;=iring) ++face_num;
00126     }
00127   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pix&lt;(npix_-ncap_)) <span class="comment">// Equatorial region</span>
00128     {
00129     int64 ip = pix - ncap_;
00130     <span class="keywordflow">if</span> (order_&gt;=0)
00131       {
00132       iring = (ip&gt;&gt;(order_+2)) + nside_; <span class="comment">// counted from North pole</span>
00133       iphi  = (ip&amp;(4*nside_-1)) + 1;
00134       }
00135     <span class="keywordflow">else</span>
00136       {
00137       iring = (ip/(4*nside_)) + nside_; <span class="comment">// counted from North pole</span>
00138       iphi  = (ip%(4*nside_)) + 1;
00139       }
00140     kshift = (iring+nside_)&amp;1;
00141     nr = nside_;
00142     int64 ire = iring-nside_+1;
00143     int64 irm = nl2+2-ire;
00144     int64 ifm, ifp;
00145     <span class="keywordflow">if</span> (order_&gt;=0)
00146       {
00147       ifm = (iphi - ire/2 + nside_ -1) &gt;&gt; order_;
00148       ifp = (iphi - irm/2 + nside_ -1) &gt;&gt; order_;
00149       }
00150     <span class="keywordflow">else</span>
00151       {
00152       ifm = (iphi - ire/2 + nside_ -1) / nside_;
00153       ifp = (iphi - irm/2 + nside_ -1) / nside_;
00154       }
00155     <span class="keywordflow">if</span> (ifp == ifm) <span class="comment">// faces 4 to 7</span>
00156       face_num = (ifp==4) ? 4 : ifp+4;
00157     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ifp&lt;ifm) <span class="comment">// (half-)faces 0 to 3</span>
00158       face_num = ifp;
00159     <span class="keywordflow">else</span> <span class="comment">// (half-)faces 8 to 11</span>
00160       face_num = ifm + 8;
00161     }
00162   <span class="keywordflow">else</span> <span class="comment">// South Polar cap</span>
00163     {
00164     int64 ip = npix_ - pix;
00165     iring = int64(0.5*(1+<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__mathutilsgroup.html#a8">isqrt</a>(2*ip-1))); <span class="comment">//counted from South pole</span>
00166     iphi  = 4*iring + 1 - (ip - 2*iring*(iring-1));
00167     kshift = 0;
00168     nr = iring;
00169     iring = 2*nl2-iring;
00170     face_num=8;
00171     int64 tmp = iphi-1;
00172     <span class="keywordflow">if</span> (tmp&gt;=(2*nr))
00173       {
00174       face_num=10;
00175       tmp-=2*nr;
00176       }
00177     <span class="keywordflow">if</span> (tmp&gt;=nr) ++face_num;
00178     }
00179 
00180   int64 irt = iring - (jrll[face_num]*nside_) + 1;
00181   int64 ipt = 2*iphi- jpll[face_num]*nr - kshift -1;
00182   <span class="keywordflow">if</span> (ipt&gt;=nl2) ipt-=8*nside_;
00183 
00184   ix =  (ipt-irt) &gt;&gt;1;
00185   iy =(-(ipt+irt))&gt;&gt;1;
00186   }
00187 
00188 int64 Healpix_Base2::xyf2ring (<span class="keywordtype">int</span> ix, <span class="keywordtype">int</span> iy, <span class="keywordtype">int</span> face_num)<span class="keyword"> const</span>
00189 <span class="keyword">  </span>{
00190   int64 nl4 = 4*nside_;
00191   int64 jr = (jrll[face_num]*nside_) - ix - iy  - 1;
00192 
00193   int64 nr, kshift, n_before;
00194   <span class="keywordflow">if</span> (jr&lt;nside_)
00195     {
00196     nr = jr;
00197     n_before = 2*nr*(nr-1);
00198     kshift = 0;
00199     }
00200   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (jr &gt; 3*nside_)
00201     {
00202     nr = nl4-jr;
00203     n_before = npix_ - 2*(nr+1)*nr;
00204     kshift = 0;
00205     }
00206   <span class="keywordflow">else</span>
00207     {
00208     nr = nside_;
00209     n_before = ncap_ + (jr-nside_)*nl4;
00210     kshift = (jr-nside_)&amp;1;
00211     }
00212 
00213   int64 jp = (jpll[face_num]*nr + ix - iy + 1 + kshift) / 2;
00214   <span class="keywordflow">if</span> (jp&gt;nl4)
00215     jp-=nl4;
00216   <span class="keywordflow">else</span>
00217     <span class="keywordflow">if</span> (jp&lt;1) jp+=nl4;
00218 
00219   <span class="keywordflow">return</span> n_before + jp - 1;
00220   }
00221 
<a name="l00222"></a><a class="code" href="classHealpix__Base2.html#a5">00222</a> <span class="keywordtype">double</span> <a class="code" href="classHealpix__Base2.html#a5">Healpix_Base2::ring2z</a> (int64 ring)<span class="keyword"> const</span>
00223 <span class="keyword">  </span>{
00224   <span class="keywordflow">if</span> (ring&lt;nside_)
00225     <span class="keywordflow">return</span> 1 - ring*ring*fact2_;
00226   <span class="keywordflow">if</span> (ring &lt;=3*nside_)
00227     <span class="keywordflow">return</span> (2*nside_-ring)*fact1_;
00228   ring=4*nside_ - ring;
00229   <span class="keywordflow">return</span> ring*ring*fact2_ - 1;
00230   }
00231 
<a name="l00232"></a><a class="code" href="classHealpix__Base2.html#a6">00232</a> int64 <a class="code" href="classHealpix__Base2.html#a6">Healpix_Base2::pix2ring</a> (int64 pix)<span class="keyword"> const</span>
00233 <span class="keyword">  </span>{
00234   <span class="keywordflow">if</span> (<a class="code" href="classHealpix__Base2.html#p7">scheme_</a>==<a class="code" href="healpix__base_8h.html#a3a1">RING</a>)
00235     {
00236     <span class="keywordflow">if</span> (pix&lt;ncap_) <span class="comment">// North Polar cap</span>
00237       <span class="keywordflow">return</span> int64(0.5*(1+<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__mathutilsgroup.html#a8">isqrt</a>(1+2*pix))); <span class="comment">//counted from North pole</span>
00238     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pix&lt;(npix_-ncap_)) <span class="comment">// Equatorial region</span>
00239       {
00240       int64 ip  = pix - ncap_;
00241       <span class="keywordflow">return</span> ip/(4*nside_) + nside_; <span class="comment">// counted from North pole</span>
00242       }
00243     <span class="keywordflow">else</span> <span class="comment">// South Polar cap</span>
00244       {
00245       int64 ip = npix_ - pix;
00246       <span class="keywordflow">return</span> 4*nside_ - int64(0.5*(1+<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__mathutilsgroup.html#a8">isqrt</a>(2*ip-1))); <span class="comment">//counted from South pole</span>
00247       }
00248     }
00249   <span class="keywordflow">else</span>
00250     {
00251     <span class="keywordtype">int</span> face_num, ix, iy;
00252     nest2xyf(pix,ix,iy,face_num);
00253     <span class="keywordflow">return</span> (int64(jrll[face_num])&lt;&lt;<a class="code" href="classHealpix__Base2.html#p0">order_</a>) - ix - iy - 1;
00254     }
00255   }
00256 
<a name="l00257"></a><a class="code" href="classHealpix__Base2.html#a7">00257</a> int64 <a class="code" href="classHealpix__Base2.html#a7">Healpix_Base2::nest2ring</a> (int64 pix)<span class="keyword"> const</span>
00258 <span class="keyword">  </span>{
00259   <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__assertgroup.html#a1">planck_assert</a>(<a class="code" href="classHealpix__Base2.html#p0">order_</a>&gt;=0, <span class="stringliteral">"nest2ring: need hierarchical map"</span>);
00260   <span class="keywordtype">int</span> ix, iy, face_num;
00261   nest2xyf (pix, ix, iy, face_num);
00262   <span class="keywordflow">return</span> xyf2ring (ix, iy, face_num);
00263   }
00264 
<a name="l00265"></a><a class="code" href="classHealpix__Base2.html#a8">00265</a> int64 <a class="code" href="classHealpix__Base2.html#a8">Healpix_Base2::ring2nest</a> (int64 pix)<span class="keyword"> const</span>
00266 <span class="keyword">  </span>{
00267   <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__assertgroup.html#a1">planck_assert</a>(<a class="code" href="classHealpix__Base2.html#p0">order_</a>&gt;=0, <span class="stringliteral">"ring2nest: need hierarchical map"</span>);
00268   <span class="keywordtype">int</span> ix, iy, face_num;
00269   ring2xyf (pix, ix, iy, face_num);
00270   <span class="keywordflow">return</span> xyf2nest (ix, iy, face_num);
00271   }
00272 
<a name="l00273"></a><a class="code" href="classHealpix__Base2.html#a9">00273</a> int64 <a class="code" href="classHealpix__Base2.html#a9">Healpix_Base2::nest2peano</a> (int64 pix)<span class="keyword"> const</span>
00274 <span class="keyword">  </span>{
00275   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> subpix[8][4] = {
00276     { 0, 1, 3, 2 }, { 3, 0, 2, 1 }, { 2, 3, 1, 0 }, { 1, 2, 0, 3 },
00277     { 0, 3, 1, 2 }, { 1, 0, 2, 3 }, { 2, 1, 3, 0 }, { 3, 2, 0, 1 } };
00278   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> subpath[8][4] = {
00279     { 4, 0, 6, 0 }, { 7, 5, 1, 1 }, { 2, 4, 2, 6 }, { 3, 3, 7, 5 },
00280     { 0, 2, 4, 4 }, { 5, 1, 5, 3 }, { 6, 6, 0, 2 }, { 1, 7, 3, 7 } };
00281   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> face2path[12] = {
00282     2, 5, 2, 5, 3, 6, 3, 6, 2, 3, 2, 3 };
00283   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> face2peanoface[12] = {
00284     0, 5, 6, 11, 10, 1, 4, 7, 2, 3, 8, 9 };
00285 
00286   <span class="keywordtype">int</span> face = pix&gt;&gt;(2*<a class="code" href="classHealpix__Base2.html#p0">order_</a>);
00287   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> path = face2path[face];
00288   int64 result = 0;
00289 
00290   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> shift=2*<a class="code" href="classHealpix__Base2.html#p0">order_</a>-2; shift&gt;=0; shift-=2)
00291     {
00292     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> spix = (pix&gt;&gt;shift) &amp; 0x3;
00293     result &lt;&lt;= 2;
00294     result |= subpix[path][spix];
00295     path=subpath[path][spix];
00296     }
00297 
00298   <span class="keywordflow">return</span> result + (int64(face2peanoface[face])&lt;&lt;(2*<a class="code" href="classHealpix__Base2.html#p0">order_</a>));
00299   }
00300 
<a name="l00301"></a><a class="code" href="classHealpix__Base2.html#a10">00301</a> int64 <a class="code" href="classHealpix__Base2.html#a10">Healpix_Base2::peano2nest</a> (int64 pix)<span class="keyword"> const</span>
00302 <span class="keyword">  </span>{
00303   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> subpix[8][4] = {
00304     { 0, 1, 3, 2 }, { 1, 3, 2, 0 }, { 3, 2, 0, 1 }, { 2, 0, 1, 3 },
00305     { 0, 2, 3, 1 }, { 1, 0, 2, 3 }, { 3, 1, 0, 2 }, { 2, 3, 1, 0 } };
00306   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> subpath[8][4] = {
00307     { 4, 0, 0, 6 }, { 5, 1, 1, 7 }, { 6, 2, 2, 4 }, { 7, 3, 3, 5 },
00308     { 0, 4, 4, 2 }, { 1, 5, 5, 3 }, { 2, 6, 6, 0 }, { 3, 7, 7, 1 } };
00309   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> face2path[12] = {
00310     2, 6, 2, 3, 3, 5, 2, 6, 2, 3, 3, 5 };
00311   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> peanoface2face[12] = {
00312     0, 5, 8, 9, 6, 1, 2, 7, 10, 11, 4, 3 };
00313 
00314   <span class="keywordtype">int</span> face = pix&gt;&gt;(2*<a class="code" href="classHealpix__Base2.html#p0">order_</a>);
00315   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> path = face2path[face];
00316   int64 result = 0;
00317 
00318   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> shift=2*<a class="code" href="classHealpix__Base2.html#p0">order_</a>-2; shift&gt;=0; shift-=2)
00319     {
00320     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> spix = (pix&gt;&gt;shift) &amp; 0x3;
00321     result &lt;&lt;= 2;
00322     result |= subpix[path][spix];
00323     path=subpath[path][spix];
00324     }
00325 
00326   <span class="keywordflow">return</span> result + (int64(peanoface2face[face])&lt;&lt;(2*<a class="code" href="classHealpix__Base2.html#p0">order_</a>));
00327   }
00328 
00329 int64 Healpix_Base2::ang2pix_z_phi (<span class="keywordtype">double</span> z, <span class="keywordtype">double</span> phi)<span class="keyword"> const</span>
00330 <span class="keyword">  </span>{
00331   <span class="keywordtype">double</span> za = abs(z);
00332   <span class="keywordtype">double</span> tt = <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__mathutilsgroup.html#a5">fmodulo</a>(phi,twopi) * inv_halfpi; <span class="comment">// in [0,4)</span>
00333 
00334   <span class="keywordflow">if</span> (<a class="code" href="classHealpix__Base2.html#p7">scheme_</a>==<a class="code" href="healpix__base_8h.html#a3a1">RING</a>)
00335     {
00336     <span class="keywordflow">if</span> (za&lt;=twothird) <span class="comment">// Equatorial region</span>
00337       {
00338       <span class="keywordtype">double</span> temp1 = nside_*(0.5+tt);
00339       <span class="keywordtype">double</span> temp2 = nside_*z*0.75;
00340       int64 jp = int64(temp1-temp2); <span class="comment">// index of  ascending edge line</span>
00341       int64 jm = int64(temp1+temp2); <span class="comment">// index of descending edge line</span>
00342 
00343       <span class="comment">// ring number counted from z=2/3</span>
00344       int64 ir = nside_ + 1 + jp - jm; <span class="comment">// in {1,2n+1}</span>
00345       <span class="keywordtype">int</span> kshift = 1-(ir&amp;1); <span class="comment">// kshift=1 if ir even, 0 otherwise</span>
00346 
00347       int64 ip = (jp+jm-nside_+kshift+1)/2; <span class="comment">// in {0,4n-1}</span>
00348       ip = imodulo&lt;int64&gt;(ip,4*nside_);
00349 
00350       <span class="keywordflow">return</span> ncap_ + (ir-1)*4*nside_ + ip;
00351       }
00352     <span class="keywordflow">else</span>  <span class="comment">// North &amp; South polar caps</span>
00353       {
00354       <span class="keywordtype">double</span> tp = tt-int(tt);
00355       <span class="keywordtype">double</span> tmp = nside_*sqrt(3*(1-za));
00356 
00357       int64 jp = int64(tp*tmp); <span class="comment">// increasing edge line index</span>
00358       int64 jm = int64((1.0-tp)*tmp); <span class="comment">// decreasing edge line index</span>
00359 
00360       int64 ir = jp+jm+1; <span class="comment">// ring number counted from the closest pole</span>
00361       int64 ip = int64(tt*ir); <span class="comment">// in {0,4*ir-1}</span>
00362       ip = imodulo&lt;int64&gt;(ip,4*ir);
00363 
00364       <span class="keywordflow">if</span> (z&gt;0)
00365         <span class="keywordflow">return</span> 2*ir*(ir-1) + ip;
00366       <span class="keywordflow">else</span>
00367         <span class="keywordflow">return</span> npix_ - 2*ir*(ir+1) + ip;
00368       }
00369     }
00370   <span class="keywordflow">else</span> <span class="comment">// scheme_ == NEST</span>
00371     {
00372     <span class="keywordtype">int</span> face_num, ix, iy;
00373 
00374     <span class="keywordflow">if</span> (za&lt;=twothird) <span class="comment">// Equatorial region</span>
00375       {
00376       <span class="keywordtype">double</span> temp1 = nside_*(0.5+tt);
00377       <span class="keywordtype">double</span> temp2 = nside_*(z*0.75);
00378       int64 jp = int64(temp1-temp2); <span class="comment">// index of  ascending edge line</span>
00379       int64 jm = int64(temp1+temp2); <span class="comment">// index of descending edge line</span>
00380       int64 ifp = jp &gt;&gt; <a class="code" href="classHealpix__Base2.html#p0">order_</a>;  <span class="comment">// in {0,4}</span>
00381       int64 ifm = jm &gt;&gt; order_;
00382       <span class="keywordflow">if</span> (ifp == ifm)           <span class="comment">// faces 4 to 7</span>
00383         face_num = (ifp==4) ? 4: ifp+4;
00384       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ifp &lt; ifm)       <span class="comment">// (half-)faces 0 to 3</span>
00385         face_num = ifp;
00386       <span class="keywordflow">else</span>                      <span class="comment">// (half-)faces 8 to 11</span>
00387         face_num = ifm + 8;
00388 
00389       ix = jm &amp; (nside_-1);
00390       iy = nside_ - (jp &amp; (nside_-1)) - 1;
00391       }
00392     <span class="keywordflow">else</span> <span class="comment">// polar region, za &gt; 2/3</span>
00393       {
00394       <span class="keywordtype">int</span> ntt = int(tt);
00395       <span class="keywordtype">double</span> tp = tt-ntt;
00396       <span class="keywordtype">double</span> tmp = nside_*sqrt(3*(1-za));
00397 
00398       int64 jp = int64(tp*tmp); <span class="comment">// increasing edge line index</span>
00399       int64 jm = int64((1.0-tp)*tmp); <span class="comment">// decreasing edge line index</span>
00400       <span class="keywordflow">if</span> (jp&gt;=nside_) jp = nside_-1; <span class="comment">// for points too close to the boundary</span>
00401       <span class="keywordflow">if</span> (jm&gt;=nside_) jm = nside_-1;
00402       <span class="keywordflow">if</span> (z &gt;= 0)
00403         {
00404         face_num = ntt;  <span class="comment">// in {0,3}</span>
00405         ix = nside_ - jm - 1;
00406         iy = nside_ - jp - 1;
00407         }
00408       <span class="keywordflow">else</span>
00409         {
00410         face_num = ntt + 8; <span class="comment">// in {8,11}</span>
00411         ix =  jp;
00412         iy =  jm;
00413         }
00414       }
00415 
00416     <span class="keywordflow">return</span> xyf2nest(ix,iy,face_num);
00417     }
00418   }
00419 
00420 <span class="keywordtype">void</span> Healpix_Base2::pix2ang_z_phi (int64 pix, <span class="keywordtype">double</span> &amp;z, <span class="keywordtype">double</span> &amp;phi)<span class="keyword"> const</span>
00421 <span class="keyword">  </span>{
00422   <span class="keywordflow">if</span> (<a class="code" href="classHealpix__Base2.html#p7">scheme_</a>==<a class="code" href="healpix__base_8h.html#a3a1">RING</a>)
00423     {
00424     <span class="keywordflow">if</span> (pix&lt;ncap_) <span class="comment">// North Polar cap</span>
00425       {
00426       int64 iring = int64(0.5*(1+<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__mathutilsgroup.html#a8">isqrt</a>(1+2*pix))); <span class="comment">//counted from North pole</span>
00427       int64 iphi  = (pix+1) - 2*iring*(iring-1);
00428 
00429       z = 1.0 - (iring*iring)*fact2_;
00430       phi = (iphi-0.5) * halfpi/iring;
00431       }
00432     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pix&lt;(npix_-ncap_)) <span class="comment">// Equatorial region</span>
00433       {
00434       int64 ip  = pix - ncap_;
00435       int64 iring = ip/(4*nside_) + nside_; <span class="comment">// counted from North pole</span>
00436       int64 iphi  = ip%(4*nside_) + 1;
00437       <span class="comment">// 1 if iring+nside is odd, 1/2 otherwise</span>
00438       <span class="keywordtype">double</span> fodd = ((iring+nside_)&amp;1) ? 1 : 0.5;
00439 
00440       int64 nl2 = 2*nside_;
00441       z = (nl2-iring)*fact1_;
00442       phi = (iphi-fodd) * pi/nl2;
00443       }
00444     <span class="keywordflow">else</span> <span class="comment">// South Polar cap</span>
00445       {
00446       int64 ip = npix_ - pix;
00447       int64 iring = int64(0.5*(1+<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/group__mathutilsgroup.html#a8">isqrt</a>(2*ip-1))); <span class="comment">//counted from South pole</span>
00448       int64 iphi  = 4*iring + 1 - (ip - 2*iring*(iring-1));
00449 
00450       z = -1.0 + (iring*iring)*fact2_;
00451       phi = (iphi-0.5) * halfpi/iring;
00452       }
00453     }
00454   <span class="keywordflow">else</span>
00455     {
00456     int64 nl4 = nside_*4;
00457 
00458     <span class="keywordtype">int</span> face_num, ix, iy;
00459     nest2xyf(pix,ix,iy,face_num);
00460 
00461     int64 jr = (int64(jrll[face_num])&lt;&lt;<a class="code" href="classHealpix__Base2.html#p0">order_</a>) - ix - iy - 1;
00462 
00463     int64 nr;
00464     <span class="keywordtype">int</span> kshift;
00465     <span class="keywordflow">if</span> (jr&lt;nside_)
00466       {
00467       nr = jr;
00468       z = 1 - nr*nr*fact2_;
00469       kshift = 0;
00470       }
00471     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (jr &gt; 3*nside_)
00472       {
00473       nr = nl4-jr;
00474       z = nr*nr*fact2_ - 1;
00475       kshift = 0;
00476       }
00477     <span class="keywordflow">else</span>
00478       {
00479       nr = nside_;
00480       z = (2*nside_-jr)*fact1_;
00481       kshift = (jr-nside_)&amp;1;
00482       }
00483 
00484     int64 jp = (jpll[face_num]*nr + ix -iy + 1 + kshift) / 2;
00485     <span class="keywordflow">if</span> (jp&gt;nl4) jp-=nl4;
00486     <span class="keywordflow">if</span> (jp&lt;1) jp+=nl4;
00487 
00488     phi = (jp-(kshift+1)*0.5)*(halfpi/nr);
00489     }
00490   }
00491 
<a name="l00492"></a><a class="code" href="classHealpix__Base2.html#a21">00492</a> <span class="keywordtype">void</span> <a class="code" href="classHealpix__Base2.html#a21">Healpix_Base2::neighbors</a> (int64 pix, <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classfix__arr.html">fix_arr&lt;int64,8&gt;</a> &amp;result)<span class="keyword"> const</span>
00493 <span class="keyword">  </span>{
00494   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> xoffset[] = { -1,-1, 0, 1, 1, 1, 0,-1 };
00495   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> yoffset[] = {  0, 1, 1, 1, 0,-1,-1,-1 };
00496   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> facearray[][12] =
00497         { {  8, 9,10,11,-1,-1,-1,-1,10,11, 8, 9 },   <span class="comment">// S</span>
00498           {  5, 6, 7, 4, 8, 9,10,11, 9,10,11, 8 },   <span class="comment">// SE</span>
00499           { -1,-1,-1,-1, 5, 6, 7, 4,-1,-1,-1,-1 },   <span class="comment">// E</span>
00500           {  4, 5, 6, 7,11, 8, 9,10,11, 8, 9,10 },   <span class="comment">// SW</span>
00501           {  0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11 },   <span class="comment">// center</span>
00502           {  1, 2, 3, 0, 0, 1, 2, 3, 5, 6, 7, 4 },   <span class="comment">// NE</span>
00503           { -1,-1,-1,-1, 7, 4, 5, 6,-1,-1,-1,-1 },   <span class="comment">// W</span>
00504           {  3, 0, 1, 2, 3, 0, 1, 2, 4, 5, 6, 7 },   <span class="comment">// NW</span>
00505           {  2, 3, 0, 1,-1,-1,-1,-1, 0, 1, 2, 3 } }; <span class="comment">// N</span>
00506   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> swaparray[][12] =
00507         { {  0,0,0,0,0,0,0,0,3,3,3,3 },   <span class="comment">// S</span>
00508           {  0,0,0,0,0,0,0,0,6,6,6,6 },   <span class="comment">// SE</span>
00509           {  0,0,0,0,0,0,0,0,0,0,0,0 },   <span class="comment">// E</span>
00510           {  0,0,0,0,0,0,0,0,5,5,5,5 },   <span class="comment">// SW</span>
00511           {  0,0,0,0,0,0,0,0,0,0,0,0 },   <span class="comment">// center</span>
00512           {  5,5,5,5,0,0,0,0,0,0,0,0 },   <span class="comment">// NE</span>
00513           {  0,0,0,0,0,0,0,0,0,0,0,0 },   <span class="comment">// W</span>
00514           {  6,6,6,6,0,0,0,0,0,0,0,0 },   <span class="comment">// NW</span>
00515           {  3,3,3,3,0,0,0,0,0,0,0,0 } }; <span class="comment">// N</span>
00516 
00517   <span class="keywordtype">int</span> ix, iy, face_num;
00518   (<a class="code" href="classHealpix__Base2.html#p7">scheme_</a>==<a class="code" href="healpix__base_8h.html#a3a1">RING</a>) ?
00519     ring2xyf(pix,ix,iy,face_num) : nest2xyf(pix,ix,iy,face_num);
00520 
00521   <span class="keyword">const</span> int64 nsm1 = nside_-1;
00522   <span class="keywordflow">if</span> ((ix&gt;0)&amp;&amp;(ix&lt;nsm1)&amp;&amp;(iy&gt;0)&amp;&amp;(iy&lt;nsm1))
00523     {
00524     <span class="keywordflow">if</span> (<a class="code" href="classHealpix__Base2.html#p7">scheme_</a>==<a class="code" href="healpix__base_8h.html#a3a1">RING</a>)
00525       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;8; ++m)
00526         result[m] = xyf2ring(ix+xoffset[m],iy+yoffset[m],face_num);
00527     <span class="keywordflow">else</span>
00528       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;8; ++m)
00529         result[m] = xyf2nest(ix+xoffset[m],iy+yoffset[m],face_num);
00530     }
00531   <span class="keywordflow">else</span>
00532     {
00533     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;8; ++i)
00534       {
00535       <span class="keywordtype">int</span> x=ix+xoffset[i];
00536       <span class="keywordtype">int</span> y=iy+yoffset[i];
00537       <span class="keywordtype">int</span> nbnum=4;
00538       <span class="keywordflow">if</span> (x&lt;0)
00539         { x+=nside_; nbnum-=1; }
00540       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (x&gt;=nside_)
00541         { x-=nside_; nbnum+=1; }
00542       <span class="keywordflow">if</span> (y&lt;0)
00543         { y+=nside_; nbnum-=3; }
00544       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (y&gt;=nside_)
00545         { y-=nside_; nbnum+=3; }
00546 
00547       <span class="keywordtype">int</span> f = facearray[nbnum][face_num];
00548       <span class="keywordflow">if</span> (f&gt;=0)
00549         {
00550         <span class="keywordflow">if</span> (swaparray[nbnum][face_num]&amp;1) x=nside_-x-1;
00551         <span class="keywordflow">if</span> (swaparray[nbnum][face_num]&amp;2) y=nside_-y-1;
00552         <span class="keywordflow">if</span> (swaparray[nbnum][face_num]&amp;4) std::swap(x,y);
00553         result[i] = (<a class="code" href="classHealpix__Base2.html#p7">scheme_</a>==<a class="code" href="healpix__base_8h.html#a3a1">RING</a>) ? xyf2ring(x,y,f) : xyf2nest(x,y,f);
00554         }
00555       <span class="keywordflow">else</span>
00556         result[i] = -1;
00557       }
00558     }
00559   }
00560 
<a name="l00561"></a><a class="code" href="classHealpix__Base2.html#a29">00561</a> <span class="keywordtype">double</span> <a class="code" href="classHealpix__Base2.html#a29">Healpix_Base2::max_pixrad</a>()<span class="keyword"> const</span>
00562 <span class="keyword">  </span>{
00563   <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classvec3.html">vec3</a> va,vb;
00564   va.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classvec3.html#a2">set_z_phi</a> (2./3., pi/(4*nside_));
00565   <span class="keywordtype">double</span> t1 = 1.-1./nside_;
00566   t1*=t1;
00567   vb.<a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/classvec3.html#a2">set_z_phi</a> (1-t1/3, 0);
00568   <span class="keywordflow">return</span> <a class="codeRef" doxygen="cxxsupport.tag:../cxxsupport/" href="../cxxsupport/geom__utils_8h.html#a1">v_angle</a>(va,vb);
00569   }
</pre></div><hr><address style="align: right;"><small>
Generated on Thu Feb 19 17:23:18 2009 for Healpix C++
</a> </small></address>
</body>
</html>
