<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>rotmatrix.cc Source File</title>
<link href="sheet.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>rotmatrix.cc</h1><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> *  This file is part of Healpix_cxx.</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> *  Healpix_cxx is free software; you can redistribute it and/or modify</span>
00005 <span class="comment"> *  it under the terms of the GNU General Public License as published by</span>
00006 <span class="comment"> *  the Free Software Foundation; either version 2 of the License, or</span>
00007 <span class="comment"> *  (at your option) any later version.</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> *  Healpix_cxx is distributed in the hope that it will be useful,</span>
00010 <span class="comment"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00012 <span class="comment"> *  GNU General Public License for more details.</span>
00013 <span class="comment"> *</span>
00014 <span class="comment"> *  You should have received a copy of the GNU General Public License</span>
00015 <span class="comment"> *  along with Healpix_cxx; if not, write to the Free Software</span>
00016 <span class="comment"> *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
00017 <span class="comment"> *</span>
00018 <span class="comment"> *  For more information about HEALPix, see http://healpix.jpl.nasa.gov</span>
00019 <span class="comment"> */</span>
00020 
00021 <span class="comment">/*</span>
00022 <span class="comment"> *  Healpix_cxx is being developed at the Max-Planck-Institut fuer Astrophysik</span>
00023 <span class="comment"> *  and financially supported by the Deutsches Zentrum fuer Luft- und Raumfahrt</span>
00024 <span class="comment"> *  (DLR).</span>
00025 <span class="comment"> */</span>
00026 
00027 <span class="comment">/*</span>
00028 <span class="comment"> *  Class for rotation transforms in 3D space</span>
00029 <span class="comment"> *</span>
00030 <span class="comment"> *  Copyright (C) 2003 Max-Planck-Society</span>
00031 <span class="comment"> *  Author: Martin Reinecke</span>
00032 <span class="comment"> */</span>
00033 
00034 <span class="preprocessor">#include "<a class="code" href="rotmatrix_8h.html">rotmatrix.h</a>"</span>
00035 <span class="preprocessor">#include "<a class="code" href="vec3_8h.html">vec3.h</a>"</span>
00036 <span class="preprocessor">#include "<a class="code" href="lsconstants_8h.html">lsconstants.h</a>"</span>
00037 <span class="preprocessor">#include &lt;algorithm&gt;</span>
00038 
00039 <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00040 
<a name="l00041"></a><a class="code" href="classrotmatrix.html#a2">00041</a> <a class="code" href="classrotmatrix.html#a1">rotmatrix::rotmatrix</a> (<span class="keyword">const</span> <a class="code" href="classvec3.html">vec3</a> &amp;a, <span class="keyword">const</span> <a class="code" href="classvec3.html">vec3</a> &amp;b, <span class="keyword">const</span> <a class="code" href="classvec3.html">vec3</a> &amp;c)
00042   {
00043   entry[0][0]=a.<a class="code" href="classvec3.html#o0">x</a>; entry[0][1]=b.<a class="code" href="classvec3.html#o0">x</a>; entry[0][2]=c.<a class="code" href="classvec3.html#o0">x</a>;
00044   entry[1][0]=a.<a class="code" href="classvec3.html#o1">y</a>; entry[1][1]=b.<a class="code" href="classvec3.html#o1">y</a>; entry[1][2]=c.<a class="code" href="classvec3.html#o1">y</a>;
00045   entry[2][0]=a.<a class="code" href="classvec3.html#o2">z</a>; entry[2][1]=b.<a class="code" href="classvec3.html#o2">z</a>; entry[2][2]=c.<a class="code" href="classvec3.html#o2">z</a>;
00046   }
00047 
<a name="l00048"></a><a class="code" href="classrotmatrix.html#a3">00048</a> <span class="keywordtype">void</span> <a class="code" href="classrotmatrix.html#a3">rotmatrix::SetToIdentity</a> ()
00049   {
00050   entry[0][0] = entry[1][1] = entry[2][2] = 1.;
00051   entry[0][1] = entry[1][0] = entry[0][2] =
00052   entry[2][0] = entry[1][2] = entry[2][1] = 0.;
00053   }
00054 
<a name="l00055"></a><a class="code" href="classrotmatrix.html#a4">00055</a> <span class="keywordtype">void</span> <a class="code" href="classrotmatrix.html#a4">rotmatrix::SetToZero</a> ()
00056   {
00057   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;3; ++m)
00058     entry[m][0] = entry[m][1] = entry[m][2] = 0;
00059   }
00060 
<a name="l00061"></a><a class="code" href="classrotmatrix.html#a5">00061</a> <span class="keywordtype">void</span> <a class="code" href="classrotmatrix.html#a5">rotmatrix::Transpose</a> ()
00062   {
00063   swap(entry[0][1], entry[1][0]);
00064   swap(entry[0][2], entry[2][0]);
00065   swap(entry[1][2], entry[2][1]);
00066   }
00067 
<a name="l00068"></a><a class="code" href="classrotmatrix.html#a6">00068</a> <span class="keywordtype">void</span> <a class="code" href="classrotmatrix.html#a6">rotmatrix::toAxisAngle</a> (<a class="code" href="classvec3.html">vec3</a> &amp;axis, <span class="keywordtype">double</span> &amp;angle)<span class="keyword"> const</span>
00069 <span class="keyword">  </span>{
00070   <span class="keywordtype">double</span> c2 = entry[0][0] + entry[1][1] + entry[2][2] - 1;
00071   axis.<a class="code" href="classvec3.html#o0">x</a> = entry[2][1] - entry[1][2];
00072   axis.<a class="code" href="classvec3.html#o1">y</a> = entry[0][2] - entry[2][0];
00073   axis.<a class="code" href="classvec3.html#o2">z</a> = entry[1][0] - entry[0][1];
00074 
00075   <span class="keywordtype">double</span> s2 = axis.<a class="code" href="classvec3.html#a4">Length</a>();
00076 
00077   <span class="keywordflow">if</span> (s2&gt;0)
00078     {
00079     angle = atan2(s2,c2);
00080     axis *= 1/s2;
00081     <span class="keywordflow">return</span>;
00082     }
00083 
00084   <span class="keywordflow">if</span> (c2&gt;=2) <span class="comment">// angle is 0</span>
00085     {
00086     axis = <a class="code" href="classvec3.html">vec3</a>(1,0,0);
00087     angle = 0;
00088     <span class="keywordflow">return</span>;
00089     }
00090 
00091   angle = pi;
00092 
00093   <span class="keywordtype">int</span> choice = 0; <span class="comment">// assume entry[0][0] is the largest</span>
00094   <span class="keywordflow">if</span> ((entry[1][1]&gt;entry[0][0]) &amp;&amp; (entry[1][1]&gt;entry[2][2])) choice=1;
00095   <span class="keywordflow">if</span> ((entry[2][2]&gt;entry[0][0]) &amp;&amp; (entry[2][2]&gt;entry[1][1])) choice=2;
00096 
00097   <span class="keywordflow">if</span> (choice==0)
00098     {
00099     axis.<a class="code" href="classvec3.html#o0">x</a> = 0.5*sqrt(entry[0][0]-entry[1][1]-entry[2][2]+1);
00100     <span class="keywordtype">double</span> half_inv = 0.5/axis.<a class="code" href="classvec3.html#o0">x</a>;
00101     axis.<a class="code" href="classvec3.html#o1">y</a> = half_inv*entry[0][1];
00102     axis.<a class="code" href="classvec3.html#o2">z</a> = half_inv*entry[0][2];
00103     <span class="keywordflow">return</span>;
00104     }
00105   <span class="keywordflow">if</span> (choice==1)
00106     {
00107     axis.<a class="code" href="classvec3.html#o1">y</a> = 0.5*sqrt(entry[1][1]-entry[0][0]-entry[2][2]+1);
00108     <span class="keywordtype">double</span> half_inv = 0.5/axis.<a class="code" href="classvec3.html#o1">y</a>;
00109     axis.<a class="code" href="classvec3.html#o0">x</a> = half_inv*entry[0][1];
00110     axis.<a class="code" href="classvec3.html#o2">z</a> = half_inv*entry[1][2];
00111     <span class="keywordflow">return</span>;
00112     }
00113 
00114   axis.<a class="code" href="classvec3.html#o2">z</a> = 0.5*sqrt(entry[2][2]-entry[0][0]-entry[1][1]+1);
00115   <span class="keywordtype">double</span> half_inv = 0.5/axis.<a class="code" href="classvec3.html#o2">z</a>;
00116   axis.<a class="code" href="classvec3.html#o0">x</a> = half_inv*entry[0][2];
00117   axis.<a class="code" href="classvec3.html#o1">y</a> = half_inv*entry[1][2];
00118   }
00119 
00120 <span class="keywordtype">void</span> <a class="code" href="classrotmatrix.html#a8">rotmatrix::Make_CPAC_Euler_Matrix</a>
<a name="l00121"></a><a class="code" href="classrotmatrix.html#a8">00121</a>   (<span class="keywordtype">double</span> alpha, <span class="keywordtype">double</span> beta, <span class="keywordtype">double</span> gamma)
00122   {
00123   <span class="keywordtype">double</span> ca=cos(alpha), cb=cos(beta), cg=cos(gamma);
00124   <span class="keywordtype">double</span> sa=sin(alpha), sb=sin(beta), sg=sin(gamma);
00125 
00126   entry[0][0]= ca*cb*cg-sa*sg; entry[0][1]=-ca*cb*sg-sa*cg; entry[0][2]= ca*sb;
00127   entry[1][0]= sa*cb*cg+ca*sg; entry[1][1]=-sa*cb*sg+ca*cg; entry[1][2]= sa*sb;
00128   entry[2][0]=-sb*cg;          entry[2][1]= sb*sg;          entry[2][2]= cb;
00129   }
00130 
00131 <span class="keywordtype">void</span> <a class="code" href="classrotmatrix.html#a9">rotmatrix::Extract_CPAC_Euler_Angles</a>
<a name="l00132"></a><a class="code" href="classrotmatrix.html#a9">00132</a>   (<span class="keywordtype">double</span> &amp;alpha, <span class="keywordtype">double</span> &amp;beta, <span class="keywordtype">double</span> &amp;gamma) <span class="keyword">const</span>
00133   {
00134   <span class="keywordtype">double</span> cb = entry[2][2];
00135   <span class="keywordtype">double</span> sb = sqrt(entry[0][2]*entry[0][2] + entry[1][2]*entry[1][2]);
00136   beta=atan2(sb,cb);
00137   <span class="keywordflow">if</span> (abs(sb)&lt;=1e-6)
00138     {
00139     alpha=0;
00140     <span class="keywordflow">if</span> (cb&gt;0)
00141       gamma=atan2(entry[1][0],entry[0][0]);
00142     <span class="keywordflow">else</span>
00143       gamma=atan2(entry[0][1],-entry[0][0]);
00144     }
00145   <span class="keywordflow">else</span>
00146     {
00147     alpha=atan2(entry[1][2],entry[0][2]);
00148     gamma=atan2(entry[2][1],-entry[2][0]);
00149     }
00150   }
00151 
<a name="l00152"></a><a class="code" href="classrotmatrix.html#a0">00152</a> <a class="code" href="classrotmatrix.html">rotmatrix</a> operator* (<span class="keyword">const</span> <a class="code" href="classrotmatrix.html">rotmatrix</a> &amp;a, <span class="keyword">const</span> <a class="code" href="classrotmatrix.html">rotmatrix</a> &amp;b)
00153   {
00154   <a class="code" href="classrotmatrix.html">rotmatrix</a> res;
00155   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;3; ++i)
00156     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;3; ++j)
00157       res.<a class="code" href="classrotmatrix.html#o0">entry</a>[i][j] = a.<a class="code" href="classrotmatrix.html#o0">entry</a>[i][0] * b.<a class="code" href="classrotmatrix.html#o0">entry</a>[0][j]
00158                       + a.<a class="code" href="classrotmatrix.html#o0">entry</a>[i][1] * b.<a class="code" href="classrotmatrix.html#o0">entry</a>[1][j]
00159                       + a.<a class="code" href="classrotmatrix.html#o0">entry</a>[i][2] * b.<a class="code" href="classrotmatrix.html#o0">entry</a>[2][j];
00160   <span class="keywordflow">return</span> res;
00161   }
00162 
<a name="l00163"></a><a class="code" href="classrotmatrix.html#a1">00163</a> <span class="keywordtype">void</span> TransposeTimes (<span class="keyword">const</span> <a class="code" href="classrotmatrix.html">rotmatrix</a> &amp;a, <span class="keyword">const</span> <a class="code" href="classrotmatrix.html">rotmatrix</a> &amp;b, <a class="code" href="classrotmatrix.html">rotmatrix</a> &amp;res)
00164   {
00165   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;3; ++i)
00166     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;3; ++j)
00167       res.<a class="code" href="classrotmatrix.html#o0">entry</a>[i][j] = a.<a class="code" href="classrotmatrix.html#o0">entry</a>[0][i] * b.<a class="code" href="classrotmatrix.html#o0">entry</a>[0][j]
00168                       + a.<a class="code" href="classrotmatrix.html#o0">entry</a>[1][i] * b.<a class="code" href="classrotmatrix.html#o0">entry</a>[1][j]
00169                       + a.<a class="code" href="classrotmatrix.html#o0">entry</a>[2][i] * b.<a class="code" href="classrotmatrix.html#o0">entry</a>[2][j];
00170   }
00171 
<a name="l00172"></a><a class="code" href="classrotmatrix.html#a2">00172</a> ostream &amp;operator&lt;&lt; (ostream &amp;os, <span class="keyword">const</span> <a class="code" href="classrotmatrix.html">rotmatrix</a> &amp;mat)
00173   {
00174   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;3;++i)
00175     os &lt;&lt; mat.<a class="code" href="classrotmatrix.html#o0">entry</a>[i][0] &lt;&lt; <span class="charliteral">' '</span>
00176        &lt;&lt; mat.<a class="code" href="classrotmatrix.html#o0">entry</a>[i][1] &lt;&lt; <span class="charliteral">' '</span>
00177        &lt;&lt; mat.<a class="code" href="classrotmatrix.html#o0">entry</a>[i][2] &lt;&lt; endl;
00178   <span class="keywordflow">return</span> os;
00179   }
</pre></div><hr><address style="align: right;"><small>
Generated on Thu Nov 13 18:48:49 2008 for LevelS C++ support library
</a> </small></address>
</body>
</html>
