<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>LevelS C++ support library: arr.h Source File</title>
<link href="sheet.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">cxxsupport</a></div>
<h1>arr.h</h1><a href="arr_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> *  This file is part of Healpix_cxx.</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> *  Healpix_cxx is free software; you can redistribute it and/or modify</span>
00005 <span class="comment"> *  it under the terms of the GNU General Public License as published by</span>
00006 <span class="comment"> *  the Free Software Foundation; either version 2 of the License, or</span>
00007 <span class="comment"> *  (at your option) any later version.</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> *  Healpix_cxx is distributed in the hope that it will be useful,</span>
00010 <span class="comment"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00012 <span class="comment"> *  GNU General Public License for more details.</span>
00013 <span class="comment"> *</span>
00014 <span class="comment"> *  You should have received a copy of the GNU General Public License</span>
00015 <span class="comment"> *  along with Healpix_cxx; if not, write to the Free Software</span>
00016 <span class="comment"> *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
00017 <span class="comment"> *</span>
00018 <span class="comment"> *  For more information about HEALPix, see http://healpix.jpl.nasa.gov</span>
00019 <span class="comment"> */</span>
00020 
00021 <span class="comment">/*</span>
00022 <span class="comment"> *  Healpix_cxx is being developed at the Max-Planck-Institut fuer Astrophysik</span>
00023 <span class="comment"> *  and financially supported by the Deutsches Zentrum fuer Luft- und Raumfahrt</span>
00024 <span class="comment"> *  (DLR).</span>
00025 <span class="comment"> */</span>
00026 <span class="comment"></span>
00027 <span class="comment">/*! \file arr.h</span>
00028 <span class="comment"> *  Various high-performance array classes used by the Planck LevelS package.</span>
00029 <span class="comment"> *</span>
00030 <span class="comment"> *  Copyright (C) 2002, 2003, 2004, 2005 Max-Planck-Society</span>
00031 <span class="comment"> *  \author Martin Reinecke</span>
00032 <span class="comment"> */</span>
00033 
00034 <span class="preprocessor">#ifndef PLANCK_ARR_H</span>
00035 <span class="preprocessor"></span><span class="preprocessor">#define PLANCK_ARR_H</span>
00036 <span class="preprocessor"></span>
00037 <span class="preprocessor">#include "<a class="code" href="cxxutils_8h.html">cxxutils.h</a>"</span>
00038 <span class="preprocessor">#include &lt;algorithm&gt;</span>
00039 <span class="comment"></span>
00040 <span class="comment">/*! \defgroup arraygroup Array classes */</span><span class="comment"></span>
00041 <span class="comment">/*! \{ */</span>
00042 <span class="comment"></span>
00043 <span class="comment">/*! An array whose size is known at compile time. Very useful for storing</span>
00044 <span class="comment">    small arrays on the stack, without need for \a new() and \a delete(). */</span>
<a name="l00045"></a><a class="code" href="classfix__arr.html">00045</a> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sz&gt; <span class="keyword">class </span><a class="code" href="classfix__arr.html">fix_arr</a>
00046   {
00047   <span class="keyword">private</span>:
00048     T d[sz];
00049 
00050   <span class="keyword">public</span>:<span class="comment"></span>
00051 <span class="comment">    /*! Returns the size of the array. */</span>
<a name="l00052"></a><a class="code" href="classfix__arr.html#a0">00052</a>     <span class="keywordtype">long</span> size()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> sz; }
00053 <span class="comment"></span>
00054 <span class="comment">    /*! Returns a reference to element \a #n */</span>
<a name="l00055"></a><a class="code" href="classfix__arr.html#a1">00055</a>     T &amp;operator[] (<span class="keywordtype">long</span> n) {<span class="keywordflow">return</span> d[n];}<span class="comment"></span>
00056 <span class="comment">    /*! Returns a reference to element \a #n */</span>
<a name="l00057"></a><a class="code" href="classfix__arr.html#a2">00057</a>     T &amp;operator[] (<span class="keywordtype">int</span> n) {<span class="keywordflow">return</span> d[n];}<span class="comment"></span>
00058 <span class="comment">    /*! Returns a constant reference to element \a #n */</span>
<a name="l00059"></a><a class="code" href="classfix__arr.html#a3">00059</a>     <span class="keyword">const</span> T &amp;operator[] (<span class="keywordtype">long</span> n)<span class="keyword"> const </span>{<span class="keywordflow">return</span> d[n];}<span class="comment"></span>
00060 <span class="comment">    /*! Returns a constant reference to element \a #n */</span>
<a name="l00061"></a><a class="code" href="classfix__arr.html#a4">00061</a>     <span class="keyword">const</span> T &amp;operator[] (<span class="keywordtype">int</span> n)<span class="keyword"> const </span>{<span class="keywordflow">return</span> d[n];}
00062   };
00063 
00064 <span class="comment"></span>
00065 <span class="comment">/*! One-dimensional array type. */</span>
<a name="l00066"></a><a class="code" href="classarr.html">00066</a> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class </span><a class="code" href="classarr.html">arr</a>
00067   {
00068   <span class="keyword">private</span>:
00069     <span class="keywordtype">long</span> s;
00070     T *d;
00071 
00072 <span class="preprocessor">#if defined(PLANCK_CHECKS)</span>
00073 <span class="preprocessor"></span>    <span class="keywordtype">void</span> check_range(<span class="keywordtype">long</span> n)<span class="keyword"> const</span>
00074 <span class="keyword">      </span>{
00075       <span class="keywordflow">if</span> ((n&lt;0) || (n&gt;=s)) <span class="keywordflow">throw</span> Message_error
00076         (<span class="stringliteral">"arr: index "</span>+<a class="code" href="group__stringutilsgroup.html#ga1">dataToString</a>(n)+<span class="stringliteral">" is out of range. Max index is "</span>
00077          +<a class="code" href="group__stringutilsgroup.html#ga1">dataToString</a>(s-1));
00078       }
00079 <span class="preprocessor">#endif</span>
00080 <span class="preprocessor"></span>
00081   <span class="keyword">public</span>:<span class="comment"></span>
00082 <span class="comment">    /*! Creates a zero-sized array. */</span>
<a name="l00083"></a><a class="code" href="classarr.html#a0">00083</a>     <a class="code" href="classarr.html">arr</a>() : s(0), d(0) {}<span class="comment"></span>
00084 <span class="comment">    /*! Creates an array with \a sz entries. */</span>
<a name="l00085"></a><a class="code" href="classarr.html#a1">00085</a>     <a class="code" href="classarr.html">arr</a>(<span class="keywordtype">long</span> sz) : s(sz), d (s&gt;0 ? new T[s] : 0) {}<span class="comment"></span>
00086 <span class="comment">    /*! Creates an array with \a sz entries, and initializes them with</span>
00087 <span class="comment">        \a inival. */</span>
<a name="l00088"></a><a class="code" href="classarr.html#a2">00088</a>     <a class="code" href="classarr.html">arr</a>(<span class="keywordtype">long</span> sz, <span class="keyword">const</span> T&amp;inival) : s(sz), d (s&gt;0 ? new T[s] : 0)
00089       { fill(inival); }<span class="comment"></span>
00090 <span class="comment">    /*! Creates an array which is a copy of \a orig. The data in \a orig</span>
00091 <span class="comment">        is duplicated. */</span>
<a name="l00092"></a><a class="code" href="classarr.html#a3">00092</a>     <a class="code" href="classarr.html">arr</a> (<span class="keyword">const</span> <a class="code" href="classarr.html">arr</a> &amp;orig): s(orig.s), d (s&gt;0 ? new T[s] : 0)
00093       { <span class="keywordflow">for</span> (<span class="keywordtype">long</span> m=0; m&lt;s; ++m) d[m] = orig.<a class="code" href="classarr.html#r1">d</a>[m]; }<span class="comment"></span>
00094 <span class="comment">    /*! Frees the memory allocated by the object. */</span>
<a name="l00095"></a><a class="code" href="classarr.html#a4">00095</a>     ~<a class="code" href="classarr.html">arr</a>() { <span class="keyword">delete</span>[] d; }
00096 <span class="comment"></span>
00097 <span class="comment">    /*! Returns the current array size. */</span>
<a name="l00098"></a><a class="code" href="classarr.html#a5">00098</a>     <span class="keywordtype">long</span> size()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> s; }
00099 <span class="comment"></span>
00100 <span class="comment">    /*! Allocates space for \a sz elements. The content of the array is</span>
00101 <span class="comment">        undefined on exit. \a sz can be 0. If \a sz is the</span>
00102 <span class="comment">        same as the current size, no reallocation is performed. */</span>
<a name="l00103"></a><a class="code" href="classarr.html#a6">00103</a>     <span class="keywordtype">void</span> alloc (<span class="keywordtype">long</span> sz)
00104       {
00105       <span class="keywordflow">if</span> (sz==s) <span class="keywordflow">return</span>;
00106       <span class="keyword">delete</span>[] d;
00107       s = sz;
00108       d = s&gt;0 ? <span class="keyword">new</span> T[sz] : 0;
00109       }<span class="comment"></span>
00110 <span class="comment">    /*! Deallocates the memory held by the array, and sets the array size</span>
00111 <span class="comment">        to 0. */</span>
<a name="l00112"></a><a class="code" href="classarr.html#a7">00112</a>     <span class="keywordtype">void</span> dealloc () {<span class="keyword">delete</span>[] d; d=0; s=0;}
00113 <span class="comment"></span>
00114 <span class="comment">    /*! Writes \a val into every element of the array. */</span>
<a name="l00115"></a><a class="code" href="classarr.html#a8">00115</a>     <span class="keywordtype">void</span> fill (<span class="keyword">const</span> T &amp;val)
00116       { <span class="keywordflow">for</span> (<span class="keywordtype">long</span> m=0; m&lt;s; ++m) d[m]=val; }
00117 <span class="comment"></span>
00118 <span class="comment">    /*! Changes the array to be a copy of \a orig. */</span>
<a name="l00119"></a><a class="code" href="classarr.html#a9">00119</a>     <a class="code" href="classarr.html">arr</a> &amp;operator= (<span class="keyword">const</span> <a class="code" href="classarr.html">arr</a> &amp;orig)
00120       {
00121       <span class="keywordflow">if</span> (<span class="keyword">this</span>==&amp;orig) <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00122       alloc (orig.<a class="code" href="classarr.html#r0">s</a>);
00123       <span class="keywordflow">for</span> (<span class="keywordtype">long</span> m=0; m&lt;s; ++m) d[m] = orig.<a class="code" href="classarr.html#r1">d</a>[m];
00124       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00125       }
00126 
00127 <span class="preprocessor">#if defined (PLANCK_CHECKS)</span>
00128 <span class="preprocessor"></span>    T &amp;operator[] (<span class="keywordtype">long</span> n) {check_range(n); <span class="keywordflow">return</span> d[n];}
00129     T &amp;operator[] (<span class="keywordtype">int</span> n) {check_range(n); <span class="keywordflow">return</span> d[n];}
00130     <span class="keyword">const</span> T &amp;operator[] (<span class="keywordtype">long</span> n)<span class="keyword"> const </span>{check_range(n); <span class="keywordflow">return</span> d[n];}
00131     <span class="keyword">const</span> T &amp;operator[] (<span class="keywordtype">int</span> n)<span class="keyword"> const </span>{check_range(n); <span class="keywordflow">return</span> d[n];}
00132 <span class="preprocessor">#else</span>
00133 <span class="preprocessor"></span><span class="comment">    /*! Returns a reference to element \a #n */</span>
<a name="l00134"></a><a class="code" href="classarr.html#a10">00134</a>     T &amp;operator[] (<span class="keywordtype">long</span> n) {<span class="keywordflow">return</span> d[n];}<span class="comment"></span>
00135 <span class="comment">    /*! Returns a reference to element \a #n */</span>
<a name="l00136"></a><a class="code" href="classarr.html#a11">00136</a>     T &amp;operator[] (<span class="keywordtype">int</span> n) {<span class="keywordflow">return</span> d[n];}<span class="comment"></span>
00137 <span class="comment">    /*! Returns a constant reference to element \a #n */</span>
<a name="l00138"></a><a class="code" href="classarr.html#a12">00138</a>     <span class="keyword">const</span> T &amp;operator[] (<span class="keywordtype">long</span> n)<span class="keyword"> const </span>{<span class="keywordflow">return</span> d[n];}<span class="comment"></span>
00139 <span class="comment">    /*! Returns a constant reference to element \a #n */</span>
<a name="l00140"></a><a class="code" href="classarr.html#a13">00140</a>     <span class="keyword">const</span> T &amp;operator[] (<span class="keywordtype">int</span> n)<span class="keyword"> const </span>{<span class="keywordflow">return</span> d[n];}
00141 <span class="preprocessor">#endif</span>
00142 <span class="preprocessor"></span><span class="comment">    /*! Returns a pointer to the first element,</span>
00143 <span class="comment">        or 0 if the array is zero-sized. */</span>
<a name="l00144"></a><a class="code" href="classarr.html#a14">00144</a>     operator T *() { <span class="keywordflow">return</span> d; }<span class="comment"></span>
00145 <span class="comment">    /*! Returns a constant pointer to the first element,</span>
00146 <span class="comment">        or 0 if the array is zero-sized. */</span>
<a name="l00147"></a><a class="code" href="classarr.html#a15">00147</a>     operator const T *()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> d; }
00148 
00149     T *begin() { <span class="keywordflow">return</span> d; }
00150     T *end() { <span class="keywordflow">return</span> d+s; }
00151 <span class="comment"></span>
00152 <span class="comment">    /*! Sorts the elements in the array, in ascending order. */</span>
<a name="l00153"></a><a class="code" href="classarr.html#a18">00153</a>     <span class="keywordtype">void</span> sort()
00154       { std::sort (d,d+s); }
00155 <span class="comment"></span>
00156 <span class="comment">    /*! Returns the minimum and maximum entry in \a minv and \a maxv,</span>
00157 <span class="comment">        respectively. Does nothing if the array is zero-sized. */</span>
<a name="l00158"></a><a class="code" href="classarr.html#a19">00158</a>     <span class="keywordtype">void</span> minmax (T &amp;minv, T &amp;maxv)<span class="keyword"> const</span>
00159 <span class="keyword">      </span>{
00160       <span class="keywordflow">if</span> (s==0) <span class="keywordflow">return</span>;
00161       minv=maxv=d[0];
00162       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=1; m&lt;s; ++m)
00163         {
00164         <span class="keywordflow">if</span> (d[m]&lt;minv) minv=d[m];
00165         <span class="keywordflow">if</span> (d[m]&gt;maxv) maxv=d[m];
00166         }
00167       }
00168 <span class="comment"></span>
00169 <span class="comment">    /*! Assigns the contents and size of \a other to the array. On exit,</span>
00170 <span class="comment">        \a other is yero-sized. */</span>
<a name="l00171"></a><a class="code" href="classarr.html#a20">00171</a>     <span class="keywordtype">void</span> transfer (<a class="code" href="classarr.html">arr</a> &amp;other)
00172       { <span class="keyword">delete</span>[] d; d=other.<a class="code" href="classarr.html#r1">d</a>; s=other.<a class="code" href="classarr.html#r0">s</a>; other.<a class="code" href="classarr.html#r1">d</a>=0; other.<a class="code" href="classarr.html#r0">s</a>=0; }<span class="comment"></span>
00173 <span class="comment">    /*! Swaps contents and size with \a other. */</span>
<a name="l00174"></a><a class="code" href="classarr.html#a21">00174</a>     <span class="keywordtype">void</span> swap (<a class="code" href="classarr.html">arr</a> &amp;other)
00175       { std::swap(d,other.<a class="code" href="classarr.html#r1">d</a>); std::swap(s,other.<a class="code" href="classarr.html#r0">s</a>); }
00176   };
00177 <span class="comment"></span>
00178 <span class="comment">/*! Two-dimensional array type. The storage ordering is the same as in C.</span>
00179 <span class="comment">    An entry is located by adress arithmetic, not by double dereferencing.</span>
00180 <span class="comment">    The indices start at zero. */</span>
<a name="l00181"></a><a class="code" href="classarr2.html">00181</a> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class </span><a class="code" href="classarr2.html">arr2</a>
00182   {
00183   <span class="keyword">private</span>:
00184     <span class="keywordtype">long</span> s1, s2, cap;
00185     T *d;
00186 
00187 <span class="preprocessor">#if defined (PLANCK_CHECKS)</span>
00188 <span class="preprocessor"></span>    <span class="keywordtype">void</span> check_range(<span class="keywordtype">long</span> n)<span class="keyword"> const</span>
00189 <span class="keyword">      </span>{
00190       <span class="keywordflow">if</span> ((n&lt;0) || (n&gt;=s1)) <span class="keywordflow">throw</span> Message_error
00191         (<span class="stringliteral">"arr: index "</span>+<a class="code" href="group__stringutilsgroup.html#ga1">dataToString</a>(n)+<span class="stringliteral">" is out of range. Max index is "</span>
00192          +<a class="code" href="group__stringutilsgroup.html#ga1">dataToString</a>(s1-1));
00193       }
00194 <span class="preprocessor">#endif</span>
00195 <span class="preprocessor"></span>
00196   <span class="keyword">public</span>:<span class="comment"></span>
00197 <span class="comment">    /*! Creates a zero-sized array. */</span>
<a name="l00198"></a><a class="code" href="classarr2.html#a0">00198</a>     <a class="code" href="classarr2.html">arr2</a>() : s1(0), s2(0), cap(0), d(0) {}<span class="comment"></span>
00199 <span class="comment">    /*! Creates an array with the dimensions \a sz1 and \a sz2. */</span>
<a name="l00200"></a><a class="code" href="classarr2.html#a1">00200</a>     <a class="code" href="classarr2.html">arr2</a>(<span class="keywordtype">long</span> sz1, <span class="keywordtype">long</span> sz2)
00201       : s1(sz1), s2(sz2), cap(s1*s2), d (cap&gt;0 ? new T[cap] : 0) {}<span class="comment"></span>
00202 <span class="comment">    /*! Creates the array as a copy of \a orig. */</span>
<a name="l00203"></a><a class="code" href="classarr2.html#a2">00203</a>     <a class="code" href="classarr2.html">arr2</a>(<span class="keyword">const</span> <a class="code" href="classarr2.html">arr2</a> &amp;orig)
00204       : s1(orig.s1), s2(orig.s2), cap(s1*s2), d (cap&gt;0 ? new T[cap] : 0)
00205       { <span class="keywordflow">for</span> (<span class="keywordtype">long</span> m=0; m&lt;cap; ++m) d[m] = orig.<a class="code" href="classarr2.html#r3">d</a>[m];}<span class="comment"></span>
00206 <span class="comment">    /*! Frees the memory associated with the array. */</span>
<a name="l00207"></a><a class="code" href="classarr2.html#a3">00207</a>     ~<a class="code" href="classarr2.html">arr2</a>() { <span class="keyword">delete</span>[] d; }
00208 <span class="comment"></span>
00209 <span class="comment">    /*! Returns the first array dimension. */</span>
<a name="l00210"></a><a class="code" href="classarr2.html#a4">00210</a>     <span class="keywordtype">long</span> size1()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> s1; }<span class="comment"></span>
00211 <span class="comment">    /*! Returns the second array dimension. */</span>
<a name="l00212"></a><a class="code" href="classarr2.html#a5">00212</a>     <span class="keywordtype">long</span> size2()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> s2; }<span class="comment"></span>
00213 <span class="comment">    /*! Returns the total array size, i.e. the product of both dimensions. */</span>
<a name="l00214"></a><a class="code" href="classarr2.html#a6">00214</a>     <span class="keywordtype">long</span> size ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> s1*s2; }
00215 <span class="comment"></span>
00216 <span class="comment">    /*! Allocates space for an array with \a sz1*sz2 elements.</span>
00217 <span class="comment">        The content of the array is undefined on exit.</span>
00218 <span class="comment">        \a sz1 or \a sz2 can be 0. If \a sz1*sz2 is the same as the</span>
00219 <span class="comment">        currently allocated space, no reallocation is performed. */</span>
<a name="l00220"></a><a class="code" href="classarr2.html#a7">00220</a>     <span class="keywordtype">void</span> alloc (<span class="keywordtype">long</span> sz1, <span class="keywordtype">long</span> sz2)
00221       {
00222       <span class="keywordflow">if</span> (sz1*sz2 != cap)
00223         {
00224         <span class="keyword">delete</span>[] d;
00225         cap = sz1*sz2;
00226         d = cap&gt;0 ? <span class="keyword">new</span> T[cap] : 0;
00227         }
00228       s1=sz1; s2=sz2;
00229       }<span class="comment"></span>
00230 <span class="comment">    /*! Allocates space for an array with \a sz1*sz2 elements.</span>
00231 <span class="comment">        The content of the array is undefined on exit.</span>
00232 <span class="comment">        \a sz1 or \a sz2 can be 0. If \a sz1*sz2 is smaller than the</span>
00233 <span class="comment">        currently allocated space, no reallocation is performed. */</span>
<a name="l00234"></a><a class="code" href="classarr2.html#a8">00234</a>     <span class="keywordtype">void</span> fast_alloc (<span class="keywordtype">long</span> sz1, <span class="keywordtype">long</span> sz2)
00235       {
00236       <span class="keywordflow">if</span> (sz1*sz2&lt;=cap)
00237         { s1=sz1; s2=sz2; }
00238       <span class="keywordflow">else</span>
00239         alloc(sz1,sz2);
00240       }<span class="comment"></span>
00241 <span class="comment">    /*! Deallocates the space and makes the array zero-sized. */</span>
<a name="l00242"></a><a class="code" href="classarr2.html#a9">00242</a>     <span class="keywordtype">void</span> dealloc () {<span class="keyword">delete</span>[] d; d=0; s1=0; s2=0; cap=0;}
00243 <span class="comment"></span>
00244 <span class="comment">    /*! Sets all array elements to \a val. */</span>
<a name="l00245"></a><a class="code" href="classarr2.html#a10">00245</a>     <span class="keywordtype">void</span> fill (<span class="keyword">const</span> T &amp;val)
00246       { <span class="keywordflow">for</span> (<span class="keywordtype">long</span> m=0; m&lt;s1*s2; ++m) d[m]=val; }
00247 <span class="comment"></span>
00248 <span class="comment">    /*! Changes the array to be a copy of \a orig. */</span>
<a name="l00249"></a><a class="code" href="classarr2.html#a11">00249</a>     <a class="code" href="classarr2.html">arr2</a> &amp;operator= (<span class="keyword">const</span> <a class="code" href="classarr2.html">arr2</a> &amp;orig)
00250       {
00251       <span class="keywordflow">if</span> (<span class="keyword">this</span>==&amp;orig) <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00252       alloc (orig.<a class="code" href="classarr2.html#r0">s1</a>, orig.<a class="code" href="classarr2.html#r1">s2</a>);
00253       <span class="keywordflow">for</span> (<span class="keywordtype">long</span> m=0; m&lt;s1*s2; ++m) d[m] = orig.<a class="code" href="classarr2.html#r3">d</a>[m];
00254       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00255       }
00256 
00257 <span class="preprocessor">#if defined (PLANCK_CHECKS)</span>
00258 <span class="preprocessor"></span>    T *operator[] (<span class="keywordtype">long</span> n) {check_range(n);<span class="keywordflow">return</span> &amp;d[n*s2];}
00259     T *operator[] (<span class="keywordtype">int</span> n) {check_range(n);<span class="keywordflow">return</span> &amp;d[n*s2];}
00260     <span class="keyword">const</span> T *operator[] (<span class="keywordtype">long</span> n)<span class="keyword"> const </span>{check_range(n);<span class="keywordflow">return</span> &amp;d[n*s2];}
00261     <span class="keyword">const</span> T *operator[] (<span class="keywordtype">int</span> n)<span class="keyword"> const </span>{check_range(n);<span class="keywordflow">return</span> &amp;d[n*s2];}
00262 <span class="preprocessor">#else</span>
00263 <span class="preprocessor"></span><span class="comment">    /*! Returns a pointer to the beginning of slice \a #n. */</span>
<a name="l00264"></a><a class="code" href="classarr2.html#a12">00264</a>     T *operator[] (<span class="keywordtype">long</span> n) {<span class="keywordflow">return</span> &amp;d[n*s2];}<span class="comment"></span>
00265 <span class="comment">    /*! Returns a pointer to the beginning of slice \a #n. */</span>
<a name="l00266"></a><a class="code" href="classarr2.html#a13">00266</a>     T *operator[] (<span class="keywordtype">int</span> n) {<span class="keywordflow">return</span> &amp;d[n*s2];}<span class="comment"></span>
00267 <span class="comment">    /*! Returns a constant pointer to the beginning of slice \a #n. */</span>
<a name="l00268"></a><a class="code" href="classarr2.html#a14">00268</a>     <span class="keyword">const</span> T *operator[] (<span class="keywordtype">long</span> n)<span class="keyword"> const </span>{<span class="keywordflow">return</span> &amp;d[n*s2];}<span class="comment"></span>
00269 <span class="comment">    /*! Returns a constant pointer to the beginning of slice \a #n. */</span>
<a name="l00270"></a><a class="code" href="classarr2.html#a15">00270</a>     <span class="keyword">const</span> T *operator[] (<span class="keywordtype">int</span> n)<span class="keyword"> const </span>{<span class="keywordflow">return</span> &amp;d[n*s2];}
00271 <span class="preprocessor">#endif</span>
00272 <span class="preprocessor"></span><span class="comment"></span>
00273 <span class="comment">    /*! Returns the minimum and maximum entry in \a minv and \a maxv,</span>
00274 <span class="comment">        respectively. Does nothing if the array is zero-sized. */</span>
<a name="l00275"></a><a class="code" href="classarr2.html#a16">00275</a>     <span class="keywordtype">void</span> minmax (T &amp;minv, T &amp;maxv)<span class="keyword"> const</span>
00276 <span class="keyword">      </span>{
00277       <span class="keywordflow">if</span> (s1*s2==0) <span class="keywordflow">return</span>;
00278       minv=maxv=d[0];
00279       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=1; m&lt;s1*s2; ++m)
00280         {
00281         <span class="keywordflow">if</span> (d[m]&lt;minv) minv=d[m];
00282         <span class="keywordflow">if</span> (d[m]&gt;maxv) maxv=d[m];
00283         }
00284       }
00285 <span class="comment"></span>
00286 <span class="comment">    /*! Swaps contents and sizes with \a other. */</span>
<a name="l00287"></a><a class="code" href="classarr2.html#a17">00287</a>     <span class="keywordtype">void</span> swap (<a class="code" href="classarr2.html">arr2</a> &amp;other)
00288       {
00289       std::swap(d,other.<a class="code" href="classarr2.html#r3">d</a>);
00290       std::swap(s1,other.<a class="code" href="classarr2.html#r0">s1</a>);
00291       std::swap(s2,other.<a class="code" href="classarr2.html#r1">s2</a>);
00292       std::swap(cap, other.<a class="code" href="classarr2.html#r2">cap</a>);
00293       }
00294   };
00295 <span class="comment"></span>
00296 <span class="comment">/*! Two-dimensional array type. An entry is located by double dereferencing,</span>
00297 <span class="comment">    i.e. via an array of pointers. The indices start at zero. */</span>
<a name="l00298"></a><a class="code" href="classarr2b.html">00298</a> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class </span><a class="code" href="classarr2b.html">arr2b</a>
00299   {
00300   <span class="keyword">private</span>:
00301     <span class="keywordtype">long</span> s1, s2;
00302     T *d;
00303     T **d1;
00304 
00305 <span class="preprocessor">#if defined (PLANCK_CHECKS)</span>
00306 <span class="preprocessor"></span>    <span class="keywordtype">void</span> check_range(<span class="keywordtype">long</span> n)<span class="keyword"> const</span>
00307 <span class="keyword">      </span>{
00308       <span class="keywordflow">if</span> ((n&lt;0) || (n&gt;=s1)) <span class="keywordflow">throw</span> Message_error
00309         (<span class="stringliteral">"arr: index "</span>+<a class="code" href="group__stringutilsgroup.html#ga1">dataToString</a>(n)+<span class="stringliteral">" is out of range. Max index is "</span>
00310          +<a class="code" href="group__stringutilsgroup.html#ga1">dataToString</a>(s1-1));
00311       }
00312 <span class="preprocessor">#endif</span>
00313 <span class="preprocessor"></span>
00314   <span class="keyword">public</span>:<span class="comment"></span>
00315 <span class="comment">    /*! Creates a zero-sized array. */</span>
<a name="l00316"></a><a class="code" href="classarr2b.html#a0">00316</a>     <a class="code" href="classarr2b.html">arr2b</a>() : s1(0), s2(0), d(0), d1(0) {}<span class="comment"></span>
00317 <span class="comment">    /*! Creates an array with the dimensions \a sz1 and \a sz2. */</span>
<a name="l00318"></a><a class="code" href="classarr2b.html#a1">00318</a>     <a class="code" href="classarr2b.html">arr2b</a>(<span class="keywordtype">long</span> sz1, <span class="keywordtype">long</span> sz2)
00319       : s1(sz1), s2(sz2), d(new T[s1*s2]), d1(new T*[s1])
00320       { <span class="keywordflow">for</span> (<span class="keywordtype">long</span> m=0; m&lt;s1; ++m) d1[m] = &amp;d[m*s2]; }<span class="comment"></span>
00321 <span class="comment">    /*! Creates the array as a copy of \a orig. */</span>
<a name="l00322"></a><a class="code" href="classarr2b.html#a2">00322</a>     <a class="code" href="classarr2b.html">arr2b</a>(<span class="keyword">const</span> <a class="code" href="classarr2b.html">arr2b</a> &amp;orig)
00323       : s1(orig.s1), s2(orig.s2), d (s1&gt;0 ? new T[s1*s2] : 0),
00324         d1 (s1&gt;0 ? new T*[s1] : 0)
00325       {
00326       <span class="keywordflow">for</span> (<span class="keywordtype">long</span> m=0; m&lt;s1*s2; ++m) d[m] = orig.<a class="code" href="classarr2b.html#r2">d</a>[m];
00327       <span class="keywordflow">for</span> (<span class="keywordtype">long</span> m=0; m&lt;s1; ++m) d1[m] = &amp;d[m*s2];
00328       }<span class="comment"></span>
00329 <span class="comment">    /*! Frees the memory associated with the array. */</span>
<a name="l00330"></a><a class="code" href="classarr2b.html#a3">00330</a>     ~<a class="code" href="classarr2b.html">arr2b</a>() { <span class="keyword">delete</span>[] d; <span class="keyword">delete</span>[] d1; }
00331 <span class="comment"></span>
00332 <span class="comment">    /*! Returns the first array dimension. */</span>
<a name="l00333"></a><a class="code" href="classarr2b.html#a4">00333</a>     <span class="keywordtype">long</span> size1()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> s1; }<span class="comment"></span>
00334 <span class="comment">    /*! Returns the second array dimension. */</span>
<a name="l00335"></a><a class="code" href="classarr2b.html#a5">00335</a>     <span class="keywordtype">long</span> size2()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> s2; }<span class="comment"></span>
00336 <span class="comment">    /*! Returns the total array size, i.e. the product of both dimensions. */</span>
<a name="l00337"></a><a class="code" href="classarr2b.html#a6">00337</a>     <span class="keywordtype">long</span> size ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> s1*s2; }
00338 <span class="comment"></span>
00339 <span class="comment">    /*! Allocates space for an array with \a sz1*sz2 elements.</span>
00340 <span class="comment">        The content of the array is undefined on exit. */</span>
<a name="l00341"></a><a class="code" href="classarr2b.html#a7">00341</a>     <span class="keywordtype">void</span> alloc (<span class="keywordtype">long</span> sz1, <span class="keywordtype">long</span> sz2)
00342       {
00343       s1=sz1; s2=sz2;
00344       <span class="keyword">delete</span>[] d;
00345       d = s1&gt;0 ? <span class="keyword">new</span> T[s1*s2] : 0;
00346       d1 = s1&gt;0 ? <span class="keyword">new</span> T*[s1] : 0;
00347       <span class="keywordflow">for</span> (<span class="keywordtype">long</span> m=0; m&lt;s1; ++m) d1[m] = &amp;d[m*s2];
00348       }<span class="comment"></span>
00349 <span class="comment">    /*! Deallocates the space and makes the array zero-sized. */</span>
<a name="l00350"></a><a class="code" href="classarr2b.html#a8">00350</a>     <span class="keywordtype">void</span> dealloc () {<span class="keyword">delete</span>[] d; <span class="keyword">delete</span>[] d1; d=0; d1=0; s1=0; s2=0;}
00351 <span class="comment"></span>
00352 <span class="comment">    /*! Sets all array elements to \a val. */</span>
<a name="l00353"></a><a class="code" href="classarr2b.html#a9">00353</a>     <span class="keywordtype">void</span> fill (<span class="keyword">const</span> T &amp;val)
00354       { <span class="keywordflow">for</span> (<span class="keywordtype">long</span> m=0; m&lt;s1*s2; ++m) d[m]=val; }
00355 <span class="comment"></span>
00356 <span class="comment">    /*! Changes the array to be a copy of \a orig. */</span>
<a name="l00357"></a><a class="code" href="classarr2b.html#a10">00357</a>     <a class="code" href="classarr2b.html">arr2b</a> &amp;operator= (<span class="keyword">const</span> <a class="code" href="classarr2b.html">arr2b</a> &amp;orig)
00358       {
00359       <span class="keywordflow">if</span> (<span class="keyword">this</span>==&amp;orig) <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00360       alloc (orig.<a class="code" href="classarr2b.html#r0">s1</a>, orig.<a class="code" href="classarr2b.html#r1">s2</a>);
00361       <span class="keywordflow">for</span> (<span class="keywordtype">long</span> m=0; m&lt;s1*s2; ++m) d[m] = orig.<a class="code" href="classarr2b.html#r2">d</a>[m];
00362       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00363       }
00364 
00365 <span class="preprocessor">#if defined (PLANCK_CHECKS)</span>
00366 <span class="preprocessor"></span>    T *operator[] (<span class="keywordtype">long</span> n) {check_range(n); <span class="keywordflow">return</span> d1[n];}
00367     T *operator[] (<span class="keywordtype">int</span> n) {check_range(n); <span class="keywordflow">return</span> d1[n];}
00368     <span class="keyword">const</span> T *operator[] (<span class="keywordtype">long</span> n)<span class="keyword"> const </span>{check_range(n); <span class="keywordflow">return</span> d1[n];}
00369     <span class="keyword">const</span> T *operator[] (<span class="keywordtype">int</span> n)<span class="keyword"> const </span>{check_range(n); <span class="keywordflow">return</span> d1[n];}
00370 <span class="preprocessor">#else</span>
00371 <span class="preprocessor"></span><span class="comment">    /*! Returns a pointer to the beginning of slice \a #n. */</span>
<a name="l00372"></a><a class="code" href="classarr2b.html#a11">00372</a>     T *operator[] (<span class="keywordtype">long</span> n) {<span class="keywordflow">return</span> d1[n];}<span class="comment"></span>
00373 <span class="comment">    /*! Returns a pointer to the beginning of slice \a #n. */</span>
<a name="l00374"></a><a class="code" href="classarr2b.html#a12">00374</a>     T *operator[] (<span class="keywordtype">int</span> n) {<span class="keywordflow">return</span> d1[n];}<span class="comment"></span>
00375 <span class="comment">    /*! Returns a constant pointer to the beginning of slice \a #n. */</span>
<a name="l00376"></a><a class="code" href="classarr2b.html#a13">00376</a>     <span class="keyword">const</span> T *operator[] (<span class="keywordtype">long</span> n)<span class="keyword"> const </span>{<span class="keywordflow">return</span> d1[n];}<span class="comment"></span>
00377 <span class="comment">    /*! Returns a constant pointer to the beginning of slice \a #n. */</span>
<a name="l00378"></a><a class="code" href="classarr2b.html#a14">00378</a>     <span class="keyword">const</span> T *operator[] (<span class="keywordtype">int</span> n)<span class="keyword"> const </span>{<span class="keywordflow">return</span> d1[n];}
00379 <span class="preprocessor">#endif</span>
00380 <span class="preprocessor"></span><span class="comment">    /*! Returns a pointer to the beginning of the pointer array. */</span>
<a name="l00381"></a><a class="code" href="classarr2b.html#a15">00381</a>     operator T **() {<span class="keywordflow">return</span> d1;}
00382   };
00383 
00384 
00385 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class </span>arr3
00386   {
00387   <span class="keyword">private</span>:
00388     <span class="keywordtype">long</span> s1, s2, s3, s2s3;
00389     T *d;
00390 
00391   <span class="keyword">public</span>:
00392     arr3() : s1(0), s2(0), s3(0), s2s3(0), d(0) {}
00393     arr3(<span class="keywordtype">long</span> sz1, <span class="keywordtype">long</span> sz2, <span class="keywordtype">long</span> sz3)
00394       : s1(sz1), s2(sz2), s3(sz3), s2s3(s2*s3),
00395         d (s1*s2*s3&gt;0 ? new T[s1*s2*s3] : 0) {}
00396     arr3(<span class="keyword">const</span> arr3 &amp;orig)
00397       : s1(orig.s1), s2(orig.s2), s3(orig.s3), s2s3(s2*s3),
00398         d (s1*s2*s3&gt;0 ? new T[s1*s2*s3] : 0)
00399       { <span class="keywordflow">for</span> (<span class="keywordtype">long</span> m=0; m&lt;s1*s2*s3; ++m) d[m] = orig.<a class="code" href="classarr2b.html#r2">d</a>[m];}
00400     ~arr3() { <span class="keyword">delete</span>[] d; }
00401 
00402     <span class="keywordtype">long</span> size1()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> s1; }
00403     <span class="keywordtype">long</span> size2()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> s2; }
00404     <span class="keywordtype">long</span> size3()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> s3; }
00405     <span class="keywordtype">long</span> size ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> s1*s2*s3; }
00406 
00407     <span class="keywordtype">void</span> alloc (<span class="keywordtype">long</span> sz1, <span class="keywordtype">long</span> sz2, <span class="keywordtype">long</span> sz3)
00408       {
00409       <span class="keywordflow">if</span> (sz1*sz2*sz3 != s1*s2*s3)
00410         {
00411         <span class="keyword">delete</span>[] d;
00412         d = sz1*sz2*sz3&gt;0 ? <span class="keyword">new</span> T[sz1*sz2*sz3] : 0;
00413         }
00414       s1=sz1; s2=sz2; s3=sz3; s2s3=s2*s3;
00415       }
00416     <span class="keywordtype">void</span> dealloc () {<span class="keyword">delete</span>[] d; d=0; s1=0; s2=0; s3=0; s2s3=0;}
00417 
00418     <span class="keywordtype">void</span> fill (<span class="keyword">const</span> T &amp;val)
00419       { <span class="keywordflow">for</span> (<span class="keywordtype">long</span> m=0; m&lt;s1*s2*s3; ++m) d[m]=val; }
00420 
00421     arr3 &amp;operator= (<span class="keyword">const</span> arr3 &amp;orig)
00422       {
00423       <span class="keywordflow">if</span> (<span class="keyword">this</span>==&amp;orig) <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00424       alloc (orig.s1, orig.s2, orig.s3);
00425       <span class="keywordflow">for</span> (<span class="keywordtype">long</span> m=0; m&lt;s1*s2*s3; ++m) d[m] = orig.<a class="code" href="classarr2b.html#r2">d</a>[m];
00426       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00427       }
00428 
00429     T &amp;operator() (<span class="keywordtype">long</span> n1, <span class="keywordtype">long</span> n2, <span class="keywordtype">long</span> n3)
00430       {<span class="keywordflow">return</span> d[n1*s2s3 + n2*s3 + n3];}
00431     <span class="keyword">const</span> T &amp;operator() (<span class="keywordtype">long</span> n1, <span class="keywordtype">long</span> n2, <span class="keywordtype">long</span> n3)<span class="keyword"> const</span>
00432 <span class="keyword">      </span>{<span class="keywordflow">return</span> d[n1*s2s3 + n2*s3 + n3];}
00433 
00434     <span class="keywordtype">void</span> swap (arr3 &amp;other)
00435       {
00436       std::swap(d,other.d);
00437       std::swap(s1,other.s1);
00438       std::swap(s2,other.s2);
00439       std::swap(s3,other.s3);
00440       std::swap(s2s3,other.s2s3);
00441       }
00442   };
00443 <span class="comment"></span>
00444 <span class="comment">/*! \} */</span>
00445 
00446 <span class="preprocessor">#endif</span>
</pre></div><hr><address style="align: right;"><small>
Generated on Fri Jul 8 09:37:14 2005 for LevelS C++ support library
</a> </small></address>
</body>
</html>
