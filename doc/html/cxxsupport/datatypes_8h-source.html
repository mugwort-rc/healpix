<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>LevelS C++ support library: datatypes.h Source File</title>
<link href="sheet.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">cxxsupport</a></div>
<h1>datatypes.h</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> *  This file is part of Healpix_cxx.</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> *  Healpix_cxx is free software; you can redistribute it and/or modify</span>
00005 <span class="comment"> *  it under the terms of the GNU General Public License as published by</span>
00006 <span class="comment"> *  the Free Software Foundation; either version 2 of the License, or</span>
00007 <span class="comment"> *  (at your option) any later version.</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> *  Healpix_cxx is distributed in the hope that it will be useful,</span>
00010 <span class="comment"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00012 <span class="comment"> *  GNU General Public License for more details.</span>
00013 <span class="comment"> *</span>
00014 <span class="comment"> *  You should have received a copy of the GNU General Public License</span>
00015 <span class="comment"> *  along with Healpix_cxx; if not, write to the Free Software</span>
00016 <span class="comment"> *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
00017 <span class="comment"> *</span>
00018 <span class="comment"> *  For more information about HEALPix, see http://healpix.jpl.nasa.gov</span>
00019 <span class="comment"> */</span>
00020 
00021 <span class="comment">/*</span>
00022 <span class="comment"> *  Healpix_cxx is being developed at the Max-Planck-Institut fuer Astrophysik</span>
00023 <span class="comment"> *  and financially supported by the Deutsches Zentrum fuer Luft- und Raumfahrt</span>
00024 <span class="comment"> *  (DLR).</span>
00025 <span class="comment"> */</span>
00026 
00027 <span class="comment">/*</span>
00028 <span class="comment"> *  This file defines various platform-independent data types.</span>
00029 <span class="comment"> *  If any of the requested types is not available, compilation aborts</span>
00030 <span class="comment"> *  with an error (unfortunately a rather obscure one).</span>
00031 <span class="comment"> *</span>
00032 <span class="comment"> *  Copyright (C) 2004 Max-Planck-Society</span>
00033 <span class="comment"> *  Author: Martin Reinecke</span>
00034 <span class="comment"> */</span>
00035 
00036 <span class="preprocessor">#ifndef PLANCK_DATATYPES_H</span>
00037 <span class="preprocessor"></span><span class="preprocessor">#define PLANCK_DATATYPES_H</span>
00038 <span class="preprocessor"></span>
00039 <span class="preprocessor">#include &lt;string&gt;</span>
00040 <span class="preprocessor">#include "message_error.h"</span>
00041 
00042 <span class="comment">// Template magic to select the proper data types. These templates</span>
00043 <span class="comment">// should not be used outside this file.</span>
00044 
00045 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keywordtype">bool</span> equalSize&gt; <span class="keyword">struct </span>sizeChooserHelper
00046   { <span class="keyword">typedef</span> <span class="keywordtype">void</span> TYPE; };
00047 
00048 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span>sizeChooserHelper&lt;T,true&gt;
00049   { <span class="keyword">typedef</span> T TYPE; };
00050 
00051 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt; <span class="keyword">struct </span>sizeChooserHelper2
00052   { <span class="keyword">typedef</span> T1 TYPE; };
00053 
00054 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt; <span class="keyword">struct </span>sizeChooserHelper2 &lt;void, T2, T3&gt;
00055   { <span class="keyword">typedef</span> T2 TYPE; };
00056 
00057 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T3&gt; <span class="keyword">struct </span>sizeChooserHelper2 &lt;void, void, T3&gt;
00058   { <span class="keyword">typedef</span> T3 TYPE; };
00059 
00060 <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>sizeChooserHelper2 &lt;void, void, void&gt;
00061   { };
00062 
00063 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> sz, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2=<span class="keywordtype">char</span>, <span class="keyword">typename</span> T3=<span class="keywordtype">char</span>&gt;
00064   <span class="keyword">struct </span>sizeChooser
00065   {
00066   <span class="keyword">typedef</span> <span class="keyword">typename</span> sizeChooserHelper2
00067     &lt;<span class="keyword">typename</span> sizeChooserHelper&lt;T1,sizeof(T1)==sz&gt;::TYPE,
00068      <span class="keyword">typename</span> sizeChooserHelper&lt;T2,sizeof(T2)==sz&gt;::TYPE,
00069      <span class="keyword">typename</span> sizeChooserHelper&lt;T3,sizeof(T3)==sz&gt;::TYPE &gt;::TYPE TYPE;
00070   };
00071 
00072 <span class="keyword">typedef</span> sizeChooser&lt;4, int, long, short&gt;::TYPE
00073   int32;
00074 <span class="keyword">typedef</span> sizeChooser&lt;4, unsigned int, unsigned long, unsigned short&gt;::TYPE
00075   uint32;
00076 
00077 <span class="keyword">typedef</span> sizeChooser&lt;8, long, long long&gt;::TYPE
00078   int64;
00079 <span class="keyword">typedef</span> sizeChooser&lt;8, unsigned long, unsigned long long&gt;::TYPE
00080   uint64;
00081 
00082 <span class="keyword">typedef</span> sizeChooser&lt;4, float, double&gt;::TYPE
00083   float32;
00084 <span class="keyword">typedef</span> sizeChooser&lt;8, double, long double&gt;::TYPE
00085   float64;
00086 
00087 <span class="comment">// mapping of types to integer constants</span>
00088 <span class="keyword">enum</span> { PLANCK_INT32   = 0,
00089        PLANCK_UINT32  = 1,
00090        PLANCK_INT64   = 2,
00091        PLANCK_UINT64  = 3,
00092        PLANCK_FLOAT32 = 4,
00093        PLANCK_FLOAT64 = 5,
00094        PLANCK_BOOL    = 6,
00095        PLANCK_STRING  = 7 };
00096 
00097 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span>typehelper {};
00098 
00099 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>typehelper&lt;int32&gt;
00100   { <span class="keyword">enum</span> { <span class="keywordtype">id</span>=PLANCK_INT32 }; };
00101 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>typehelper&lt;uint32&gt;
00102   { <span class="keyword">enum</span> { <span class="keywordtype">id</span>=PLANCK_UINT32 }; };
00103 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>typehelper&lt;int64&gt;
00104   { <span class="keyword">enum</span> { <span class="keywordtype">id</span>=PLANCK_INT64 }; };
00105 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>typehelper&lt;uint64&gt;
00106   { <span class="keyword">enum</span> { <span class="keywordtype">id</span>=PLANCK_UINT64 }; };
00107 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>typehelper&lt;float32&gt;
00108   { <span class="keyword">enum</span> { <span class="keywordtype">id</span>=PLANCK_FLOAT32 }; };
00109 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>typehelper&lt;float64&gt;
00110   { <span class="keyword">enum</span> { <span class="keywordtype">id</span>=PLANCK_FLOAT64 }; };
00111 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>typehelper&lt;bool&gt;
00112   { <span class="keyword">enum</span> { <span class="keywordtype">id</span>=PLANCK_BOOL }; };
00113 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>typehelper&lt;std::string&gt;
00114   { <span class="keyword">enum</span> { <span class="keywordtype">id</span>=PLANCK_STRING }; };
00115 
00116 <span class="keyword">inline</span> <span class="keywordtype">int</span> type2size (<span class="keywordtype">int</span> type)
00117   {
00118   <span class="keywordflow">switch</span> (type)
00119     {
00120     <span class="keywordflow">case</span> PLANCK_INT32  : <span class="keywordflow">return</span> 4;
00121     <span class="keywordflow">case</span> PLANCK_UINT32 : <span class="keywordflow">return</span> 4;
00122     <span class="keywordflow">case</span> PLANCK_INT64  : <span class="keywordflow">return</span> 8;
00123     <span class="keywordflow">case</span> PLANCK_UINT64 : <span class="keywordflow">return</span> 8;
00124     <span class="keywordflow">case</span> PLANCK_FLOAT32: <span class="keywordflow">return</span> 4;
00125     <span class="keywordflow">case</span> PLANCK_FLOAT64: <span class="keywordflow">return</span> 8;
00126     <span class="keywordflow">case</span> PLANCK_BOOL   : <span class="keywordflow">return</span> 1;
00127     <span class="keywordflow">case</span> PLANCK_STRING : <span class="keywordflow">return</span> 1;
00128     <span class="keywordflow">default</span>: <span class="keywordflow">throw</span> Message_error (<span class="stringliteral">"unsupported data type"</span>);
00129     }
00130   }
00131 
00132 <span class="keyword">inline</span> <span class="keywordtype">int</span> string2type(<span class="keyword">const</span> std::string &amp;type)
00133   {
00134   <span class="keywordflow">if</span> (type==<span class="stringliteral">"FLOAT64"</span>) <span class="keywordflow">return</span> PLANCK_FLOAT64;
00135   <span class="keywordflow">if</span> (type==<span class="stringliteral">"FLOAT32"</span>) <span class="keywordflow">return</span> PLANCK_FLOAT32;
00136   <span class="keywordflow">if</span> (type==<span class="stringliteral">"INT32"</span>)   <span class="keywordflow">return</span> PLANCK_INT32;
00137   <span class="keywordflow">if</span> (type==<span class="stringliteral">"UINT32"</span>)  <span class="keywordflow">return</span> PLANCK_UINT32;
00138   <span class="keywordflow">if</span> (type==<span class="stringliteral">"INT64"</span>)   <span class="keywordflow">return</span> PLANCK_INT64;
00139   <span class="keywordflow">if</span> (type==<span class="stringliteral">"UINT64"</span>)  <span class="keywordflow">return</span> PLANCK_UINT64;
00140   <span class="keywordflow">if</span> (type==<span class="stringliteral">"BOOL"</span>)    <span class="keywordflow">return</span> PLANCK_BOOL;
00141   <span class="keywordflow">if</span> (type==<span class="stringliteral">"STRING"</span>)  <span class="keywordflow">return</span> PLANCK_STRING;
00142   <span class="keywordflow">throw</span> Message_error (<span class="stringliteral">"unknown data type "</span>+type);
00143   }
00144 
00145 <span class="preprocessor">#endif</span>
</pre></div><hr><address style="align: right;"><small>
Generated on Fri Jul 8 09:37:14 2005 for LevelS C++ support library
</a> </small></address>
</body>
</html>
