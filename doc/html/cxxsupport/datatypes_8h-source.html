<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>datatypes.h Source File</title>
<link href="sheet.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>datatypes.h</h1><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> *  This file is part of Healpix_cxx.</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> *  Healpix_cxx is free software; you can redistribute it and/or modify</span>
00005 <span class="comment"> *  it under the terms of the GNU General Public License as published by</span>
00006 <span class="comment"> *  the Free Software Foundation; either version 2 of the License, or</span>
00007 <span class="comment"> *  (at your option) any later version.</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> *  Healpix_cxx is distributed in the hope that it will be useful,</span>
00010 <span class="comment"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00012 <span class="comment"> *  GNU General Public License for more details.</span>
00013 <span class="comment"> *</span>
00014 <span class="comment"> *  You should have received a copy of the GNU General Public License</span>
00015 <span class="comment"> *  along with Healpix_cxx; if not, write to the Free Software</span>
00016 <span class="comment"> *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
00017 <span class="comment"> *</span>
00018 <span class="comment"> *  For more information about HEALPix, see http://healpix.jpl.nasa.gov</span>
00019 <span class="comment"> */</span>
00020 
00021 <span class="comment">/*</span>
00022 <span class="comment"> *  Healpix_cxx is being developed at the Max-Planck-Institut fuer Astrophysik</span>
00023 <span class="comment"> *  and financially supported by the Deutsches Zentrum fuer Luft- und Raumfahrt</span>
00024 <span class="comment"> *  (DLR).</span>
00025 <span class="comment"> */</span>
00026 
00027 <span class="comment">/*</span>
00028 <span class="comment"> *  This file defines various platform-independent data types.</span>
00029 <span class="comment"> *  If any of the requested types is not available, compilation aborts</span>
00030 <span class="comment"> *  with an error (unfortunately a rather obscure one).</span>
00031 <span class="comment"> *</span>
00032 <span class="comment"> *  Copyright (C) 2004 Max-Planck-Society</span>
00033 <span class="comment"> *  Author: Martin Reinecke</span>
00034 <span class="comment"> */</span>
00035 
00036 <span class="preprocessor">#ifndef PLANCK_DATATYPES_H</span>
00037 <span class="preprocessor"></span><span class="preprocessor">#define PLANCK_DATATYPES_H</span>
00038 <span class="preprocessor"></span>
00039 <span class="preprocessor">#include &lt;string&gt;</span>
00040 <span class="preprocessor">#include "message_error.h"</span>
00041 
00042 <span class="comment">// Template magic to select the proper data types. These templates</span>
00043 <span class="comment">// should not be used outside this file.</span>
00044 
00045 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keywordtype">bool</span> equalSize&gt; <span class="keyword">struct </span>sizeChooserHelper
00046   { <span class="keyword">typedef</span> <span class="keywordtype">void</span> TYPE; };
00047 
00048 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span>sizeChooserHelper&lt;T,true&gt;
00049   { <span class="keyword">typedef</span> T TYPE; };
00050 
00051 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt; <span class="keyword">struct </span>sizeChooserHelper2
00052   { <span class="keyword">typedef</span> T1 TYPE; };
00053 
00054 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt; <span class="keyword">struct </span>sizeChooserHelper2 &lt;void, T2, T3&gt;
00055   { <span class="keyword">typedef</span> T2 TYPE; };
00056 
00057 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T3&gt; <span class="keyword">struct </span>sizeChooserHelper2 &lt;void, void, T3&gt;
00058   { <span class="keyword">typedef</span> T3 TYPE; };
00059 
00060 <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>sizeChooserHelper2 &lt;void, void, void&gt;
00061   { };
00062 
00063 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> sz, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2=<span class="keywordtype">char</span>, <span class="keyword">typename</span> T3=<span class="keywordtype">char</span>&gt;
00064   <span class="keyword">struct </span>sizeChooser
00065   {
00066   <span class="keyword">typedef</span> <span class="keyword">typename</span> sizeChooserHelper2
00067     &lt;<span class="keyword">typename</span> sizeChooserHelper&lt;T1,sizeof(T1)==sz&gt;::TYPE,
00068      <span class="keyword">typename</span> sizeChooserHelper&lt;T2,sizeof(T2)==sz&gt;::TYPE,
00069      <span class="keyword">typename</span> sizeChooserHelper&lt;T3,sizeof(T3)==sz&gt;::TYPE &gt;::TYPE TYPE;
00070   };
00071 
00072 <span class="keyword">typedef</span> <span class="keywordtype">signed</span> <span class="keywordtype">char</span> int8;
00073 <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> uint8;
00074 
00075 <span class="keyword">typedef</span> sizeChooser&lt;2, short, int&gt;::TYPE
00076   int16;
00077 <span class="keyword">typedef</span> sizeChooser&lt;2, unsigned short, unsigned int&gt;::TYPE
00078   uint16;
00079 
00080 <span class="keyword">typedef</span> sizeChooser&lt;4, int, long, short&gt;::TYPE
00081   int32;
00082 <span class="keyword">typedef</span> sizeChooser&lt;4, unsigned int, unsigned long, unsigned short&gt;::TYPE
00083   uint32;
00084 
00085 <span class="keyword">typedef</span> sizeChooser&lt;8, long, long long&gt;::TYPE
00086   int64;
00087 <span class="keyword">typedef</span> sizeChooser&lt;8, unsigned long, unsigned long long&gt;::TYPE
00088   uint64;
00089 
00090 <span class="keyword">typedef</span> sizeChooser&lt;4, float, double&gt;::TYPE
00091   float32;
00092 <span class="keyword">typedef</span> sizeChooser&lt;8, double, long double&gt;::TYPE
00093   float64;
00094 
00095 <span class="comment">// mapping of types to integer constants</span>
00096 <span class="keyword">enum</span> { PLANCK_INT8    =  0,
00097        PLANCK_UINT8   =  1,
00098        PLANCK_INT16   =  2,
00099        PLANCK_UINT16  =  3,
00100        PLANCK_INT32   =  4,
00101        PLANCK_UINT32  =  5,
00102        PLANCK_INT64   =  6,
00103        PLANCK_UINT64  =  7,
00104        PLANCK_FLOAT32 =  8,
00105        PLANCK_FLOAT64 =  9,
00106        PLANCK_BOOL    = 10,
00107        PLANCK_STRING  = 11 };
00108 
00109 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span>typehelper {};
00110 
00111 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>typehelper&lt;int8&gt;
00112   { <span class="keyword">enum</span> { id=PLANCK_INT8 }; };
00113 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>typehelper&lt;uint8&gt;
00114   { <span class="keyword">enum</span> { id=PLANCK_UINT8 }; };
00115 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>typehelper&lt;int16&gt;
00116   { <span class="keyword">enum</span> { id=PLANCK_INT16 }; };
00117 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>typehelper&lt;uint16&gt;
00118   { <span class="keyword">enum</span> { id=PLANCK_UINT16 }; };
00119 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>typehelper&lt;int32&gt;
00120   { <span class="keyword">enum</span> { id=PLANCK_INT32 }; };
00121 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>typehelper&lt;uint32&gt;
00122   { <span class="keyword">enum</span> { id=PLANCK_UINT32 }; };
00123 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>typehelper&lt;int64&gt;
00124   { <span class="keyword">enum</span> { id=PLANCK_INT64 }; };
00125 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>typehelper&lt;uint64&gt;
00126   { <span class="keyword">enum</span> { id=PLANCK_UINT64 }; };
00127 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>typehelper&lt;float32&gt;
00128   { <span class="keyword">enum</span> { id=PLANCK_FLOAT32 }; };
00129 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>typehelper&lt;float64&gt;
00130   { <span class="keyword">enum</span> { id=PLANCK_FLOAT64 }; };
00131 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>typehelper&lt;bool&gt;
00132   { <span class="keyword">enum</span> { id=PLANCK_BOOL }; };
00133 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>typehelper&lt;std::string&gt;
00134   { <span class="keyword">enum</span> { id=PLANCK_STRING }; };
00135 
00136 <span class="keyword">inline</span> <span class="keywordtype">int</span> type2size (<span class="keywordtype">int</span> type)
00137   {
00138   <span class="keywordflow">switch</span> (type)
00139     {
00140     <span class="keywordflow">case</span> PLANCK_INT8   : <span class="keywordflow">return</span> 1;
00141     <span class="keywordflow">case</span> PLANCK_UINT8  : <span class="keywordflow">return</span> 1;
00142     <span class="keywordflow">case</span> PLANCK_INT16  : <span class="keywordflow">return</span> 2;
00143     <span class="keywordflow">case</span> PLANCK_UINT16 : <span class="keywordflow">return</span> 2;
00144     <span class="keywordflow">case</span> PLANCK_INT32  : <span class="keywordflow">return</span> 4;
00145     <span class="keywordflow">case</span> PLANCK_UINT32 : <span class="keywordflow">return</span> 4;
00146     <span class="keywordflow">case</span> PLANCK_INT64  : <span class="keywordflow">return</span> 8;
00147     <span class="keywordflow">case</span> PLANCK_UINT64 : <span class="keywordflow">return</span> 8;
00148     <span class="keywordflow">case</span> PLANCK_FLOAT32: <span class="keywordflow">return</span> 4;
00149     <span class="keywordflow">case</span> PLANCK_FLOAT64: <span class="keywordflow">return</span> 8;
00150     <span class="keywordflow">case</span> PLANCK_BOOL   : <span class="keywordflow">return</span> 1;
00151     <span class="keywordflow">case</span> PLANCK_STRING : <span class="keywordflow">return</span> 1;
00152     <span class="keywordflow">default</span>: <span class="keywordflow">throw</span> Message_error (<span class="stringliteral">"unsupported data type"</span>);
00153     }
00154   }
00155 
00156 <span class="keyword">inline</span> <span class="keywordtype">int</span> string2type(<span class="keyword">const</span> std::string &amp;type)
00157   {
00158   <span class="keywordflow">if</span> (type==<span class="stringliteral">"FLOAT64"</span>) <span class="keywordflow">return</span> PLANCK_FLOAT64;
00159   <span class="keywordflow">if</span> (type==<span class="stringliteral">"FLOAT32"</span>) <span class="keywordflow">return</span> PLANCK_FLOAT32;
00160   <span class="keywordflow">if</span> (type==<span class="stringliteral">"INT8"</span>)    <span class="keywordflow">return</span> PLANCK_INT8;
00161   <span class="keywordflow">if</span> (type==<span class="stringliteral">"UINT8"</span>)   <span class="keywordflow">return</span> PLANCK_UINT8;
00162   <span class="keywordflow">if</span> (type==<span class="stringliteral">"INT16"</span>)   <span class="keywordflow">return</span> PLANCK_INT16;
00163   <span class="keywordflow">if</span> (type==<span class="stringliteral">"UINT16"</span>)  <span class="keywordflow">return</span> PLANCK_UINT16;
00164   <span class="keywordflow">if</span> (type==<span class="stringliteral">"INT32"</span>)   <span class="keywordflow">return</span> PLANCK_INT32;
00165   <span class="keywordflow">if</span> (type==<span class="stringliteral">"UINT32"</span>)  <span class="keywordflow">return</span> PLANCK_UINT32;
00166   <span class="keywordflow">if</span> (type==<span class="stringliteral">"INT64"</span>)   <span class="keywordflow">return</span> PLANCK_INT64;
00167   <span class="keywordflow">if</span> (type==<span class="stringliteral">"UINT64"</span>)  <span class="keywordflow">return</span> PLANCK_UINT64;
00168   <span class="keywordflow">if</span> (type==<span class="stringliteral">"BOOL"</span>)    <span class="keywordflow">return</span> PLANCK_BOOL;
00169   <span class="keywordflow">if</span> (type==<span class="stringliteral">"STRING"</span>)  <span class="keywordflow">return</span> PLANCK_STRING;
00170   <span class="keywordflow">throw</span> Message_error (<span class="stringliteral">"unknown data type "</span>+type);
00171   }
00172 
00173 <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *type2string (<span class="keywordtype">int</span> type)
00174   {
00175   <span class="keywordflow">switch</span> (type)
00176     {
00177     <span class="keywordflow">case</span> PLANCK_INT8   : <span class="keywordflow">return</span> <span class="stringliteral">"INT8"</span>;
00178     <span class="keywordflow">case</span> PLANCK_UINT8  : <span class="keywordflow">return</span> <span class="stringliteral">"UINT8"</span>;
00179     <span class="keywordflow">case</span> PLANCK_INT16  : <span class="keywordflow">return</span> <span class="stringliteral">"INT16"</span>;
00180     <span class="keywordflow">case</span> PLANCK_UINT16 : <span class="keywordflow">return</span> <span class="stringliteral">"UINT16"</span>;
00181     <span class="keywordflow">case</span> PLANCK_INT32  : <span class="keywordflow">return</span> <span class="stringliteral">"INT32"</span>;
00182     <span class="keywordflow">case</span> PLANCK_UINT32 : <span class="keywordflow">return</span> <span class="stringliteral">"UINT32"</span>;
00183     <span class="keywordflow">case</span> PLANCK_INT64  : <span class="keywordflow">return</span> <span class="stringliteral">"INT64"</span>;
00184     <span class="keywordflow">case</span> PLANCK_UINT64 : <span class="keywordflow">return</span> <span class="stringliteral">"UINT64"</span>;
00185     <span class="keywordflow">case</span> PLANCK_FLOAT32: <span class="keywordflow">return</span> <span class="stringliteral">"FLOAT32"</span>;
00186     <span class="keywordflow">case</span> PLANCK_FLOAT64: <span class="keywordflow">return</span> <span class="stringliteral">"FLOAT64"</span>;
00187     <span class="keywordflow">case</span> PLANCK_BOOL   : <span class="keywordflow">return</span> <span class="stringliteral">"BOOL"</span>;
00188     <span class="keywordflow">case</span> PLANCK_STRING : <span class="keywordflow">return</span> <span class="stringliteral">"STRING"</span>;
00189     <span class="keywordflow">default</span>: <span class="keywordflow">throw</span> Message_error (<span class="stringliteral">"unsupported data type"</span>);
00190     }
00191   }
00192 
00193 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *type2typename ()
00194   { <span class="keywordflow">return</span> <span class="stringliteral">"unknown type"</span>; }
00195 <span class="keyword">template</span>&lt;&gt; <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *type2typename&lt;signed char&gt; ()
00196   { <span class="keywordflow">return</span> <span class="stringliteral">"signed char"</span>; }
00197 <span class="keyword">template</span>&lt;&gt; <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *type2typename&lt;unsigned char&gt; ()
00198   { <span class="keywordflow">return</span> <span class="stringliteral">"unsigned char"</span>; }
00199 <span class="keyword">template</span>&lt;&gt; <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *type2typename&lt;short&gt; ()
00200   { <span class="keywordflow">return</span> <span class="stringliteral">"short"</span>; }
00201 <span class="keyword">template</span>&lt;&gt; <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *type2typename&lt;unsigned short&gt; ()
00202   { <span class="keywordflow">return</span> <span class="stringliteral">"unsigned short"</span>; }
00203 <span class="keyword">template</span>&lt;&gt; <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *type2typename&lt;int&gt; ()
00204   { <span class="keywordflow">return</span> <span class="stringliteral">"int"</span>; }
00205 <span class="keyword">template</span>&lt;&gt; <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *type2typename&lt;unsigned int&gt; ()
00206   { <span class="keywordflow">return</span> <span class="stringliteral">"unsigned int"</span>; }
00207 <span class="keyword">template</span>&lt;&gt; <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *type2typename&lt;long&gt; ()
00208   { <span class="keywordflow">return</span> <span class="stringliteral">"long"</span>; }
00209 <span class="keyword">template</span>&lt;&gt; <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *type2typename&lt;unsigned long&gt; ()
00210   { <span class="keywordflow">return</span> <span class="stringliteral">"unsigned long"</span>; }
00211 <span class="keyword">template</span>&lt;&gt; <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *type2typename&lt;long long&gt; ()
00212   { <span class="keywordflow">return</span> <span class="stringliteral">"long long"</span>; }
00213 <span class="keyword">template</span>&lt;&gt; <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *type2typename&lt;unsigned long long&gt; ()
00214   { <span class="keywordflow">return</span> <span class="stringliteral">"unsigned long long"</span>; }
00215 <span class="keyword">template</span>&lt;&gt; <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *type2typename&lt;float&gt; ()
00216   { <span class="keywordflow">return</span> <span class="stringliteral">"float"</span>; }
00217 <span class="keyword">template</span>&lt;&gt; <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *type2typename&lt;double&gt; ()
00218   { <span class="keywordflow">return</span> <span class="stringliteral">"double"</span>; }
00219 <span class="keyword">template</span>&lt;&gt; <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *type2typename&lt;bool&gt; ()
00220   { <span class="keywordflow">return</span> <span class="stringliteral">"bool"</span>; }
00221 <span class="keyword">template</span>&lt;&gt; <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *type2typename&lt;std::string&gt; ()
00222   { <span class="keywordflow">return</span> <span class="stringliteral">"std::string"</span>; }
00223 
00224 <span class="preprocessor">#endif</span>
</pre></div><hr><address style="align: right;"><small>
Generated on Thu Nov 13 18:48:49 2008 for LevelS C++ support library
</a> </small></address>
</body>
</html>
