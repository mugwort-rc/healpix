<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>fitshandle.h Source File</title>
<link href="sheet.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>fitshandle.h</h1><a href="fitshandle_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> *  This file is part of Healpix_cxx.</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> *  Healpix_cxx is free software; you can redistribute it and/or modify</span>
00005 <span class="comment"> *  it under the terms of the GNU General Public License as published by</span>
00006 <span class="comment"> *  the Free Software Foundation; either version 2 of the License, or</span>
00007 <span class="comment"> *  (at your option) any later version.</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> *  Healpix_cxx is distributed in the hope that it will be useful,</span>
00010 <span class="comment"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00012 <span class="comment"> *  GNU General Public License for more details.</span>
00013 <span class="comment"> *</span>
00014 <span class="comment"> *  You should have received a copy of the GNU General Public License</span>
00015 <span class="comment"> *  along with Healpix_cxx; if not, write to the Free Software</span>
00016 <span class="comment"> *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
00017 <span class="comment"> *</span>
00018 <span class="comment"> *  For more information about HEALPix, see http://healpix.jpl.nasa.gov</span>
00019 <span class="comment"> */</span>
00020 
00021 <span class="comment">/*</span>
00022 <span class="comment"> *  Healpix_cxx is being developed at the Max-Planck-Institut fuer Astrophysik</span>
00023 <span class="comment"> *  and financially supported by the Deutsches Zentrum fuer Luft- und Raumfahrt</span>
00024 <span class="comment"> *  (DLR).</span>
00025 <span class="comment"> */</span>
00026 <span class="comment"></span>
00027 <span class="comment">/*! \file fitshandle.h</span>
00028 <span class="comment"> *  Declaration of the FITS I/O helper class used by LevelS</span>
00029 <span class="comment"> *</span>
00030 <span class="comment"> *  Copyright (C) 2002, 2003, 2004, 2005, 2006 Max-Planck-Society</span>
00031 <span class="comment"> *  \author Martin Reinecke</span>
00032 <span class="comment"> */</span>
00033 
00034 <span class="preprocessor">#ifndef PLANCK_FITSHANDLE_H</span>
00035 <span class="preprocessor"></span><span class="preprocessor">#define PLANCK_FITSHANDLE_H</span>
00036 <span class="preprocessor"></span>
00037 <span class="preprocessor">#include &lt;string&gt;</span>
00038 <span class="preprocessor">#include &lt;vector&gt;</span>
00039 <span class="preprocessor">#include "fitsio.h"</span>
00040 <span class="preprocessor">#include "<a class="code" href="arr_8h.html">arr.h</a>"</span>
00041 <span class="preprocessor">#include "datatypes.h"</span>
00042 <span class="comment"></span>
00043 <span class="comment">/*! \defgroup fitsgroup FITS-related functionality */</span><span class="comment"></span>
00044 <span class="comment">/*! \{ */</span>
00045 
00046 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span>FITSUTIL {};
00047 
00048 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>FITSUTIL&lt;signed char&gt;
00049   { <span class="keyword">enum</span> { DTYPE=TBYTE }; };
00050 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>FITSUTIL&lt;short&gt;
00051   { <span class="keyword">enum</span> { DTYPE=TSHORT }; };
00052 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>FITSUTIL&lt;int&gt;
00053   { <span class="keyword">enum</span> { DTYPE=TINT }; };
00054 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>FITSUTIL&lt;long&gt;
00055   { <span class="keyword">enum</span> { DTYPE=TLONG }; };
00056 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>FITSUTIL&lt;long long&gt;
00057   { <span class="keyword">enum</span> { DTYPE=TLONGLONG }; };
00058 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>FITSUTIL&lt;float&gt;
00059   { <span class="keyword">enum</span> { DTYPE=TFLOAT }; };
00060 <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>FITSUTIL&lt;double&gt;
00061   { <span class="keyword">enum</span> { DTYPE=TDOUBLE }; };
00062 <span class="comment"></span>
00063 <span class="comment">/*! Converts a FITS type code (i.e. the data type of a FITS column) to the</span>
00064 <span class="comment">    corresponding Planck type code. */</span>
<a name="l00065"></a><a class="code" href="group__fitsgroup.html#a0">00065</a> <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="group__fitsgroup.html#a0">ftc2type</a> (<span class="keywordtype">int</span> ftc)
00066   {
00067   <span class="keywordflow">switch</span> (ftc)
00068     {
00069     <span class="keywordflow">case</span> TLOGICAL : <span class="keywordflow">return</span> PLANCK_BOOL;
00070     <span class="keywordflow">case</span> TBYTE    : <span class="keywordflow">return</span> PLANCK_INT8;
00071     <span class="keywordflow">case</span> TSHORT   : <span class="keywordflow">return</span> PLANCK_INT16;
00072     <span class="keywordflow">case</span> TINT32BIT: <span class="keywordflow">return</span> PLANCK_INT32;
00073     <span class="keywordflow">case</span> TLONGLONG: <span class="keywordflow">return</span> PLANCK_INT64;
00074     <span class="keywordflow">case</span> TFLOAT   : <span class="keywordflow">return</span> PLANCK_FLOAT32;
00075     <span class="keywordflow">case</span> TDOUBLE  : <span class="keywordflow">return</span> PLANCK_FLOAT64;
00076     <span class="keywordflow">case</span> TSTRING  : <span class="keywordflow">return</span> PLANCK_STRING;
00077     <span class="keywordflow">default</span>: <span class="keywordflow">throw</span> Message_error (<span class="stringliteral">"ftc2type: unsupported component type"</span>);
00078     }
00079   }
00080 <span class="comment"></span>
00081 <span class="comment">/*! Converts a Planck type code to the corresponding FITS type code</span>
00082 <span class="comment">    (i.e. the data type of a FITS column). */</span>
<a name="l00083"></a><a class="code" href="group__fitsgroup.html#a1">00083</a> <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="group__fitsgroup.html#a1">type2ftc</a> (<span class="keywordtype">int</span> type)
00084   {
00085   <span class="keywordflow">switch</span> (type)
00086     {
00087     <span class="keywordflow">case</span> PLANCK_BOOL   : <span class="keywordflow">return</span> TLOGICAL;
00088     <span class="keywordflow">case</span> PLANCK_INT8   : <span class="keywordflow">return</span> TBYTE;
00089     <span class="keywordflow">case</span> PLANCK_INT16  : <span class="keywordflow">return</span> TSHORT;
00090     <span class="keywordflow">case</span> PLANCK_INT32  : <span class="keywordflow">return</span> TINT32BIT;
00091     <span class="keywordflow">case</span> PLANCK_INT64  : <span class="keywordflow">return</span> TLONGLONG;
00092     <span class="keywordflow">case</span> PLANCK_FLOAT32: <span class="keywordflow">return</span> TFLOAT;
00093     <span class="keywordflow">case</span> PLANCK_FLOAT64: <span class="keywordflow">return</span> TDOUBLE;
00094     <span class="keywordflow">case</span> PLANCK_STRING : <span class="keywordflow">return</span> TSTRING;
00095     <span class="keywordflow">default</span>: <span class="keywordflow">throw</span> Message_error (<span class="stringliteral">"type2ftc: unsupported component type"</span>);
00096     }
00097   }
00098 <span class="comment"></span>
00099 <span class="comment">/*! Class containing information about a single column in a FITS table. */</span>
<a name="l00100"></a><a class="code" href="classfitscolumn.html">00100</a> <span class="keyword">class </span><a class="code" href="classfitscolumn.html">fitscolumn</a>
00101   {
00102   <span class="keyword">private</span>:
00103     std::string name_, unit_;
00104     int64 repcount_;
00105     <span class="keywordtype">int</span> type_;
00106 
00107   <span class="keyword">public</span>:
00108     <a class="code" href="classfitscolumn.html#a1">fitscolumn</a>()
00109       : repcount_(0), type_(-1) {}<span class="comment"></span>
00110 <span class="comment">    /*! Creates a \a fitscolumn with name \a nm, unit \a un, a repetition</span>
00111 <span class="comment">        count of \a rc, and a FITS type code of \a tp. */</span>
<a name="l00112"></a><a class="code" href="classfitscolumn.html#a1">00112</a>     <a class="code" href="classfitscolumn.html#a1">fitscolumn</a> (<span class="keyword">const</span> std::string &amp;nm, <span class="keyword">const</span> std::string &amp;un, int64 rc,
00113       <span class="keywordtype">int</span> tp)
00114       : name_(nm), unit_(un), repcount_(rc), type_(tp) {}
00115 <span class="comment"></span>
00116 <span class="comment">    /*! Returns the column name. */</span>
<a name="l00117"></a><a class="code" href="classfitscolumn.html#a2">00117</a>     <span class="keyword">const</span> std::string &amp;<a class="code" href="classfitscolumn.html#a2">name</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> name_;}<span class="comment"></span>
00118 <span class="comment">    /*! Returns the column unit string. */</span>
<a name="l00119"></a><a class="code" href="classfitscolumn.html#a3">00119</a>     <span class="keyword">const</span> std::string &amp;<a class="code" href="classfitscolumn.html#a3">unit</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> unit_;}<span class="comment"></span>
00120 <span class="comment">    /*! Returns the repetition count of the column. */</span>
<a name="l00121"></a><a class="code" href="classfitscolumn.html#a4">00121</a>     int64 <a class="code" href="classfitscolumn.html#a4">repcount</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> repcount_;}<span class="comment"></span>
00122 <span class="comment">    /*! Returns the FITS type code of the column. */</span>
<a name="l00123"></a><a class="code" href="classfitscolumn.html#a5">00123</a>     <span class="keywordtype">int</span> <a class="code" href="classfitscolumn.html#a5">type</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> type_;}
00124   };
00125 <span class="comment"></span>
00126 <span class="comment">/*! Class for performing I/O from/to FITS files. */</span>
<a name="l00127"></a><a class="code" href="classfitshandle.html">00127</a> <span class="keyword">class </span><a class="code" href="classfitshandle.html">fitshandle</a>
00128   {
00129   <span class="keyword">private</span>:
00130     <span class="keyword">enum</span> { INVALID = -4711 };
00131 
00132     <span class="keyword">mutable</span> <span class="keywordtype">int</span> status;
00133     fitsfile *fptr;
00134     <span class="keywordtype">int</span> hdutype_, bitpix_;
00135     std::vector&lt;int64&gt; axes_;
00136     std::vector&lt;fitscolumn&gt; columns_;
00137     int64 nrows_;
00138 
00139     <span class="keywordtype">void</span> check_errors() <span class="keyword">const</span>;
00140 
00141     <span class="keywordtype">void</span> clean_data();
00142     <span class="keywordtype">void</span> clean_all();
00143 
00144     <span class="keywordtype">void</span> assert_connected (<span class="keyword">const</span> std::string &amp;func)<span class="keyword"> const</span>
00145 <span class="keyword">      </span>{
00146       <a class="code" href="group__assertgroup.html#a1">planck_assert</a> (hdutype_!=INVALID,
00147         func + <span class="stringliteral">": not connected to a HDU"</span>);
00148       }
00149     <span class="keywordtype">void</span> assert_table_hdu (<span class="keyword">const</span> std::string &amp;func, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> col)<span class="keyword"> const</span>
00150 <span class="keyword">      </span>{
00151       <a class="code" href="group__assertgroup.html#a1">planck_assert</a> ((hdutype_==ASCII_TBL) || (hdutype_==BINARY_TBL),
00152         func + <span class="stringliteral">": HDU is not a table"</span>);
00153       <a class="code" href="group__assertgroup.html#a1">planck_assert</a> (col&gt;0 &amp;&amp; col&lt;=columns_.size(),
00154         func + <span class="stringliteral">": column number out of range"</span>);
00155       }
00156     <span class="keywordtype">void</span> assert_image_hdu (<span class="keyword">const</span> std::string &amp;func)<span class="keyword"> const</span>
00157 <span class="keyword">      </span>{
00158       <a class="code" href="group__assertgroup.html#a1">planck_assert</a> ((hdutype_==IMAGE_HDU), func + <span class="stringliteral">": HDU is not an image"</span>);
00159       }
00160 
00161     <span class="keywordtype">void</span> init_image();
00162     <span class="keywordtype">void</span> init_asciitab();
00163     <span class="keywordtype">void</span> init_bintab();
00164     <span class="keywordtype">void</span> init_data();
00165 
00166     <span class="keywordtype">void</span> check_key_present(<span class="keyword">const</span> std::string &amp;name)<span class="keyword">const</span> ;
00167 
00168     <span class="keywordtype">void</span> read_col (<span class="keywordtype">int</span> colnum, <span class="keywordtype">void</span> *data, int64 ndata, <span class="keywordtype">int</span> dtype,
00169                    int64 offset) <span class="keyword">const</span>;
00170     <span class="keywordtype">void</span> write_col (<span class="keywordtype">int</span> colnum, <span class="keyword">const</span> <span class="keywordtype">void</span> *data, int64 ndata, <span class="keywordtype">int</span> dtype,
00171                    int64 offset);
00172 
00173   <span class="keyword">public</span>:<span class="comment"></span>
00174 <span class="comment">    /*! the list of modes in which a \a fitshandle can be opened. */</span>
<a name="l00175"></a><a class="code" href="classfitshandle.html#w2">00175</a>     <span class="keyword">typedef</span> <span class="keyword">enum</span> { <a class="code" href="classfitshandle.html#w2w0">CREATE</a>, <span class="comment">/*!&lt; the file must not yet exist */</span>
00176                    <a class="code" href="classfitshandle.html#w2w1">OPEN</a>    <span class="comment">/*!&lt; the file must already exist */</span>
00177                  } <a class="code" href="classfitshandle.html#w2">openmethod</a>;
00178 <span class="comment"></span>
00179 <span class="comment">    /*! \name File-level access and manipulation. */</span><span class="comment"></span>
00180 <span class="comment">    /*! \{ */</span>
00181 <span class="comment"></span>
00182 <span class="comment">    /*! Creates an unconnected \a fitshandle. */</span>
<a name="l00183"></a><a class="code" href="classfitshandle.html#z1_0">00183</a>     <a class="code" href="classfitshandle.html#z1_0">fitshandle</a> ()
00184       : status(0), fptr(0), hdutype_(INVALID), bitpix_(INVALID), nrows_(0) {}<span class="comment"></span>
00185 <span class="comment">    /*! Creates a \a fitshandle connected to file \a fname.</span>
00186 <span class="comment">        If \a rwmode == READONLY, no writing access is permitted; if it is</span>
00187 <span class="comment">        READWRITE, reading and writing can be performed. */</span>
<a name="l00188"></a><a class="code" href="classfitshandle.html#z1_1">00188</a>     <a class="code" href="classfitshandle.html#z1_0">fitshandle</a> (<span class="keyword">const</span> std::string &amp;fname, openmethod mode=OPEN,
00189       <span class="keywordtype">int</span> rwmode=READONLY)
00190       : status(0), fptr(0), hdutype_(INVALID), bitpix_(INVALID), nrows_(0)
00191       {
00192       <span class="keywordflow">if</span> (mode==OPEN)
00193         <a class="code" href="classfitshandle.html#z1_4">open</a> (fname, rwmode);
00194       <span class="keywordflow">else</span>
00195         <a class="code" href="classfitshandle.html#z1_5">create</a> (fname);
00196       }<span class="comment"></span>
00197 <span class="comment">    /*! Creates a \a fitshandle connected to file \a fname and jumps directly</span>
00198 <span class="comment">        to the HDU with the number \a hdunum.</span>
00199 <span class="comment">        If \a rwmode == READONLY, no writing access is permitted; if it is</span>
00200 <span class="comment">        READWRITE, reading and writing can be performed. */</span>
<a name="l00201"></a><a class="code" href="classfitshandle.html#z1_2">00201</a>     <a class="code" href="classfitshandle.html#z1_0">fitshandle</a> (<span class="keyword">const</span> std::string &amp;fname, <span class="keywordtype">int</span> hdunum, <span class="keywordtype">int</span> rwmode=READONLY)
00202       : status(0), fptr(0), hdutype_(INVALID), bitpix_(INVALID), nrows_(0)
00203       {
00204       <a class="code" href="classfitshandle.html#z1_4">open</a> (fname, rwmode);
00205       <a class="code" href="classfitshandle.html#z1_7">goto_hdu</a> (hdunum);
00206       }
00207 <span class="comment"></span>
00208 <span class="comment">    /*! Performs all necessary cleanups. */</span>
<a name="l00209"></a><a class="code" href="classfitshandle.html#z1_3">00209</a>     <a class="code" href="classfitshandle.html#z1_3">~fitshandle</a>() { clean_all(); }
00210 <span class="comment"></span>
00211 <span class="comment">    /*! Connects to the file \a fname.</span>
00212 <span class="comment">        If \a rwmode == READONLY, no writing access is permitted; if it is</span>
00213 <span class="comment">        READWRITE, reading and writing can be performed. */</span>
00214     <span class="keywordtype">void</span> <a class="code" href="classfitshandle.html#z1_4">open</a> (<span class="keyword">const</span> std::string &amp;fname, <span class="keywordtype">int</span> rwmode=READONLY);<span class="comment"></span>
00215 <span class="comment">    /*! Creates the file \a fname and connects to it. */</span>
00216     <span class="keywordtype">void</span> <a class="code" href="classfitshandle.html#z1_5">create</a> (<span class="keyword">const</span> std::string &amp;fname);<span class="comment"></span>
00217 <span class="comment">    /*! Closes the current file. */</span>
<a name="l00218"></a><a class="code" href="classfitshandle.html#z1_6">00218</a>     <span class="keywordtype">void</span> <a class="code" href="classfitshandle.html#z1_6">close</a> () { clean_all(); }<span class="comment"></span>
00219 <span class="comment">    /*! Deletes the file with name \a name. */</span>
00220     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classfitshandle.html#z1_15">delete_file</a> (<span class="keyword">const</span> std::string &amp;name);<span class="comment"></span>
00221 <span class="comment">    /*! Jumps to the HDU with the absolute number \a hdu. */</span>
00222     <span class="keywordtype">void</span> <a class="code" href="classfitshandle.html#z1_7">goto_hdu</a> (<span class="keywordtype">int</span> hdu);<span class="comment"></span>
00223 <span class="comment">    /*! Returns the number of HDUs in the file. */</span>
00224     <span class="keywordtype">int</span> <a class="code" href="classfitshandle.html#z1_8">num_hdus</a> () <span class="keyword">const</span>;<span class="comment"></span>
00225 <span class="comment">    /*! Asserts that the PDMTYPE of the current HDU is \a pdmtype. */</span>
00226     <span class="keywordtype">void</span> <a class="code" href="classfitshandle.html#z1_9">assert_pdmtype</a> (<span class="keyword">const</span> std::string &amp;pdmtype) <span class="keyword">const</span>;<span class="comment"></span>
00227 <span class="comment">    /*! Inserts a binary table described by \a cols.</span>
00228 <span class="comment">        The HDU has the name \a extname. */</span>
00229     <span class="keywordtype">void</span> <a class="code" href="classfitshandle.html#z1_10">insert_bintab</a> (<span class="keyword">const</span> std::vector&lt;fitscolumn&gt; &amp;cols,
00230       <span class="keyword">const</span> std::string &amp;extname=<span class="stringliteral">"xtension"</span>);<span class="comment"></span>
00231 <span class="comment">    /*! Inserts an ASCII table described by \a cols. The width of the</span>
00232 <span class="comment">        columns is chosen automatically, in a way that avoids truncation.</span>
00233 <span class="comment">        The HDU has the name \a extname. */</span>
00234     <span class="keywordtype">void</span> <a class="code" href="classfitshandle.html#z1_11">insert_asctab</a> (<span class="keyword">const</span> std::vector&lt;fitscolumn&gt; &amp;cols,
00235       <span class="keyword">const</span> std::string &amp;extname=<span class="stringliteral">"xtension"</span>);<span class="comment"></span>
00236 <span class="comment">    /*! Inserts a FITS image with the type given by \a btpx and dimensions</span>
00237 <span class="comment">        given by \a Axes. */</span>
00238     <span class="keywordtype">void</span> <a class="code" href="classfitshandle.html#z1_12">insert_image</a> (<span class="keywordtype">int</span> btpx, <span class="keyword">const</span> std::vector&lt;int64&gt; &amp;Axes);<span class="comment"></span>
00239 <span class="comment">    /*! Inserts a 2D FITS image with the type given by \a btpx, whose</span>
00240 <span class="comment">        contents are given in \a data. */</span>
00241     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
00242       <span class="keywordtype">void</span> <a class="code" href="classfitshandle.html#z1_12">insert_image</a> (<span class="keywordtype">int</span> btpx, <span class="keyword">const</span> <a class="code" href="classarr2.html">arr2&lt;T&gt;</a> &amp;data);
00243 <span class="comment"></span>
00244 <span class="comment">    /*! Computes the checksum for the current HDU and writes it into the</span>
00245 <span class="comment">        header. */</span>
00246     <span class="keywordtype">void</span> <a class="code" href="classfitshandle.html#z1_14">write_checksum</a>();
00247 <span class="comment"></span>
00248 <span class="comment">    /*! \} */</span>
00249 <span class="comment"></span>
00250 <span class="comment">    /*! \name Information about the current HDU */</span><span class="comment"></span>
00251 <span class="comment">    /*! \{ */</span>
00252 <span class="comment"></span>
00253 <span class="comment">    /*! If the current HDU is an image, returns the BITPIX parameter of that</span>
00254 <span class="comment">        image, else throws an exception. */</span>
<a name="l00255"></a><a class="code" href="classfitshandle.html#z3_0">00255</a>     <span class="keywordtype">int</span> <a class="code" href="classfitshandle.html#z3_0">bitpix</a>()<span class="keyword"> const</span>
00256 <span class="keyword">      </span>{
00257       assert_image_hdu (<span class="stringliteral">"fitshandle::bitpix()"</span>);
00258       <span class="keywordflow">return</span> bitpix_;
00259       }<span class="comment"></span>
00260 <span class="comment">    /*! Returns the FITS type code for the current HDU. */</span>
<a name="l00261"></a><a class="code" href="classfitshandle.html#z3_1">00261</a>     <span class="keywordtype">int</span> <a class="code" href="classfitshandle.html#z3_1">hdutype</a>()<span class="keyword"> const </span>{<span class="keywordflow">return</span> hdutype_;}<span class="comment"></span>
00262 <span class="comment">    /*! Returns the dimensions of the current image. */</span>
<a name="l00263"></a><a class="code" href="classfitshandle.html#z3_2">00263</a>     <span class="keyword">const</span> std::vector&lt;int64&gt; &amp;<a class="code" href="classfitshandle.html#z3_2">axes</a>()<span class="keyword"> const</span>
00264 <span class="keyword">      </span>{
00265       assert_image_hdu (<span class="stringliteral">"fitshandle::axes()"</span>);
00266       <span class="keywordflow">return</span> axes_;
00267       }<span class="comment"></span>
00268 <span class="comment">    /*! Returns the name of column \a #i. */</span>
<a name="l00269"></a><a class="code" href="classfitshandle.html#z3_3">00269</a>     <span class="keyword">const</span> std::string &amp;<a class="code" href="classfitshandle.html#z3_3">colname</a>(<span class="keywordtype">int</span> i)<span class="keyword"> const</span>
00270 <span class="keyword">      </span>{
00271       assert_table_hdu(<span class="stringliteral">"fitshandle::colname()"</span>,i);
00272       <span class="keywordflow">return</span> columns_[i-1].name();
00273       }<span class="comment"></span>
00274 <span class="comment">    /*! Returns the unit of column \a #i. */</span>
<a name="l00275"></a><a class="code" href="classfitshandle.html#z3_4">00275</a>     <span class="keyword">const</span> std::string &amp;<a class="code" href="classfitshandle.html#z3_4">colunit</a>(<span class="keywordtype">int</span> i)<span class="keyword"> const</span>
00276 <span class="keyword">      </span>{
00277       assert_table_hdu(<span class="stringliteral">"fitshandle::colunit()"</span>,i);
00278       <span class="keywordflow">return</span> columns_[i-1].unit();
00279       }<span class="comment"></span>
00280 <span class="comment">    /*! Returns repetition count of column \a #i. */</span>
<a name="l00281"></a><a class="code" href="classfitshandle.html#z3_5">00281</a>     int64 <a class="code" href="classfitshandle.html#z3_5">repcount</a>(<span class="keywordtype">int</span> i)<span class="keyword"> const</span>
00282 <span class="keyword">      </span>{
00283       assert_table_hdu(<span class="stringliteral">"fitshandle::repcount()"</span>,i);
00284       <span class="keywordflow">return</span> columns_[i-1].repcount();
00285       }<span class="comment"></span>
00286 <span class="comment">    /*! Returns the FITS type code for column \a #i. */</span>
<a name="l00287"></a><a class="code" href="classfitshandle.html#z3_6">00287</a>     <span class="keywordtype">int</span> <a class="code" href="classfitshandle.html#z3_6">coltype</a>(<span class="keywordtype">int</span> i)<span class="keyword"> const</span>
00288 <span class="keyword">      </span>{
00289       assert_table_hdu(<span class="stringliteral">"fitshandle::coltype()"</span>,i);
00290       <span class="keywordflow">return</span> columns_[i-1].type();
00291       }<span class="comment"></span>
00292 <span class="comment">    /*! Returns the number of columns in the current table. */</span>
<a name="l00293"></a><a class="code" href="classfitshandle.html#z3_7">00293</a>     <span class="keywordtype">int</span> <a class="code" href="classfitshandle.html#z3_7">ncols</a>()<span class="keyword"> const</span>
00294 <span class="keyword">      </span>{
00295       assert_table_hdu(<span class="stringliteral">"fitshandle::ncols()"</span>,1);
00296       <span class="keywordflow">return</span> columns_.size();
00297       }<span class="comment"></span>
00298 <span class="comment">    /*! Returns the number of rows in the current table. */</span>
<a name="l00299"></a><a class="code" href="classfitshandle.html#z3_8">00299</a>     int64 <a class="code" href="classfitshandle.html#z3_8">nrows</a>()<span class="keyword"> const</span>
00300 <span class="keyword">      </span>{
00301       assert_table_hdu(<span class="stringliteral">"fitshandle::nrows()"</span>,1);
00302       <span class="keywordflow">return</span> nrows_;
00303       }<span class="comment"></span>
00304 <span class="comment">    /*! Returns the total number of elements (nrows*repcount)</span>
00305 <span class="comment">        in column \a #i. */</span>
<a name="l00306"></a><a class="code" href="classfitshandle.html#z3_9">00306</a>     int64 <a class="code" href="classfitshandle.html#z3_9">nelems</a>(<span class="keywordtype">int</span> i)<span class="keyword"> const</span>
00307 <span class="keyword">      </span>{
00308       assert_table_hdu(<span class="stringliteral">"fitshandle::nelems()"</span>,i);
00309       <span class="keywordflow">if</span> (columns_[i-1].type()==TSTRING) <span class="keywordflow">return</span> nrows_;
00310       <span class="keywordflow">return</span> nrows_*columns_[i-1].repcount();
00311       }
00312 <span class="comment"></span>
00313 <span class="comment">    /*! \} */</span>
00314 <span class="comment"></span>
00315 <span class="comment">    /*! \name Keyword-handling methods */</span><span class="comment"></span>
00316 <span class="comment">    /*! \{ */</span>
00317 <span class="comment"></span>
00318 <span class="comment">    /*! Copies all header keywords from the current HDU of \a orig to</span>
00319 <span class="comment">        the current HDU of \a *this. */</span>
00320     <span class="keywordtype">void</span> <a class="code" href="classfitshandle.html#z5_0">copy_header</a> (<span class="keyword">const</span> <a class="code" href="classfitshandle.html">fitshandle</a> &amp;orig);<span class="comment"></span>
00321 <span class="comment">    /*! Copies all header keywords from the current HDU of \a orig to</span>
00322 <span class="comment">        the current HDU of \a *this, prepending a HISTORY keyword to</span>
00323 <span class="comment">        every line. */</span>
00324     <span class="keywordtype">void</span> <a class="code" href="classfitshandle.html#z5_1">copy_historified_header</a> (<span class="keyword">const</span> <a class="code" href="classfitshandle.html">fitshandle</a> &amp;orig);
00325 <span class="comment"></span>
00326 <span class="comment">    /*! Returns a list of all user-defined keys in the current HDU</span>
00327 <span class="comment">        in \a keys. */</span>
00328     <span class="keywordtype">void</span> <a class="code" href="classfitshandle.html#z5_2">get_all_keys</a> (std::vector&lt;std::string&gt; &amp;keys) <span class="keyword">const</span>;
00329 <span class="comment"></span>
00330 <span class="comment">    /*! Adds a new header line consisting of \a key, \a value and</span>
00331 <span class="comment">        \a comment. */</span>
00332     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> <a class="code" href="classfitshandle.html#z5_3">add_key</a> (<span class="keyword">const</span> std::string &amp;name, <span class="keyword">const</span> T &amp;value,
00333       <span class="keyword">const</span> std::string &amp;comment=<span class="stringliteral">""</span>);<span class="comment"></span>
00334 <span class="comment">    /*! Updates \a key with \a value and \a comment. */</span>
00335     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> <a class="code" href="classfitshandle.html#z5_4">update_key</a> (<span class="keyword">const</span> std::string &amp;name,
00336       <span class="keyword">const</span> T &amp;value, <span class="keyword">const</span> std::string &amp;comment=<span class="stringliteral">""</span>);<span class="comment"></span>
00337 <span class="comment">    /*! Deletes \a key from the header. */</span>
00338     <span class="keywordtype">void</span> <a class="code" href="classfitshandle.html#z5_5">delete_key</a> (<span class="keyword">const</span> std::string &amp;name);<span class="comment"></span>
00339 <span class="comment">    /*! Adds \a comment as a comment line. */</span>
00340     <span class="keywordtype">void</span> <a class="code" href="classfitshandle.html#z5_6">add_comment</a> (<span class="keyword">const</span> std::string &amp;comment);<span class="comment"></span>
00341 <span class="comment">    /*! Reads the value belonging to \a key and returns it in \a value. */</span>
00342     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> <a class="code" href="classfitshandle.html#z5_7">get_key</a> (<span class="keyword">const</span> std::string &amp;name, T &amp;value) <span class="keyword">const</span>;<span class="comment"></span>
00343 <span class="comment">    /*! Returms the value belonging to \a key. */</span>
<a name="l00344"></a><a class="code" href="classfitshandle.html#z5_8">00344</a>     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; T <a class="code" href="classfitshandle.html#z5_7">get_key</a> (<span class="keyword">const</span> std::string &amp;name)<span class="keyword"> const</span>
00345 <span class="keyword">      </span>{ T tmp; <a class="code" href="classfitshandle.html#z5_7">get_key</a>(name, tmp); <span class="keywordflow">return</span> tmp; }<span class="comment"></span>
00346 <span class="comment">    /*! Returns \a true if \a key is present, else \a false. */</span>
00347     <span class="keywordtype">bool</span> <a class="code" href="classfitshandle.html#z5_9">key_present</a> (<span class="keyword">const</span> std::string &amp;name) <span class="keyword">const</span>;<span class="comment"></span>
00348 <span class="comment">    /*! Returns the Planck type code for the key \a name. */</span>
00349     <span class="keywordtype">int</span> <a class="code" href="classfitshandle.html#z5_10">get_key_type</a>(<span class="keyword">const</span> std::string &amp;name) <span class="keyword">const</span>;
00350 <span class="comment"></span>
00351 <span class="comment">    /*! \} */</span>
00352 <span class="comment"></span>
00353 <span class="comment">    /*! \name Methods for table data I/O */</span><span class="comment"></span>
00354 <span class="comment">    /*! \{ */</span>
00355 
00356     <span class="keywordtype">void</span> read_column_raw_void
00357       (<span class="keywordtype">int</span> colnum, <span class="keywordtype">void</span> *data, <span class="keywordtype">int</span> type, int64 num, int64 offset=0) <span class="keyword">const</span>;<span class="comment"></span>
00358 <span class="comment">    /*! Copies \a num elements from column \a colnum to the memory pointed</span>
00359 <span class="comment">        to by \a data, starting at offset \a offset in the column. */</span>
00360     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> <a class="code" href="classfitshandle.html#z7_1">read_column_raw</a>
<a name="l00361"></a><a class="code" href="classfitshandle.html#z7_1">00361</a>       (<span class="keywordtype">int</span> colnum, T *data, int64 num, int64 offset=0) <span class="keyword">const</span>
00362       { read_column_raw_void (colnum, data, typehelper&lt;T&gt;::id, num, offset); }<span class="comment"></span>
00363 <span class="comment">    /*! Fills \a data with elements from column \a colnum,</span>
00364 <span class="comment">        starting at offset \a offset in the column. */</span>
00365     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> <a class="code" href="classfitshandle.html#z7_2">read_column</a>
<a name="l00366"></a><a class="code" href="classfitshandle.html#z7_2">00366</a>       (<span class="keywordtype">int</span> colnum, <a class="code" href="classarr.html">arr&lt;T&gt;</a> &amp;data, int64 offset=0) <span class="keyword">const</span>
00367       { <a class="code" href="classfitshandle.html#z7_1">read_column_raw</a> (colnum, &amp;(data[0]), data.size(), offset); }<span class="comment"></span>
00368 <span class="comment">    /*! Reads the element \a #offset from column \a colnum into \a data. */</span>
00369     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> <a class="code" href="classfitshandle.html#z7_2">read_column</a>
<a name="l00370"></a><a class="code" href="classfitshandle.html#z7_3">00370</a>       (<span class="keywordtype">int</span> colnum, T &amp;data, int64 offset=0) <span class="keyword">const</span>
00371       { <a class="code" href="classfitshandle.html#z7_1">read_column_raw</a> (colnum, &amp;data, 1, offset); }
00372     <span class="comment">/* Reads the whole column \a colnum into \a data (which is resized</span>
00373 <span class="comment">       accordingly). */</span>
00374     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> read_entire_column
00375       (<span class="keywordtype">int</span> colnum, <a class="code" href="classarr.html">arr&lt;T&gt;</a> &amp;data) <span class="keyword">const</span>
00376       { data.alloc(<a class="code" href="classfitshandle.html#z3_9">nelems</a>(colnum)); <a class="code" href="classfitshandle.html#z7_2">read_column</a> (colnum, data); }
00377 
00378 
00379     <span class="keywordtype">void</span> write_column_raw_void
00380       (<span class="keywordtype">int</span> colnum, <span class="keyword">const</span> <span class="keywordtype">void</span> *data, <span class="keywordtype">int</span> type, int64 num, int64 offset=0);<span class="comment"></span>
00381 <span class="comment">    /*! Copies \a num elements from the memory pointed to by \a data to the</span>
00382 <span class="comment">        column \a colnum, starting at offset \a offset in the column. */</span>
00383     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> <a class="code" href="classfitshandle.html#z7_6">write_column_raw</a>
<a name="l00384"></a><a class="code" href="classfitshandle.html#z7_6">00384</a>       (<span class="keywordtype">int</span> colnum, <span class="keyword">const</span> T *data, int64 num, int64 offset=0)
00385       { write_column_raw_void (colnum, data, typehelper&lt;T&gt;::id, num, offset); }<span class="comment"></span>
00386 <span class="comment">    /*! Copies all elements from \a data to the</span>
00387 <span class="comment">        column \a colnum, starting at offset \a offset in the column. */</span>
00388     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> <a class="code" href="classfitshandle.html#z7_7">write_column</a>
<a name="l00389"></a><a class="code" href="classfitshandle.html#z7_7">00389</a>       (<span class="keywordtype">int</span> colnum, <span class="keyword">const</span> <a class="code" href="classarr.html">arr&lt;T&gt;</a> &amp;data, int64 offset=0)
00390       { <a class="code" href="classfitshandle.html#z7_6">write_column_raw</a> (colnum, &amp;(data[0]), data.size(), offset); }<span class="comment"></span>
00391 <span class="comment">    /*! Copies \a data to the column \a colnum, at the position \a offset. */</span>
00392     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> <a class="code" href="classfitshandle.html#z7_7">write_column</a>
<a name="l00393"></a><a class="code" href="classfitshandle.html#z7_8">00393</a>       (<span class="keywordtype">int</span> colnum, <span class="keyword">const</span> T &amp;data, int64 offset=0)
00394       { <a class="code" href="classfitshandle.html#z7_6">write_column_raw</a> (colnum, &amp;data, 1, offset); }
00395 <span class="comment"></span>
00396 <span class="comment">    /*! \} */</span>
00397 <span class="comment"></span>
00398 <span class="comment">    /*! \name Methods for image data I/O */</span><span class="comment"></span>
00399 <span class="comment">    /*! \{ */</span>
00400 <span class="comment"></span>
00401 <span class="comment">    /*! Reads the current image into \a data, which is resized accordingly. */</span>
00402     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> <a class="code" href="classfitshandle.html#z9_0">read_image</a> (<a class="code" href="classarr2.html">arr2&lt;T&gt;</a> &amp;data) <span class="keyword">const</span>;<span class="comment"></span>
00403 <span class="comment">    /*! Reads the current image into \a data, which is resized accordingly. */</span>
00404     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> <a class="code" href="classfitshandle.html#z9_0">read_image</a> (<a class="code" href="classarr3.html">arr3&lt;T&gt;</a> &amp;data) <span class="keyword">const</span>;<span class="comment"></span>
00405 <span class="comment">    /*! Reads a partial image, whose dimensions are given by the dimensions</span>
00406 <span class="comment">        of \a data, into data. The starting pixel indices are given by</span>
00407 <span class="comment">        \a xl and \a yl. */</span>
00408     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> <a class="code" href="classfitshandle.html#z9_2">read_subimage</a>
00409       (<a class="code" href="classarr2.html">arr2&lt;T&gt;</a> &amp;data, <span class="keywordtype">int</span> xl, <span class="keywordtype">int</span> yl) <span class="keyword">const</span>;<span class="comment"></span>
00410 <span class="comment">    /*! Fills \a data with values from the image, starting at the offset</span>
00411 <span class="comment">        \a offset in the image. The image is treated as a one-dimensional</span>
00412 <span class="comment">        array. */</span>
00413     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> <a class="code" href="classfitshandle.html#z9_2">read_subimage</a> (<a class="code" href="classarr.html">arr&lt;T&gt;</a> &amp;data, int64 offset=0)
00414       <span class="keyword">const</span>;<span class="comment"></span>
00415 <span class="comment">    /*! Writes \a data into the current image. \a data must have the same</span>
00416 <span class="comment">        dimensions as specified in the HDU. */</span>
00417     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> <a class="code" href="classfitshandle.html#z9_4">write_image</a> (<span class="keyword">const</span> <a class="code" href="classarr2.html">arr2&lt;T&gt;</a> &amp;data);<span class="comment"></span>
00418 <span class="comment">    /*! Copies \a data to the image, starting at the offset</span>
00419 <span class="comment">        \a offset in the image. The image is treated as a one-dimensional</span>
00420 <span class="comment">        array. */</span>
00421     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> <a class="code" href="classfitshandle.html#z9_5">write_subimage</a> (<span class="keyword">const</span> <a class="code" href="classarr.html">arr&lt;T&gt;</a> &amp;data,
00422       int64 offset=0);
00423 <span class="comment"></span>
00424 <span class="comment">    /*! \} */</span>
00425 
00426     <span class="keywordtype">void</span> add_healpix_keys (<span class="keywordtype">int</span> datasize);
00427   };
00428 <span class="comment"></span>
00429 <span class="comment">/*! \} */</span>
00430 
00431 <span class="comment">// announce the specialisations</span>
00432 <span class="keyword">template</span>&lt;&gt; <span class="keywordtype">void</span> <a class="code" href="classfitshandle.html#z5_3">fitshandle::add_key</a>(<span class="keyword">const</span> std::string &amp;name,
00433   <span class="keyword">const</span> <span class="keywordtype">bool</span> &amp;value, <span class="keyword">const</span> std::string &amp;comment);
00434 <span class="keyword">template</span>&lt;&gt; <span class="keywordtype">void</span> <a class="code" href="classfitshandle.html#z5_3">fitshandle::add_key</a> (<span class="keyword">const</span> std::string &amp;name,
00435   <span class="keyword">const</span> std::string &amp;value, <span class="keyword">const</span> std::string &amp;comment);
00436 <span class="keyword">template</span>&lt;&gt; <span class="keywordtype">void</span> <a class="code" href="classfitshandle.html#z5_4">fitshandle::update_key</a>(<span class="keyword">const</span> std::string &amp;name,
00437   <span class="keyword">const</span> <span class="keywordtype">bool</span> &amp;value, <span class="keyword">const</span> std::string &amp;comment);
00438 <span class="keyword">template</span>&lt;&gt; <span class="keywordtype">void</span> <a class="code" href="classfitshandle.html#z5_4">fitshandle::update_key</a> (<span class="keyword">const</span> std::string &amp;name,
00439   <span class="keyword">const</span> std::string &amp;value, <span class="keyword">const</span> std::string &amp;comment);
00440 <span class="keyword">template</span>&lt;&gt; <span class="keywordtype">void</span> <a class="code" href="classfitshandle.html#z5_7">fitshandle::get_key</a>(<span class="keyword">const</span> std::string &amp;name,<span class="keywordtype">bool</span> &amp;value) <span class="keyword">const</span>;
00441 <span class="keyword">template</span>&lt;&gt; <span class="keywordtype">void</span> <a class="code" href="classfitshandle.html#z5_7">fitshandle::get_key</a> (<span class="keyword">const</span> std::string &amp;name,
00442   std::string &amp;value) <span class="keyword">const</span>;
00443 
00444 <span class="preprocessor">#endif</span>
</pre></div><hr><address style="align: right;"><small>
Generated on Thu Nov 13 18:48:49 2008 for LevelS C++ support library
</a> </small></address>
</body>
</html>
