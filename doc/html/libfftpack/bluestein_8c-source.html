<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>bluestein.c Source File</title>
<link href="sheet.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>bluestein.c</h1><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> *  This file is part of libfftpack.</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> *  libfftpack is free software; you can redistribute it and/or modify</span>
00005 <span class="comment"> *  it under the terms of the GNU General Public License as published by</span>
00006 <span class="comment"> *  the Free Software Foundation; either version 2 of the License, or</span>
00007 <span class="comment"> *  (at your option) any later version.</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> *  libfftpack is distributed in the hope that it will be useful,</span>
00010 <span class="comment"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00012 <span class="comment"> *  GNU General Public License for more details.</span>
00013 <span class="comment"> *</span>
00014 <span class="comment"> *  You should have received a copy of the GNU General Public License</span>
00015 <span class="comment"> *  along with libfftpack; if not, write to the Free Software</span>
00016 <span class="comment"> *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
00017 <span class="comment"> */</span>
00018 
00019 <span class="comment">/*</span>
00020 <span class="comment"> *  libfftpack is being developed at the Max-Planck-Institut fuer Astrophysik</span>
00021 <span class="comment"> *  and financially supported by the Deutsches Zentrum fuer Luft- und Raumfahrt</span>
00022 <span class="comment"> *  (DLR).</span>
00023 <span class="comment"> */</span>
00024 
00025 <span class="comment">/*</span>
00026 <span class="comment"> *  Copyright (C) 2005, 2006, 2007 Max-Planck-Society</span>
00027 <span class="comment"> *  \author Martin Reinecke</span>
00028 <span class="comment"> */</span>
00029 
00030 <span class="preprocessor">#include &lt;math.h&gt;</span>
00031 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00032 <span class="preprocessor">#include "fftpack.h"</span>
00033 <span class="preprocessor">#include "bluestein.h"</span>
00034 
00035 <span class="comment">/* returns the sum of all prime factors of n */</span>
00036 <span class="keywordtype">int</span> prime_factor_sum (<span class="keywordtype">int</span> n)
00037   {
00038   <span class="keywordtype">int</span> result=0,x,limit,tmp;
00039   <span class="keywordflow">while</span> (((tmp=(n&gt;&gt;1))&lt;&lt;1)==n)
00040     { result+=2; n=tmp; }
00041 
00042   limit=sqrt(n+0.01);
00043   <span class="keywordflow">for</span> (x=3; x&lt;=limit; x+=2)
00044   <span class="keywordflow">while</span> ((tmp=(n/x))*x==n)
00045     {
00046     result+=x;
00047     n=tmp;
00048     limit=sqrt(n+0.01);
00049     }
00050   <span class="keywordflow">if</span> (n&gt;1) result+=n;
00051 
00052   <span class="keywordflow">return</span> result;
00053   }
00054 
00055 <span class="comment">/* returns the smallest composite of 2, 3 and 5 which is &gt;= n */</span>
00056 <span class="keyword">static</span> <span class="keywordtype">int</span> good_size(<span class="keywordtype">int</span> n)
00057   {
00058   <span class="keywordtype">int</span> maxfactors=1, i, j, k, f2=1, f3, f5, bestfac, guessfac;
00059   <span class="keywordflow">while</span> ((n&gt;&gt;maxfactors)&gt;0)
00060     ++maxfactors;
00061   bestfac=1&lt;&lt;maxfactors;
00062 
00063   <span class="keywordflow">for</span> (i=0; i&lt;maxfactors; ++i)
00064     {
00065     f3=1;
00066     <span class="keywordflow">for</span> (j=0; j&lt;maxfactors-i; ++j)
00067       {
00068       <span class="keywordflow">if</span> (f2*f3&gt;bestfac) <span class="keywordflow">break</span>;
00069       f5=1;
00070       <span class="keywordflow">for</span> (k=0; k&lt;maxfactors-i-j; ++k)
00071         {
00072         guessfac = f2*f3*f5;
00073         <span class="keywordflow">if</span> (guessfac&gt;=bestfac) <span class="keywordflow">break</span>;
00074         <span class="keywordflow">if</span> ((guessfac&gt;=n) &amp;&amp; (guessfac&lt;bestfac))
00075           bestfac=guessfac;
00076         f5*=5;
00077         }
00078       f3*=3;
00079       }
00080     f2*=2;
00081     }
00082   <span class="keywordflow">return</span> bestfac;
00083   }
00084 
00085 <span class="keywordtype">void</span> bluestein_i (<span class="keywordtype">int</span> n, <span class="keywordtype">double</span> **tstorage)
00086   {
00087   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span> pi=3.14159265358979323846;
00088   <span class="keywordtype">int</span> n2=good_size(n*2-1);
00089   <span class="keywordtype">int</span> m, coeff;
00090   <span class="keywordtype">double</span> angle, xn2;
00091   <span class="keywordtype">double</span> *bk, *bkf, *work;
00092   <span class="keywordtype">double</span> pibyn=pi/n;
00093   *tstorage = (<span class="keywordtype">double</span> *)malloc (<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>)*(1+2*n+8*n2+15));
00094   ((<span class="keywordtype">int</span> *)(*tstorage))[0]=n2;
00095   bk  = *tstorage+1;
00096   bkf = *tstorage+1+2*n;
00097   work= *tstorage+1+2*(n+n2);
00098 
00099 <span class="comment">/* initialize b_k */</span>
00100   bk[0] = 1;
00101   bk[1] = 0;
00102 
00103   coeff=0;
00104   <span class="keywordflow">for</span> (m=1; m&lt;n; ++m)
00105     {
00106     coeff+=2*m-1;
00107     <span class="keywordflow">if</span> (coeff&gt;=2*n) coeff-=2*n;
00108     angle = pibyn*coeff;
00109     bk[2*m] = cos(angle);
00110     bk[2*m+1] = sin(angle);
00111     }
00112 
00113 <span class="comment">/* initialize the zero-padded, Fourier transformed b_k. Add normalisation.  */</span>
00114   xn2 = 1./n2;
00115   bkf[0] = bk[0]*xn2;
00116   bkf[1] = bk[1]*xn2;
00117   <span class="keywordflow">for</span> (m=2; m&lt;2*n; m+=2)
00118     {
00119     bkf[m]   = bkf[2*n2-m]   = bk[m]   *xn2;
00120     bkf[m+1] = bkf[2*n2-m+1] = bk[m+1] *xn2;
00121     }
00122   <span class="keywordflow">for</span> (m=2*n;m&lt;=(2*n2-2*n+1);++m)
00123     bkf[m]=0.;
00124   cffti (n2,work);
00125   cfftf (n2,bkf,work);
00126   }
00127 
00128 <span class="keywordtype">void</span> bluestein (<span class="keywordtype">int</span> n, <span class="keywordtype">double</span> *data, <span class="keywordtype">double</span> *tstorage, <span class="keywordtype">int</span> isign)
00129   {
00130   <span class="keywordtype">int</span> n2=*((<span class="keywordtype">int</span> *)tstorage);
00131   <span class="keywordtype">int</span> m;
00132   <span class="keywordtype">double</span> *bk, *bkf, *akf, *work;
00133   bk  = tstorage+1;
00134   bkf = tstorage+1+2*n;
00135   work= tstorage+1+2*(n+n2);
00136   akf = tstorage+1+2*n+6*n2+15;  
00137 
00138 <span class="comment">/* initialize a_k and FFT it */</span>
00139   <span class="keywordflow">if</span> (isign&gt;0)
00140     <span class="keywordflow">for</span> (m=0; m&lt;2*n; m+=2)
00141       {
00142       akf[m]   = data[m]*bk[m]   - data[m+1]*bk[m+1];
00143       akf[m+1] = data[m]*bk[m+1] + data[m+1]*bk[m];
00144       }
00145   <span class="keywordflow">else</span>
00146     <span class="keywordflow">for</span> (m=0; m&lt;2*n; m+=2)
00147       {
00148       akf[m]   = data[m]*bk[m]   + data[m+1]*bk[m+1];
00149       akf[m+1] =-data[m]*bk[m+1] + data[m+1]*bk[m];
00150       }
00151   <span class="keywordflow">for</span> (m=2*n; m&lt;2*n2; ++m)
00152     akf[m]=0;
00153 
00154   cfftf (n2,akf,work);
00155 
00156 <span class="comment">/* do the convolution */</span>
00157   <span class="keywordflow">if</span> (isign&gt;0)
00158     <span class="keywordflow">for</span> (m=0; m&lt;2*n2; m+=2)
00159       {
00160       <span class="keywordtype">double</span> im = -akf[m]*bkf[m+1] + akf[m+1]*bkf[m];
00161       akf[m  ]  =  akf[m]*bkf[m]   + akf[m+1]*bkf[m+1];
00162       akf[m+1]  = im;
00163       }
00164   <span class="keywordflow">else</span>
00165     <span class="keywordflow">for</span> (m=0; m&lt;2*n2; m+=2)
00166       {
00167       <span class="keywordtype">double</span> im = akf[m]*bkf[m+1] + akf[m+1]*bkf[m];
00168       akf[m  ]  = akf[m]*bkf[m]   - akf[m+1]*bkf[m+1];
00169       akf[m+1]  = im;
00170       }
00171 
00172 
00173 <span class="comment">/* inverse FFT */</span>
00174   cfftb (n2,akf,work);
00175 
00176 <span class="comment">/* multiply by b_k* */</span>
00177   <span class="keywordflow">if</span> (isign&gt;0)
00178     <span class="keywordflow">for</span> (m=0; m&lt;2*n; m+=2)
00179       {
00180       data[m]   = bk[m]  *akf[m] - bk[m+1]*akf[m+1];
00181       data[m+1] = bk[m+1]*akf[m] + bk[m]  *akf[m+1];
00182       }
00183   <span class="keywordflow">else</span>
00184     <span class="keywordflow">for</span> (m=0; m&lt;2*n; m+=2)
00185       {
00186       data[m]   = bk[m]  *akf[m] + bk[m+1]*akf[m+1];
00187       data[m+1] =-bk[m+1]*akf[m] + bk[m]  *akf[m+1];
00188       }
00189   }
</pre></div><hr><address style="align: right;"><small>
Generated on Thu Nov 13 18:48:49 2008 for LevelS FFT library
</a> </small></address>
</body>
</html>
