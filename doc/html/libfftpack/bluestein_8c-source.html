<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>LevelS FFT library: bluestein.c Source File</title>
<link href="sheet.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">libfftpack</a></div>
<h1>bluestein.c</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> *  This file is part of Healpix_cxx.</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> *  Healpix_cxx is free software; you can redistribute it and/or modify</span>
00005 <span class="comment"> *  it under the terms of the GNU General Public License as published by</span>
00006 <span class="comment"> *  the Free Software Foundation; either version 2 of the License, or</span>
00007 <span class="comment"> *  (at your option) any later version.</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> *  Healpix_cxx is distributed in the hope that it will be useful,</span>
00010 <span class="comment"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00012 <span class="comment"> *  GNU General Public License for more details.</span>
00013 <span class="comment"> *</span>
00014 <span class="comment"> *  You should have received a copy of the GNU General Public License</span>
00015 <span class="comment"> *  along with Healpix_cxx; if not, write to the Free Software</span>
00016 <span class="comment"> *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
00017 <span class="comment"> *</span>
00018 <span class="comment"> *  For more information about HEALPix, see http://healpix.jpl.nasa.gov</span>
00019 <span class="comment"> */</span>
00020 
00021 <span class="comment">/*</span>
00022 <span class="comment"> *  Healpix_cxx is being developed at the Max-Planck-Institut fuer Astrophysik</span>
00023 <span class="comment"> *  and financially supported by the Deutsches Zentrum fuer Luft- und Raumfahrt</span>
00024 <span class="comment"> *  (DLR).</span>
00025 <span class="comment"> */</span>
00026 
00027 <span class="comment">/*</span>
00028 <span class="comment"> *  Copyright (C) 2005 Max-Planck-Society</span>
00029 <span class="comment"> *  \author Martin Reinecke</span>
00030 <span class="comment"> */</span>
00031 
00032 <span class="preprocessor">#include &lt;math.h&gt;</span>
00033 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00034 <span class="preprocessor">#include "fftpack.h"</span>
00035 <span class="preprocessor">#include "bluestein.h"</span>
00036 
00037 <span class="comment">/* returns the largest prime factor of n */</span>
00038 <span class="keywordtype">int</span> largest_prime_factor (<span class="keywordtype">int</span> n)
00039   {
00040   <span class="keywordtype">int</span> maxdiv=0,x,limit,tmp;
00041   <span class="keywordflow">while</span> (((tmp=(n&gt;&gt;1))&lt;&lt;1)==n)
00042     { maxdiv=2; n=tmp; }
00043 
00044   limit=sqrt(n+0.01);
00045   <span class="keywordflow">for</span> (x=3; x&lt;=limit; x+=2)
00046   <span class="keywordflow">while</span> ((tmp=(n/x))*x==n)
00047     {
00048     maxdiv=x;
00049     n=tmp;
00050     limit=sqrt(n+0.01);
00051     }
00052   <span class="keywordflow">if</span> (n&gt;maxdiv) maxdiv=n;
00053 
00054   <span class="keywordflow">return</span> maxdiv;
00055   }
00056 
00057 <span class="comment">/* returns the sum of all prime factors of n */</span>
00058 <span class="keywordtype">int</span> prime_factor_sum (<span class="keywordtype">int</span> n)
00059   {
00060   <span class="keywordtype">int</span> result=0,x,limit,tmp;
00061   <span class="keywordflow">while</span> (((tmp=(n&gt;&gt;1))&lt;&lt;1)==n)
00062     { result+=2; n=tmp; }
00063 
00064   limit=sqrt(n+0.01);
00065   <span class="keywordflow">for</span> (x=3; x&lt;=limit; x+=2)
00066   <span class="keywordflow">while</span> ((tmp=(n/x))*x==n)
00067     {
00068     result+=x;
00069     n=tmp;
00070     limit=sqrt(n+0.01);
00071     }
00072   <span class="keywordflow">if</span> (n&gt;1) result+=n;
00073 
00074   <span class="keywordflow">return</span> result;
00075   }
00076 
00077 <span class="comment">/* returns the smallest power of 2 which is &gt;= n */</span>
00078 <span class="keywordtype">int</span> nextpow2 (<span class="keywordtype">int</span> n)
00079   {
00080   <span class="keywordtype">int</span> cnt=1;
00081   <span class="keywordflow">while</span> ((n&gt;&gt;cnt)&gt;0)
00082     ++cnt;
00083   <span class="keywordflow">return</span> 1&lt;&lt;cnt;
00084   }
00085 
00086 <span class="comment">/* returns the smallest composite of 2, 3 and 5 which is &gt;= n */</span>
00087 <span class="keywordtype">int</span> good_size(<span class="keywordtype">int</span> n)
00088   {
00089   <span class="keywordtype">int</span> maxfactors=1, i, j, k, f2=1, f3, f5, bestfac, guessfac;
00090   <span class="keywordflow">while</span> ((n&gt;&gt;maxfactors)&gt;0)
00091     ++maxfactors;
00092   bestfac=1&lt;&lt;maxfactors;
00093 
00094   <span class="keywordflow">for</span> (i=0; i&lt;maxfactors; ++i)
00095     {
00096     f3=1;
00097     <span class="keywordflow">for</span> (j=0; j&lt;maxfactors-i; ++j)
00098       {
00099       <span class="keywordflow">if</span> (f2*f3&gt;bestfac) <span class="keywordflow">break</span>;
00100       f5=1;
00101       <span class="keywordflow">for</span> (k=0; k&lt;maxfactors-i-j; ++k)
00102         {
00103         guessfac = f2*f3*f5;
00104         <span class="keywordflow">if</span> (guessfac&gt;=bestfac) <span class="keywordflow">break</span>;
00105         <span class="keywordflow">if</span> ((guessfac&gt;=n) &amp;&amp; (guessfac&lt;bestfac))
00106           bestfac=guessfac;
00107         f5*=5;
00108         }
00109       f3*=3;
00110       }
00111     f2*=2;
00112     }
00113   <span class="keywordflow">return</span> bestfac;
00114   }
00115 
00116 <span class="keywordtype">void</span> bluestein_i (<span class="keywordtype">int</span> n, <span class="keywordtype">double</span> **tstorage)
00117   {
00118   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span> pi=3.14159265358979323846;
00119   <span class="keywordtype">int</span> n2=good_size(n*2-1);
00120   <span class="keywordtype">int</span> m, coeff;
00121   <span class="keywordtype">double</span> angle, xn2;
00122   <span class="keywordtype">double</span> *bk, *bkf, *work;
00123   <span class="keywordtype">double</span> pibyn=pi/n;
00124   *tstorage = (<span class="keywordtype">double</span> *)malloc (<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>)*(1+2*n+8*n2+15));
00125   ((<span class="keywordtype">int</span> *)(*tstorage))[0]=n2;
00126   bk  = *tstorage+1;
00127   bkf = *tstorage+1+2*n;
00128   work= *tstorage+1+2*(n+n2);
00129 
00130 <span class="comment">/* initialize b_k */</span>
00131   bk[0] = 1;
00132   bk[1] = 0;
00133 
00134   coeff=0;
00135   <span class="keywordflow">for</span> (m=1; m&lt;n; ++m)
00136     {
00137     coeff+=2*m-1;
00138     <span class="keywordflow">if</span> (coeff&gt;=2*n) coeff-=2*n;
00139     angle = pibyn*coeff;
00140     bk[2*m] = cos(angle);
00141     bk[2*m+1] = sin(angle);
00142     }
00143 
00144 <span class="comment">/* initialize the zero-padded, Fourier transformed b_k. Add normalisation.  */</span>
00145   xn2 = 1./n2;
00146   bkf[0] = bk[0]*xn2;
00147   bkf[1] = bk[1]*xn2;
00148   <span class="keywordflow">for</span> (m=2; m&lt;2*n; m+=2)
00149     {
00150     bkf[m]   = bkf[2*n2-m]   = bk[m]   *xn2;
00151     bkf[m+1] = bkf[2*n2-m+1] = bk[m+1] *xn2;
00152     }
00153   <span class="keywordflow">for</span> (m=2*n;m&lt;=(2*n2-2*n+1);++m)
00154     bkf[m]=0.;
00155   cffti (n2,work);
00156   cfftf (n2,bkf,work);
00157   }
00158 
00159 <span class="keywordtype">void</span> bluestein (<span class="keywordtype">int</span> n, <span class="keywordtype">double</span> *data, <span class="keywordtype">double</span> *tstorage, <span class="keywordtype">int</span> isign)
00160   {
00161   <span class="keywordtype">int</span> n2=*((<span class="keywordtype">int</span> *)tstorage);
00162   <span class="keywordtype">int</span> m;
00163   <span class="keywordtype">double</span> *bk, *bkf, *akf, *work;
00164   bk  = tstorage+1;
00165   bkf = tstorage+1+2*n;
00166   work= tstorage+1+2*(n+n2);
00167   akf = tstorage+1+2*n+6*n2+15;  
00168 
00169 <span class="comment">/* initialize a_k and FFT it */</span>
00170   <span class="keywordflow">if</span> (isign&gt;0)
00171     <span class="keywordflow">for</span> (m=0; m&lt;2*n; m+=2)
00172       {
00173       akf[m]   = data[m]*bk[m]   - data[m+1]*bk[m+1];
00174       akf[m+1] = data[m]*bk[m+1] + data[m+1]*bk[m];
00175       }
00176   <span class="keywordflow">else</span>
00177     <span class="keywordflow">for</span> (m=0; m&lt;2*n; m+=2)
00178       {
00179       akf[m]   = data[m]*bk[m]   + data[m+1]*bk[m+1];
00180       akf[m+1] =-data[m]*bk[m+1] + data[m+1]*bk[m];
00181       }
00182   <span class="keywordflow">for</span> (m=2*n; m&lt;2*n2; ++m)
00183     akf[m]=0;
00184 
00185   cfftf (n2,akf,work);
00186 
00187 <span class="comment">/* do the convolution */</span>
00188   <span class="keywordflow">if</span> (isign&gt;0)
00189     <span class="keywordflow">for</span> (m=0; m&lt;2*n2; m+=2)
00190       {
00191       <span class="keywordtype">double</span> im = -akf[m]*bkf[m+1] + akf[m+1]*bkf[m];
00192       akf[m  ]  =  akf[m]*bkf[m]   + akf[m+1]*bkf[m+1];
00193       akf[m+1]  = im;
00194       }
00195   <span class="keywordflow">else</span>
00196     <span class="keywordflow">for</span> (m=0; m&lt;2*n2; m+=2)
00197       {
00198       <span class="keywordtype">double</span> im = akf[m]*bkf[m+1] + akf[m+1]*bkf[m];
00199       akf[m  ]  = akf[m]*bkf[m]   - akf[m+1]*bkf[m+1];
00200       akf[m+1]  = im;
00201       }
00202 
00203 
00204 <span class="comment">/* inverse FFT */</span>
00205   cfftb (n2,akf,work);
00206 
00207 <span class="comment">/* multiply by b_k* */</span>
00208   <span class="keywordflow">if</span> (isign&gt;0)
00209     <span class="keywordflow">for</span> (m=0; m&lt;2*n; m+=2)
00210       {
00211       data[m]   = bk[m]  *akf[m] - bk[m+1]*akf[m+1];
00212       data[m+1] = bk[m+1]*akf[m] + bk[m]  *akf[m+1];
00213       }
00214   <span class="keywordflow">else</span>
00215     <span class="keywordflow">for</span> (m=0; m&lt;2*n; m+=2)
00216       {
00217       data[m]   = bk[m]  *akf[m] + bk[m+1]*akf[m+1];
00218       data[m+1] =-bk[m+1]*akf[m] + bk[m]  *akf[m+1];
00219       }
00220   }
</pre></div><hr><address style="align: right;"><small>
Generated on Fri Jul 8 09:37:13 2005 for LevelS FFT library
</a> </small></address>
</body>
</html>
